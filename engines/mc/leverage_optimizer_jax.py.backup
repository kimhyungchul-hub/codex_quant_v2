"""
GPU-Accelerated Leverage Optimizer using JAX Metal.

Evaluates multiple leverage candidates in parallel to find the optimal leverage
that maximizes score while accounting for different risk/reward profiles.
"""

import os
from typing import Tuple
import logging

logger = logging.getLogger(__name__)

# ✅ Safe JAX Metal configuration with error handling
_JAX_METAL_AVAILABLE = False
_JAX_INIT_ERROR = None

try:
    import jax
    import jax.numpy as jnp
    from jax import jit, vmap
    
    # ⚠️ JAX 0.8.2 has Metal GPU bugs (default_memory_space error)
    # Force CPU mode for stability
    import os
    os.environ['JAX_PLATFORMS'] = 'cpu'
    jax.config.update('jax_platform_name', 'cpu')
    jax.config.update("jax_compilation_cache_dir", "/tmp/jax_cache")
    
    logger.info("[JAX] Using CPU backend (Metal has bugs in JAX 0.8.2)")
    # Metal is disabled
    _JAX_METAL_AVAILABLE = False
        
except ImportError as e:
    _JAX_INIT_ERROR = f"JAX not available: {e}"
    logger.warning(f"[JAX] {_JAX_INIT_ERROR}")
    # Will use CPU fallback for all functions
    jax = None
    jnp = None
    jit = None
    vmap = None

# Flag to track if warm-up has been done
_WARMED_UP = False


def _warmup_jit_cache():
    """
    Warm-up JIT compilation cache on first use.
    This triggers compilation so subsequent calls are fast.
    """
    global _WARMED_UP
    if _WARMED_UP or not _JAX_METAL_AVAILABLE:
        return
    
    try:
        # Dummy call to trigger compilation
        _ = find_optimal_leverage_gpu(
            mu_annual=0.1,
            sigma_annual=0.4,
            horizon_sec=60,
            fee_base=0.0003,
            leverage_candidates=(1.0, 2.0, 5.0, 10.0, 20.0, 30.0, 50.0, 75.0, 100.0),
        )
        _WARMED_UP = True
        logger.info("[JAX_METAL] Warm-up JIT cache successful")
    except Exception as e:
        logger.warning(f"[JAX_METAL] Warm-up failed, will use CPU fallback: {e}")
        # Warm-up failure is non-critical


# Only apply @jit decorator if JAX is available
if jax is not None:
    @jit
    def compute_ev_for_leverage(
        leverage: float,
        mu_annual: float,
        sigma_annual: float,
        horizon_sec: int,
        fee_base: float,
        direction: int,
    ) -> float:
        """
        Compute expected value (EV) for a given leverage.
        
        EV = direction * mu * leverage - fee * leverage
        
        Args:
            leverage: Leverage multiplier
            mu_annual: Annual drift
            sigma_annual: Annual volatility
            horizon_sec: Horizon in seconds
            fee_base: Base fee (roundtrip)
            direction: 1 for long, -1 for short
        
        Returns:
            Expected value in ROE units
        """
        # Convert annual to per-second
        seconds_per_year = 31536000.0
        mu_ps = mu_annual / seconds_per_year
        
        # Expected return over horizon
        mu_horizon = mu_ps * float(horizon_sec)
        
        # EV = (mu * horizon) * leverage * direction - fee * leverage
        ev = direction * mu_horizon * leverage - fee_base * leverage
        return ev
else:
    # CPU-only fallback (no JIT)
    def compute_ev_for_leverage(
        leverage: float,
        mu_annual: float,
        sigma_annual: float,
        horizon_sec: int,
        fee_base: float,
        direction: int,
    ) -> float:
        import numpy as np
        seconds_per_year = 31536000.0
        mu_ps = mu_annual / seconds_per_year
        mu_horizon = mu_ps * float(horizon_sec)
        ev = direction * mu_horizon * leverage - fee_base * leverage
        return float(ev)


# Only apply @jit decorator if JAX is available
if jax is not None:
    @jit
    def compute_score_for_leverage(
        leverage: float,
        mu_annual: float,
        sigma_annual: float,
        horizon_sec: int,
        fee_base: float,
    ) -> float:
        """
        Compute score for a given leverage (simplified).
        
        Score considers both long and short EV.
        
        Args:
            leverage: Leverage multiplier
            mu_annual: Annual drift
            sigma_annual: Annual volatility
            horizon_sec: Horizon in seconds
            fee_base: Base fee
        
        Returns:
            Score value
        """
        ev_long = compute_ev_for_leverage(leverage, mu_annual, sigma_annual, horizon_sec, fee_base, 1)
        ev_short = compute_ev_for_leverage(leverage, mu_annual, sigma_annual, horizon_sec, fee_base, -1)
        
        # Simplified score: max of long/short EV
        # (In reality this would use more complex objective function)
        score = jnp.maximum(ev_long, ev_short)
        return score
else:
    # CPU-only fallback
    def compute_score_for_leverage(
        leverage: float,
        mu_annual: float,
        sigma_annual: float,
        horizon_sec: int,
        fee_base: float,
    ) -> float:
        import numpy as np
        ev_long = compute_ev_for_leverage(leverage, mu_annual, sigma_annual, horizon_sec, fee_base, 1)
        ev_short = compute_ev_for_leverage(leverage, mu_annual, sigma_annual, horizon_sec, fee_base, -1)
        score = max(ev_long, ev_short)
        return float(score)


def find_optimal_leverage_gpu(
    mu_annual: float,
    sigma_annual: float,
    horizon_sec: int = 60,
    fee_base: float = 0.0003,
    leverage_candidates: Tuple[float, ...] = (1.0, 5.0, 10.0, 20.0, 30.0, 50.0, 75.0, 100.0),
) -> Tuple[float, float]:
    """
    Find optimal leverage using GPU-accelerated parallel evaluation.
    Falls back to CPU if JAX/Metal unavailable.
    
    Args:
        mu_annual: Annual drift
        sigma_annual: Annual volatility
        horizon_sec: Horizon in seconds
        fee_base: Base fee (roundtrip)
        leverage_candidates: Tuple of leverage values to evaluate
    
    Returns:
        (optimal_leverage, optimal_score)
    """
    # If JAX not available, use CPU fallback immediately
    if jax is None or not _JAX_METAL_AVAILABLE:
        return find_optimal_leverage_cpu(
            mu_annual, sigma_annual, horizon_sec, fee_base, leverage_candidates
        )
    
    try:
        # Convert to JAX array
        lev_array = jnp.array(leverage_candidates, dtype=jnp.float32)
        
        # Vectorize score computation over leverage candidates
        score_fn = lambda lev: compute_score_for_leverage(
            lev, mu_annual, sigma_annual, horizon_sec, fee_base
        )
        
        # GPU-parallel evaluation
        scores = vmap(score_fn)(lev_array)
        
        # Find best
        best_idx = jnp.argmax(scores)
        optimal_leverage = lev_array[best_idx]
        optimal_score = scores[best_idx]
        
        return float(optimal_leverage), float(optimal_score)
        
    except Exception as e:
        # Metal error - fallback to CPU
        logger.warning(f"[JAX_METAL] GPU evaluation failed, using CPU fallback: {e}")
        return find_optimal_leverage_cpu(
            mu_annual, sigma_annual, horizon_sec, fee_base, leverage_candidates
        )


# For backward compatibility / NumPy fallback
def find_optimal_leverage_cpu(
    mu_annual: float,
    sigma_annual: float,
    horizon_sec: int = 60,
    fee_base: float = 0.0003,
    leverage_candidates: Tuple[float, ...] = (1.0, 5.0, 10.0, 20.0, 30.0, 50.0, 75.0, 100.0),
) -> Tuple[float, float]:
    """CPU fallback (non-JAX)."""
    import numpy as np
    
    best_lev = 5.0
    best_score = -float('inf')
    
    seconds_per_year = 31536000.0
    mu_ps = mu_annual / seconds_per_year
    mu_horizon = mu_ps * horizon_sec
    
    for lev in leverage_candidates:
        ev_long = mu_horizon * lev - fee_base * lev
        ev_short = -mu_horizon * lev - fee_base * lev
        score = max(ev_long, ev_short)
        
        if score > best_score:
            best_score = score
            best_lev = lev
    
    return best_lev, best_score


# Main API
def find_optimal_leverage(
    mu_annual: float,
    sigma_annual: float,
    horizon_sec: int = 60,
    fee_base: float = 0.0003,
    use_gpu: bool = True,
) -> Tuple[float, float]:
    """
    Find optimal leverage (GPU or CPU).
    
    Args:
        mu_annual: Annual drift
        sigma_annual: Annual volatility
        horizon_sec: Horizon in seconds
        fee_base: Base fee
        use_gpu: Use GPU if True, CPU otherwise
    
    Returns:
        (optimal_leverage, optimal_score)
    """
    leverage_candidates = (1.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 40.0, 50.0, 75.0, 100.0)
    
    if use_gpu:
        # ✅ Warm-up JIT compilation on first use
        _warmup_jit_cache()
        
        try:
            return find_optimal_leverage_gpu(
                mu_annual, sigma_annual, horizon_sec, fee_base, leverage_candidates
            )
        except Exception:
            # Fallback to CPU
            return find_optimal_leverage_cpu(
                mu_annual, sigma_annual, horizon_sec, fee_base, leverage_candidates
            )
    else:
        return find_optimal_leverage_cpu(
            mu_annual, sigma_annual, horizon_sec, fee_base, leverage_candidates
        )
