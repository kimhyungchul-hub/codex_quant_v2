from __future__ import annotations

import asyncio
import json
import math
import os
import random
import time
from collections import deque
from pathlib import Path
from typing import Any, Dict, Optional

import ccxt.async_support as ccxt
import numpy as np

import config
from core.data_manager import DataManager
from engines.engine_hub import EngineHub
from engines.pmaker_manager import PMakerManager
from engines.probability_methods import _approx_p_pos_and_ev_hold
from engines.mc.constants import SECONDS_PER_YEAR
from utils.helpers import _env_bool, _env_float, _env_int, _load_env_file, _load_env_file_override, _safe_float, now_ms

# Multi-timeframe scoring (RESTORED)
try:
    from core.multi_timeframe_scoring import (
        calculate_consensus_score,
        get_best_entry_tag,
    )
except ImportError:
    def calculate_consensus_score(scores_dict, weights=None):
        return 0.0

    def get_best_entry_tag(scores_multi):
        return None

from core.opportunity_scoring import (
    find_optimal_horizon,
    calculate_opportunity_score,
    extract_ev_by_horizon_from_meta,
    extract_directional_ev_by_horizon_from_meta,
    extract_signed_ev_rate_by_horizon_from_meta,
)
from core.economic_brain import Candidate, EconomicBrain
from core.continuous_opportunity import ContinuousOpportunityChecker
from core.portfolio_management import calculate_dynamic_decay_rho
from core.risk_manager import RiskManager


class LiveOrchestrator:
    def __init__(self, exchange: Any, symbols: Optional[list[str]] = None, *, data_exchange: Any = None):
        # `exchange` is the trading exchange (orders/positions/balance).
        self.exchange = exchange
        # `data_exchange` is the public-data feed exchange (prices/OHLCV/orderbook) used for MC inputs.
        # Default to the trading exchange if not provided.
        self.data_exchange = data_exchange if data_exchange is not None else exchange
        self.symbols = list(symbols) if symbols is not None else list(config.SYMBOLS)

        self.hub = EngineHub()
        self._mc_ready = True

        self._net_sem = asyncio.Semaphore(int(config.MAX_INFLIGHT_REQ))
        self.clients: set[Any] = set()
        self.logs = deque(maxlen=300)

        self.start_ms = int(now_ms())
        self.run_id = f"{self.start_ms}-{random.randint(1000, 9999)}"

        self.balance = 10_000.0
        self.positions: Dict[str, Dict[str, Any]] = {}
        self.exposure_cap_enabled = bool(getattr(config, "EXPOSURE_CAP_ENABLED", True))

        self.leverage = float(config.DEFAULT_LEVERAGE)
        self.max_leverage = float(config.MAX_LEVERAGE)
        self.enable_orders = bool(config.ENABLE_LIVE_ORDERS)
        self.decision_refresh_sec = float(_env_float("DECISION_REFRESH_SEC", float(getattr(config, "DECISION_REFRESH_SEC", 2.0))))
        # Heavy decision compute is decoupled from dashboard refresh; this sets a minimum per-symbol re-eval interval.
        self.decision_eval_min_interval_sec = float(
            _env_float("DECISION_EVAL_MIN_INTERVAL_SEC", float(self.decision_refresh_sec))
        )
        self.decision_worker_sleep_sec = float(_env_float("DECISION_WORKER_SLEEP_SEC", 0.0))

        # paper trading (no exchange orders)
        self.paper_trading_enabled = _env_bool("PAPER_TRADING", True) and (not self.enable_orders)
        self.paper_flat_on_wait = _env_bool("PAPER_FLAT_ON_WAIT", True)
        # Paper sizing: by default use orchestrator defaults (fixed size/leverage).
        # If enabled, use engine-provided optimal sizing/leverage (often Kelly-like and can be extremely small).
        self.paper_use_engine_sizing = _env_bool("PAPER_USE_ENGINE_SIZING", True)
        # If engine sizing is enabled, apply a multiplier and a floor/cap so paper positions don't become too tiny.
        self.paper_engine_size_mult = float(_env_float("PAPER_ENGINE_SIZE_MULT", 1.0))
        self.paper_engine_size_min_frac = float(_env_float("PAPER_ENGINE_SIZE_MIN_FRAC", 0.005))
        self.paper_engine_size_max_frac = float(_env_float("PAPER_ENGINE_SIZE_MAX_FRAC", 0.20))
        self.paper_size_frac_default = float(_env_float("PAPER_SIZE_FRAC", float(getattr(config, "DEFAULT_SIZE_FRAC", 0.10))))
        self.paper_leverage_default = float(_env_float("PAPER_LEVERAGE", float(getattr(config, "DEFAULT_LEVERAGE", 5.0))))
        self.paper_fee_roundtrip = float(_env_float("PAPER_FEE_ROUNDTRIP", 0.0))
        self.paper_slippage_bps = float(_env_float("PAPER_SLIPPAGE_BPS", 0.0))
        self.paper_min_hold_sec = int(_env_int("PAPER_MIN_HOLD_SEC", int(getattr(config, "POSITION_HOLD_MIN_SEC", 0))))
        self.paper_max_hold_sec = int(_env_int("PAPER_MAX_HOLD_SEC", int(getattr(config, "MAX_POSITION_HOLD_SEC", 600))))
        self.paper_max_positions = int(_env_int("PAPER_MAX_POSITIONS", int(getattr(config, "MAX_CONCURRENT_POSITIONS", 99999))))
        # If enabled, exits/flips are driven by MC exit-policy heuristics (hold_bad/score_flip/dd_stop/time_stop),
        # and legacy "WAIT->FLAT" / "max_hold" paper rules are ignored for open positions.
        self.paper_exit_policy_only = _env_bool("PAPER_EXIT_POLICY_ONLY", True)
        self.paper_exit_policy_horizon_sec_default = int(_env_int("PAPER_EXIT_POLICY_HORIZON_SEC", 1800))
        self.paper_exit_policy_min_hold_sec = int(_env_int("PAPER_EXIT_POLICY_MIN_HOLD_SEC", 180))
        self.paper_exit_policy_decision_dt_sec = int(_env_int("PAPER_EXIT_POLICY_DECISION_DT_SEC", 5))
        self.paper_exit_policy_flip_confirm_ticks = int(_env_int("PAPER_EXIT_POLICY_FLIP_CONFIRM_TICKS", 3))
        # EconomicBrain (NAPV) paper policy toggle + params
        self.paper_economic_brain_enabled = _env_bool("PAPER_ECONOMIC_BRAIN", True)
        self.paper_rf_per_sec = float(_env_float("PAPER_RF_PER_SEC", 0.0))
        self.paper_economic_switch_buffer = float(_env_float("PAPER_ECONOMIC_SWITCH_BUFFER", 0.0002))
        self.paper_exit_policy_hold_bad_ticks = int(_env_int("PAPER_EXIT_POLICY_HOLD_BAD_TICKS", 3))
        self.paper_exit_policy_score_margin = float(_env_float("PAPER_EXIT_POLICY_SCORE_MARGIN", 0.0001))
        self.paper_exit_policy_soft_floor = float(_env_float("PAPER_EXIT_POLICY_SOFT_FLOOR", -0.001))
        self.paper_exit_policy_p_pos_enter_floor = float(_env_float("PAPER_EXIT_POLICY_P_POS_ENTER_FLOOR", 0.52))
        self.paper_exit_policy_p_pos_hold_floor = float(_env_float("PAPER_EXIT_POLICY_P_POS_HOLD_FLOOR", 0.50))
        self.paper_exit_policy_dd_stop_enabled = _env_bool("PAPER_EXIT_POLICY_DD_STOP_ENABLED", True)
        self.paper_exit_policy_dd_stop_roe = float(_env_float("PAPER_EXIT_POLICY_DD_STOP_ROE", -0.02))
        self.paper_rebalance_interval_ms = int(_env_int("PAPER_REBALANCE_INTERVAL_MS", 5000))
        self.paper_rebalance_min_cap_diff = float(_env_float("PAPER_REBALANCE_MIN_CAP_DIFF", 0.10))
        self.paper_rebalance_min_notional_frac = float(_env_float("PAPER_REBALANCE_MIN_NOTIONAL_FRAC", 0.02))
        self.paper_rebalance_fee_mult = float(_env_float("PAPER_REBALANCE_FEE_MULT", 1.25))
        # Hard stop loss:
        # - PRICE_FRAC: unlevered price move vs entry (e.g., -2% move)
        # - ROE_FRAC: ROE/margin drawdown (levered), which users often mean by "2% hard cap"
        # Back-compat: if the new vars are not set, reuse HARD_STOP_LOSS_FRAC for both.
        self.hard_stop_loss_frac = float(_env_float("HARD_STOP_LOSS_FRAC", 0.02))
        self.hard_stop_loss_price_frac = float(_env_float("HARD_STOP_LOSS_PRICE_FRAC", float(self.hard_stop_loss_frac)))
        self.hard_stop_loss_roe_frac = float(_env_float("HARD_STOP_LOSS_ROE_FRAC", float(self.hard_stop_loss_frac)))
        try:
            self.hard_stop_loss_price_frac = float(max(0.0, min(1.0, float(self.hard_stop_loss_price_frac))))
        except Exception:
            self.hard_stop_loss_price_frac = float(max(0.0, min(1.0, float(self.hard_stop_loss_frac))))
        try:
            self.hard_stop_loss_roe_frac = float(max(0.0, min(1.0, float(self.hard_stop_loss_roe_frac))))
        except Exception:
            self.hard_stop_loss_roe_frac = float(max(0.0, min(1.0, float(self.hard_stop_loss_frac))))
        # Dashboard-only (no execution) target refresh rate for Kelly targets.
        # Keep this faster than `paper_rebalance_interval_ms` so TGT UTIL% updates in near real-time.
        self.rebalance_targets_interval_ms = int(_env_int("REBALANCE_TARGETS_INTERVAL_MS", 1000))
        self.rebalance_target_ema_alpha = float(_env_float("REBALANCE_TARGET_EMA_ALPHA", 0.2))

        # Live state sync (exchange -> dashboard/strategy state)
        self.live_sync_enabled = _env_bool("LIVE_SYNC_ENABLED", True)
        self.live_sync_interval_ms = int(_env_int("LIVE_SYNC_INTERVAL_MS", 1200))
        self.live_order_pending_ms = int(_env_int("LIVE_ORDER_PENDING_MS", 30000))
        self._live_pending_until_ms: Dict[str, int] = {}
        self._live_warn_last_ms: Dict[str, int] = {}
        self._live_warn_interval_ms = int(_env_int("LOG_LIVE_SYNC_WARN_INTERVAL_SEC", 60) * 1000)
        self._last_live_sync_ms = 0
        self._last_live_sync_err: Optional[str] = None
        self._live_wallet_balance: Optional[float] = None
        self._live_equity: Optional[float] = None
        self._live_free_balance: Optional[float] = None
        self._live_total_initial_margin: Optional[float] = None
        self._live_total_maintenance_margin: Optional[float] = None
        # Bybit can report a very old `createdTime` for positions (even after close/reopen).
        # Track "open time" ourselves based on exchange state transitions so dashboard hold-time is sane.
        self._live_pos_open_time_ms: Dict[str, int] = {}
        # When we submit live orders, remember "why" so ENTER/EXIT events can show reasons on the tape.
        self._live_pending_entry_reason: Dict[str, str] = {}
        self._live_pending_exit_reason: Dict[str, str] = {}
        # Live FLIP/SWITCH execution needs a 2-step flow: close first, then (after live sync confirms close)
        # enter the new position. Otherwise we can oversubscribe margin/notional or accidentally hedge.
        self._live_pending_rotations: Dict[str, Dict[str, Any]] = {}
        self._live_rotation_expire_ms = int(_env_int("LIVE_ROTATION_EXPIRE_MS", 120_000))
        self._live_rotation_attempt_dt_ms = int(_env_int("LIVE_ROTATION_ATTEMPT_DT_MS", 3_000))
        self._last_live_rotation_process_ms = 0
        # Live leverage control:
        # - Bybit sometimes leaves positions at 1x if leverage isn't applied correctly.
        # - Track desired leverage per symbol and throttle set_leverage calls.
        self.live_leverage_min_interval_ms = int(_env_int("LIVE_LEVERAGE_MIN_INTERVAL_MS", 15_000))
        self._live_leverage_target: Dict[str, float] = {}
        self._live_leverage_last_set_ms: Dict[str, int] = {}
        # Manual pause: used by dashboard actions like "liquidate all" to prevent immediate re-entry.
        # While paused, only reduceOnly orders are allowed.
        self._manual_pause_until_ms = 0
        self.manual_pause_after_liquidate_ms = int(_env_int("MANUAL_PAUSE_AFTER_LIQUIDATE_MS", 120_000))
        # UI/ops notes for live positions (e.g. low-liquidity close orders waiting to fill).
        self.live_close_note_ttl_ms = int(_env_int("LIVE_CLOSE_NOTE_TTL_MS", 300_000))
        self._live_close_note_by_sym: Dict[str, Dict[str, Any]] = {}
        # Live open-order cleanup (prevents margin ratio getting stuck due to unfilled entry LIMIT orders).
        # - Only cancels non-reduceOnly orders.
        # - Triggered when margin ratio is high or when we see insufficient margin errors.
        self.live_open_order_cleanup_enabled = _env_bool("LIVE_OPEN_ORDER_CLEANUP", True)
        self.live_open_order_cleanup_interval_ms = int(_env_int("LIVE_OPEN_ORDER_CLEANUP_INTERVAL_MS", 5_000))
        self.live_open_order_stale_ms = int(_env_int("LIVE_OPEN_ORDER_STALE_MS", 15_000))
        self.live_open_order_cleanup_max_cancel = int(_env_int("LIVE_OPEN_ORDER_CLEANUP_MAX_CANCEL", 25))
        self._last_live_open_order_cleanup_ms = 0
        self._live_force_open_order_cleanup_until_ms = 0
        self._live_force_open_order_cleanup_reason = ""
        # Live margin budget control (prevents "ab not enough for new order" spam).
        # `cap_frac` is treated as a fraction of wallet used as margin, so sum(cap_frac) must be <= 1.
        self.live_max_margin_frac = float(_env_float("LIVE_MAX_MARGIN_FRAC", 0.95))
        self.live_margin_reserve_ms = int(_env_int("LIVE_MARGIN_RESERVE_MS", 5_000))
        self._live_margin_reserved_by_sym: Dict[str, Dict[str, float]] = {}
        self._live_notional_reserved_by_sym: Dict[str, Dict[str, float]] = {}
        # Cross-margin total leverage cap (total_notional / total_equity).
        # User-tunable via env; default 10x unless overridden.
        self.max_total_leverage = float(_env_float("MAX_TOTAL_LEVERAGE", 10.0))

        # MC runtime tuning (ctx/instance overrides)
        self.mc_n_paths_live = int(_env_int("MC_N_PATHS_LIVE", int(getattr(config, "MC_N_PATHS_LIVE", 10000))))
        self.mc_n_paths_exit = int(_env_int("MC_N_PATHS_EXIT", int(getattr(config, "MC_N_PATHS_EXIT", 512))))
        self.mc_use_jax = _env_bool("MC_USE_JAX", True)
        self.mc_tail_mode = str(os.environ.get("MC_TAIL_MODE", "student_t")).strip().lower() or "student_t"
        self.mc_student_t_df = float(_env_float("MC_STUDENT_T_DF", 6.0))
        self._last_trade_event_by_sym: Dict[str, str] = {}

        self.exec_stats: Dict[str, Dict[str, Any]] = {}
        self.trade_tape = deque(maxlen=20_000)
        self._equity_history = deque(maxlen=20_000)
        self._last_rebalance_ts = 0
        self._last_rebalance_targets_ts = 0
        self._rebalance_in_progress = False
        self._rebalance_targets: Dict[str, float] = {}
        self._cap_frac_ema: Dict[str, float] = {}

        self._loop_ms: Optional[int] = None
        self._last_rows: Optional[list[Dict[str, Any]]] = None
        self._decision_cache: Dict[str, Dict[str, Any]] = {}
        self._last_decision: Optional[Dict[str, Any]] = None
        self._decision_rr_index: int = 0
        self._decide_cycle_ms: Optional[int] = None
        
        # Group and Rank tracking (RESTORED)
        self._group_info: Dict[str, Dict[str, Any]] = {}  # {symbol: {group: TOP10/OTHER, boost: 1.0, cap: 0.25}}
        self._latest_rankings: list[str] = []  # [sym1, sym2, ...] ordered by rank
        self._last_group_update_ts = 0
        self._entry_order_counter = 0  # For unique entry tracking
        self._pos_meta: Dict[str, Dict[str, Any]] = {}

        # -----------------------------
        # Mode namespaces (paper vs live)
        #
        # The dashboard and trading loops historically shared a single in-memory
        # tape/equity/positions store. If the user toggles "Live Orders" at runtime,
        # paper and live state can get mixed (especially charts), making equity/balance
        # look like it's "from our records" instead of the exchange. Keep them separate.
        # -----------------------------
        self._paper_state_loaded = False

        self._paper_balance: float = float(self.balance)
        self._paper_positions: Dict[str, Dict[str, Any]] = self.positions
        self._paper_pos_meta: Dict[str, Dict[str, Any]] = self._pos_meta
        self._paper_trade_tape = self.trade_tape
        self._paper_equity_history = self._equity_history

        self._live_balance: float = 0.0
        self._live_positions: Dict[str, Dict[str, Any]] = {}
        self._live_pos_meta: Dict[str, Dict[str, Any]] = {}
        self._live_trade_tape = deque(maxlen=self.trade_tape.maxlen)
        self._live_equity_history = deque(maxlen=self._equity_history.maxlen)

        self._record_mode = "live" if bool(self.enable_orders) else "paper"
        if self._record_mode == "live":
            self.balance = float(self._live_balance)
            self.positions = self._live_positions
            self._pos_meta = self._live_pos_meta
            self.trade_tape = self._live_trade_tape
            self._equity_history = self._live_equity_history
        else:
            # Paper mode: use paper namespaces and clear live state
            self.balance = float(self._paper_balance)
            self.positions = self._paper_positions
            self._pos_meta = self._paper_pos_meta
            self.trade_tape = self._paper_trade_tape
            self._equity_history = self._paper_equity_history
            
            self._live_positions.clear()
            self._live_pos_meta.clear()
            self._live_trade_tape.clear()
            self._live_equity_history.clear()
            
            # Load persisted Paper state (balance, positions, trade_tape, equity_history)
            try:
                self._load_persisted_state()
                self._paper_state_loaded = True
            except Exception as e:
                self._log(f"[WARN] Failed to load persisted state: {e}")
        
        # Multi-timeframe score tracking (RESTORED)
        from collections import defaultdict
        self._symbol_scores_multi: Dict[str, Dict[str, float]] = {}  # {symbol: {'5m': score, '10m': score, ...}}
        self._symbol_scores: Dict[str, float] = {}  # {symbol: consensus_score}
        self._symbol_t_star: Dict[str, float] = {}  # {symbol: optimal_horizon_T*}
        self._symbol_best_side: Dict[str, str] = {}  # {symbol: "LONG"|"SHORT"} for best Score_A
        self._score_update_time: Dict[str, int] = {}  # {symbol: timestamp_ms}
        self._score_history: Dict[str, deque] = defaultdict(lambda: deque(maxlen=1000))  # For covariance calculation

        self.dashboard = None  # set in main
        self.data = DataManager(self, self.symbols)

        # Back-compat aliases (some modules still reference orch.market/orderbook directly)
        self.market = self.data.market
        self.ohlcv_buffer = self.data.ohlcv_buffer
        self.orderbook = self.data.orderbook
        self._last_kline_ok_ms = self.data._last_kline_ok_ms

        # Risk manager (live cross-margin guardrails)
        self.risk = RiskManager(self)

        self.pmaker = PMakerManager(self)
        self._apply_mc_runtime_to_engines()
        
        # Opportunity Replacement (RESTORED)
        self._opportunity_checker = ContinuousOpportunityChecker(self)
        
        # Position Refill System (Auto-reentry after exit)
        self._last_exit_time: Dict[str, int] = {}  # {symbol: timestamp_ms} for cooldown
        self._exit_cooldown_ms = 60000  # 60 seconds cooldown before re-entry
        self._max_positions = 10  # Maximum number of positions to maintain

        # PMaker paper-mode self-training (simulated maker fills).
        # 목적: paper에서도 심볼별 fill_rate 통계를 누적해서 mu_alpha 보정/대시보드 표시가 가능하도록 함.
        self.pmaker_paper_enabled = _env_bool("PMAKER_PAPER_ENABLE", True)
        self.pmaker_paper_probe_interval_sec = float(_env_float("PMAKER_PAPER_PROBE_INTERVAL_SEC", 2.0))
        self.pmaker_paper_probe_timeout_ms = int(_env_int("PMAKER_PAPER_PROBE_TIMEOUT_MS", int(getattr(config, "MAKER_TIMEOUT_MS", 1500))))
        self.pmaker_paper_train_every_n = int(_env_int("PMAKER_PAPER_TRAIN_EVERY_N", 25))
        self.pmaker_paper_save_every_sec = float(_env_float("PMAKER_PAPER_SAVE_EVERY_SEC", 30.0))
        self._pmaker_paper_active: Dict[str, Dict[str, Any]] = {}
        self._pmaker_paper_next_side: Dict[str, str] = {}
        self._pmaker_paper_last_start_ms: Dict[str, int] = {}
        self._pmaker_paper_updates = 0
        self._pmaker_paper_last_save_ms = 0

        # persistence
        self.state_dir = config.BASE_DIR / "state"
        self.state_dir.mkdir(exist_ok=True)
        self.state_files = {
            "equity": self.state_dir / "equity_history.json",
            "trade": self.state_dir / "trade_tape.json",
            "positions": self.state_dir / "positions.json",
            "balance": self.state_dir / "balance.json",
        }
        self._last_state_persist_ms = 0
        self._load_persisted_state()

    def _live_is_pending(self, sym: str, ts_ms: int) -> bool:
        try:
            until = int(self._live_pending_until_ms.get(sym, 0) or 0)
        except Exception:
            until = 0
        return int(ts_ms) < int(until)

    def _live_mark_pending(self, sym: str, ts_ms: int) -> None:
        try:
            dur = int(getattr(self, "live_order_pending_ms", 0) or 0)
        except Exception:
            dur = 0
        if dur <= 0:
            return
        self._live_pending_until_ms[str(sym)] = int(ts_ms) + int(dur)

    def _manual_pause_orders(self, ts_ms: int, *, duration_ms: Optional[int] = None, reason: str = "") -> None:
        try:
            dur = int(duration_ms) if duration_ms is not None else int(self.manual_pause_after_liquidate_ms)
        except Exception:
            dur = int(self.manual_pause_after_liquidate_ms)
        dur = int(max(0, dur))
        until = int(ts_ms) + dur
        if until > int(self._manual_pause_until_ms):
            self._manual_pause_until_ms = int(until)
        try:
            msg = f"[PAUSE] Manual order pause for {dur}ms"
            if reason:
                msg += f": {reason}"
            self._log(msg)
        except Exception:
            pass

    def _manual_pause_active(self, ts_ms: int) -> bool:
        try:
            return int(ts_ms) < int(self._manual_pause_until_ms)
        except Exception:
            return False

    def _best_detail_from_cache(self, sym: str) -> Optional[Dict[str, Any]]:
        cached = self._decision_cache.get(str(sym)) or {}
        decision = cached.get("decision")
        if not isinstance(decision, dict):
            return None
        details = decision.get("details", []) if isinstance(decision.get("details", []), list) else []
        cand = [d for d in details if isinstance(d, dict)]
        if cand:
            try:
                return max(cand, key=lambda d: float(d.get("ev", 0.0) or 0.0))
            except Exception:
                return cand[0]
        return decision

    def _queue_live_rotation(
        self,
        *,
        from_sym: str,
        target_sym: str,
        target_side: str,
        cap_frac: float,
        leverage_hint: Optional[float],
        reason: str,
        ts_ms: int,
    ) -> None:
        if not (self.enable_orders and (not self.paper_trading_enabled)):
            return
        f = str(from_sym or "").strip()
        t = str(target_sym or "").strip()
        s = str(target_side or "").upper()
        if not f or not t or s not in ("LONG", "SHORT"):
            return
        now = int(ts_ms)
        prev = self._live_pending_rotations.get(f)
        self._live_pending_rotations[f] = {
            "from_sym": f,
            "target_sym": t,
            "target_side": s,
            "cap_frac": float(max(0.0, min(1.0, float(cap_frac)))),
            "leverage_hint": float(leverage_hint) if leverage_hint is not None else None,
            "reason": str(reason or ""),
            "created_ms": int(prev.get("created_ms") if isinstance(prev, dict) and prev.get("created_ms") is not None else now),
            "updated_ms": int(now),
            "last_attempt_ms": int(prev.get("last_attempt_ms") if isinstance(prev, dict) and prev.get("last_attempt_ms") is not None else 0),
            "attempts": int(prev.get("attempts") if isinstance(prev, dict) and prev.get("attempts") is not None else 0),
        }
        try:
            self._log(f"[LIVE_ROTATE] Queued {f} -> {t} {s} (cap={float(cap_frac):.3f} lev_hint={leverage_hint})")
        except Exception:
            pass

    def _process_live_pending_rotations(self, *, ts_ms: int) -> None:
        if not (self.enable_orders and (not self.paper_trading_enabled)):
            return
        now = int(ts_ms)
        if (now - int(self._last_live_rotation_process_ms or 0)) < 200:
            return
        self._last_live_rotation_process_ms = now

        if not self._live_pending_rotations:
            return

        # Drop expired items.
        expire_ms = int(max(10_000, int(self._live_rotation_expire_ms)))
        for from_sym, info in list(self._live_pending_rotations.items()):
            try:
                created = int(info.get("created_ms") or 0)
            except Exception:
                created = 0
            if created and (now - created) > expire_ms:
                try:
                    self._log_err(f"[LIVE_ROTATE] Dropped expired rotation: {from_sym} -> {info.get('target_sym')}")
                except Exception:
                    pass
                self._live_pending_rotations.pop(from_sym, None)

        # Execute when the source position is confirmed closed on exchange (i.e., not in self.positions).
        attempt_dt = int(max(500, int(self._live_rotation_attempt_dt_ms)))
        for from_sym, info in list(self._live_pending_rotations.items()):
            if from_sym in (self.positions or {}):
                continue
            if not isinstance(info, dict):
                self._live_pending_rotations.pop(from_sym, None)
                continue
            try:
                last_attempt = int(info.get("last_attempt_ms") or 0)
            except Exception:
                last_attempt = 0
            if last_attempt and (now - last_attempt) < attempt_dt:
                continue

            target_sym = str(info.get("target_sym") or "").strip()
            target_side = str(info.get("target_side") or "").upper()
            if not target_sym or target_side not in ("LONG", "SHORT"):
                self._live_pending_rotations.pop(from_sym, None)
                continue
            if target_sym in (self.positions or {}):
                # Target already open (maybe manual entry); drop.
                self._live_pending_rotations.pop(from_sym, None)
                continue

            # Snapshot prices for entry sizing.
            price_t, _closes_t, _candles_t, bid_t, ask_t, _spread_t = self._snapshot_inputs(target_sym)
            mark_t = self._mark_price(bid_t, ask_t, float(price_t) if price_t is not None else None)
            target_detail = self._best_detail_from_cache(target_sym)
            px_entry, exec_tag_entry = self._paper_fill_price(
                side=target_side,
                leg="entry",
                best_bid=bid_t,
                best_ask=ask_t,
                mark_price=mark_t,
                detail=target_detail,
            )
            if px_entry is None:
                # No usable price snapshot yet; retry later.
                info["last_attempt_ms"] = now
                info["attempts"] = int(info.get("attempts") or 0) + 1
                continue

            cap_frac = float(info.get("cap_frac") or self.paper_size_frac_default)
            lev = None
            try:
                lev = info.get("leverage_hint")
            except Exception:
                lev = None
            leverage = float(lev) if lev is not None and float(lev) > 0 else float(self.paper_leverage_default)
            if target_detail is not None:
                try:
                    lev_opt = target_detail.get("optimal_leverage")
                    if lev_opt is not None and float(lev_opt) > 0:
                        leverage = float(lev_opt)
                except Exception:
                    pass

            base_reason = str(info.get("reason") or "").strip()
            if not base_reason:
                base_reason = f"live_rotate({from_sym}->{target_sym})"
            reason = f"{base_reason} | entry_exec={exec_tag_entry}"

            before_pending = self._live_is_pending(target_sym, now)
            self._open_position(
                sym=target_sym,
                side=target_side,
                entry_price=float(px_entry),
                ts_ms=now,
                cap_frac=cap_frac,
                leverage=leverage,
                fee_roundtrip=float(self.paper_fee_roundtrip),
                reason=reason,
                detail=target_detail,
            )
            info["last_attempt_ms"] = now
            info["attempts"] = int(info.get("attempts") or 0) + 1

            after_pending = self._live_is_pending(target_sym, now)
            if (not before_pending) and after_pending:
                try:
                    self._log(f"[LIVE_ROTATE] Executed {from_sym} -> {target_sym} {target_side}")
                except Exception:
                    pass
                self._live_pending_rotations.pop(from_sym, None)
            else:
                # If it keeps failing (blocked by guards), eventually drop to avoid infinite retries.
                if int(info.get("attempts") or 0) >= 40:
                    try:
                        self._log_err(f"[LIVE_ROTATE] Dropped after too many attempts: {from_sym} -> {target_sym}")
                    except Exception:
                        pass
                    self._live_pending_rotations.pop(from_sym, None)

    def _extract_usdt_wallet_equity_from_balance(self, bal: Any) -> tuple[Optional[float], Optional[float], Optional[float]]:
        wallet = None
        equity = None
        free = None
        try:
            if isinstance(bal, dict):
                usdt = bal.get("USDT")
                if isinstance(usdt, dict):
                    try:
                        free = float(usdt.get("free")) if usdt.get("free") is not None else None
                    except Exception:
                        free = None
                    try:
                        # This is ccxt's computed total; may be wallet/equity depending on venue.
                        equity = float(usdt.get("total")) if usdt.get("total") is not None else None
                    except Exception:
                        equity = None
                info = bal.get("info")
                if isinstance(info, dict):
                    res = info.get("result")
                    if isinstance(res, dict):
                        lst = res.get("list")
                        if isinstance(lst, list) and lst:
                            item = lst[0]
                            if isinstance(item, dict):
                                try:
                                    wallet = float(item.get("totalWalletBalance")) if item.get("totalWalletBalance") is not None else wallet
                                except Exception:
                                    pass
                                try:
                                    equity = float(item.get("totalEquity")) if item.get("totalEquity") is not None else equity
                                except Exception:
                                    pass
                                try:
                                    # Bybit UNIFIED: prefer totalAvailableBalance; fallback to availableBalance.
                                    if item.get("totalAvailableBalance") is not None:
                                        free = float(item.get("totalAvailableBalance"))
                                    elif item.get("availableBalance") is not None:
                                        free = float(item.get("availableBalance"))
                                except Exception:
                                    pass
        except Exception:
            pass
        return wallet, equity, free

    def _extract_margin_metrics_from_balance(self, bal: Any) -> tuple[Optional[float], Optional[float]]:
        """
        Parse Bybit UNIFIED account balance payload to extract margin metrics.
        Returns (total_initial_margin, total_maintenance_margin).
        """
        im = None
        mm = None
        try:
            if isinstance(bal, dict):
                info = bal.get("info")
                if isinstance(info, dict):
                    res = info.get("result")
                    if isinstance(res, dict):
                        lst = res.get("list")
                        if isinstance(lst, list) and lst:
                            item = lst[0]
                            if isinstance(item, dict):
                                try:
                                    if item.get("totalInitialMargin") is not None:
                                        im = float(item.get("totalInitialMargin"))
                                except Exception:
                                    im = None
                                try:
                                    if item.get("totalMaintenanceMargin") is not None:
                                        mm = float(item.get("totalMaintenanceMargin"))
                                except Exception:
                                    mm = None
        except Exception:
            pass
        return im, mm

    def _normalize_ccxt_position(self, p: Dict[str, Any], ts_ms: int) -> Optional[Dict[str, Any]]:
        if not isinstance(p, dict):
            return None
        sym = p.get("symbol")
        if not sym:
            return None
        try:
            contracts = float(p.get("contracts") or 0.0)
        except Exception:
            contracts = 0.0
        if abs(contracts) <= 0.0:
            return None
        side_raw = str(p.get("side") or "").lower()
        side = "LONG" if side_raw in ("long", "buy") else ("SHORT" if side_raw in ("short", "sell") else None)
        if side is None:
            return None

        def _f(x):
            try:
                v = float(x) if x is not None else None
            except Exception:
                v = None
            if v is None or (not math.isfinite(v)):
                return None
            return float(v)

        entry = _f(p.get("entryPrice")) or 0.0
        mark = _f(p.get("markPrice")) or _f(p.get("lastPrice")) or 0.0
        notional = _f(p.get("notional"))
        if notional is None:
            notional = abs(float(contracts)) * float(mark)

        margin = _f(p.get("initialMargin")) or 0.0
        lev = _f(p.get("leverage"))
        if lev is None:
            lev = (float(notional) / float(margin)) if margin > 0 else float(self.leverage)

        unreal = _f(p.get("unrealizedPnl")) or 0.0

        created_ms = None
        position_idx = None
        info = p.get("info")
        if isinstance(info, dict):
            try:
                created_ms = int(info.get("createdTime")) if info.get("createdTime") is not None else None
            except Exception:
                created_ms = None
            try:
                position_idx = int(info.get("positionIdx")) if info.get("positionIdx") is not None else None
            except Exception:
                position_idx = None

        t0_exchange = int(created_ms) if created_ms else int(p.get("timestamp") or ts_ms)
        age = max(0.0, (int(ts_ms) - int(t0_exchange)) / 1000.0)

        return {
            "symbol": str(sym),
            "side": side,
            "entry_price": float(entry),
            "entry": float(entry),
            "time": int(t0_exchange),
            "exchange_time": int(t0_exchange),
            "position_idx": position_idx,
            "leverage": float(lev) if lev is not None else float(self.leverage),
            "cap_frac": None,  # filled after balance sync (margin / wallet)
            "margin": float(margin),
            "notional": float(notional),
            "size": float(contracts),
            "quantity": float(contracts),
            "current": float(mark),
            "price": float(mark),
            "unrealized_pnl": float(unreal),
            "pnl": float(unreal),
            "roe": float(unreal) / float(margin) if margin > 0 else 0.0,
            "age_sec": float(age),
        }

    async def live_sync_loop(self) -> None:
        while True:
            try:
                if (not self.live_sync_enabled) or (not getattr(self, "exchange", None)) or (not bool(self.enable_orders)):
                    await asyncio.sleep(0.5)
                    continue

                ts_ms = now_ms()

                # Balance
                try:
                    bal = await self._ccxt_call("fetch_balance(live_sync)", self.exchange.fetch_balance)
                    wallet, equity, free = self._extract_usdt_wallet_equity_from_balance(bal)
                    im, mm = self._extract_margin_metrics_from_balance(bal)
                    # Use wallet balance for sizing (tradable collateral for USDT-settled perps),
                    # and keep total account equity separately for dashboard curves.
                    if wallet is not None:
                        self.balance = float(wallet)
                    elif equity is not None:
                        self.balance = float(equity)
                    self._live_wallet_balance = wallet
                    self._live_equity = equity
                    self._live_free_balance = free
                    self._live_total_initial_margin = im
                    self._live_total_maintenance_margin = mm
                    try:
                        self.risk.update_account_summary(
                            wallet_balance=wallet,
                            total_equity=equity,
                            free_balance=free,
                            total_initial_margin=im,
                            total_maintenance_margin=mm,
                        )
                    except Exception:
                        pass
                    # If margin ratio is high (or we recently hit insufficient margin), cancel non-reduceOnly open
                    # orders to free initial margin. This prevents util/cap_frac from getting "stuck" low.
                    try:
                        mr = getattr(self.risk, "get_margin_ratio", lambda: None)()
                    except Exception:
                        mr = None
                    try:
                        force_until = int(getattr(self, "_live_force_open_order_cleanup_until_ms", 0) or 0)
                    except Exception:
                        force_until = 0
                    force = False
                    reason = ""
                    try:
                        guard = float(getattr(self.risk, "margin_ratio_guard", 0.80))
                    except Exception:
                        guard = 0.80
                    if mr is not None and float(mr) > float(guard):
                        force = True
                        reason = f"margin_ratio_guard mr={float(mr):.3f}"
                    if force_until > int(ts_ms):
                        force = True
                        r = str(getattr(self, "_live_force_open_order_cleanup_reason", "") or "").strip()
                        if r:
                            reason = r
                    if force:
                        await self._cleanup_live_open_orders(int(ts_ms), reason=reason or "risk_guard", force=True)
                    try:
                        self._live_balance = float(wallet) if wallet is not None else (float(equity) if equity is not None else float(self._live_balance))
                    except Exception:
                        pass
                except Exception as e:
                    self._last_live_sync_err = f"balance:{type(e).__name__}:{e}"
                    self._log_err(f"[LIVE_SYNC_ERR] balance: {e}")

                # Positions
                try:
                    # Snapshot previous open positions so we can emit ENTER/EXIT events
                    # based on actual exchange state transitions (not just "signals").
                    prev_open: Dict[str, Dict[str, Any]] = {}
                    try:
                        for _sym, _pos in (self.positions or {}).items():
                            if not isinstance(_pos, dict):
                                continue
                            try:
                                _size = float(_pos.get("size", _pos.get("quantity", _pos.get("qty", 0.0))) or 0.0)
                            except Exception:
                                _size = 0.0
                            if _size == 0.0:
                                continue
                            prev_open[str(_sym)] = {
                                "symbol": str(_sym),
                                "side": str(_pos.get("side") or "").upper(),
                                "size": float(_size),
                                "entry_price": _pos.get("entry_price", _pos.get("entry")),
                                "price": _pos.get("price", _pos.get("current")),
                                "notional": _pos.get("notional"),
                                "margin": _pos.get("margin"),
                                "leverage": _pos.get("leverage"),
                                "cap_frac": _pos.get("cap_frac"),
                            }
                    except Exception:
                        prev_open = {}

                    raw_positions = await self._ccxt_call("fetch_positions(live_sync)", self.exchange.fetch_positions)
                    universe = set(self.symbols or [])
                    extras = []
                    live_positions: Dict[str, Dict[str, Any]] = {}
                    include_outside = str(os.environ.get("LIVE_SYNC_INCLUDE_OUTSIDE_UNIVERSE", "1")).strip().lower() in (
                        "1",
                        "true",
                        "yes",
                    )
                    for p in raw_positions or []:
                        if not isinstance(p, dict):
                            continue
                        sym = p.get("symbol")
                        outside = bool(sym and sym not in universe)
                        if outside and (not include_outside):
                            # Ignore out-of-universe positions but keep a warning trail.
                            try:
                                contracts = float(p.get("contracts") or 0.0)
                            except Exception:
                                contracts = 0.0
                            if abs(contracts) > 0:
                                extras.append(sym)
                            continue

                        norm = self._normalize_ccxt_position(p, ts_ms)
                        if norm is None:
                            continue
                        if outside:
                            norm["outside_universe"] = True
                            extras.append(str(sym))
                        live_positions[norm["symbol"]] = norm

                    if extras:
                        msg = "included" if include_outside else "ignored"
                        warn_keys = "_".join(sorted(set(extras)))
                        last_warn = self._live_warn_last_ms.get(warn_keys, 0)
                        if (ts_ms - last_warn) > self._live_warn_interval_ms:
                            self._log_err(f"[LIVE_SYNC_WARN] Open positions outside SYMBOLS {msg}: {sorted(set(extras))[:10]}")
                            self._live_warn_last_ms[warn_keys] = ts_ms

                    # Emit tape events based on exchange state changes (ENTER/EXIT/FLIP).
                    try:
                        prev_syms = set(prev_open.keys())
                        cur_syms = set(live_positions.keys())
                        closed = prev_syms - cur_syms
                        opened = cur_syms - prev_syms
                        stayed = prev_syms & cur_syms

                        # Maintain our own "open time" so dashboard hold-time doesn't inherit ancient exchange createdTime.
                        try:
                            for sym in closed:
                                self._live_pos_open_time_ms.pop(str(sym), None)
                            for sym in opened:
                                self._live_pos_open_time_ms[str(sym)] = int(ts_ms)
                            for sym in stayed:
                                if str(sym) not in self._live_pos_open_time_ms:
                                    self._live_pos_open_time_ms[str(sym)] = int(ts_ms)
                            for sym, pos in (live_positions or {}).items():
                                t_open = self._live_pos_open_time_ms.get(str(sym))
                                if t_open is not None:
                                    pos["time"] = int(t_open)
                                    pos["age_sec"] = max(0.0, (int(ts_ms) - int(t_open)) / 1000.0)
                                    try:
                                        ex_t = pos.get("exchange_time")
                                        pos["legacy"] = bool(ex_t is not None and int(ex_t) < int(self.start_ms))
                                    except Exception:
                                        pos["legacy"] = False
                        except Exception:
                            pass

                        # Closed
                        for sym in sorted(closed):
                            old = prev_open.get(sym) or {}
                            side_old = str(old.get("side") or "").upper()
                            if side_old not in ("LONG", "SHORT"):
                                side_old = "-"
                            try:
                                self._live_close_note_by_sym.pop(str(sym), None)
                            except Exception:
                                pass
                            try:
                                reason = self._live_pending_exit_reason.pop(str(sym), None)
                            except Exception:
                                reason = None
                            if not reason:
                                reason = "live_sync"
                            pnl = None
                            roe = None
                            try:
                                entry = float(old.get("entry_price") or old.get("entry") or 0.0)
                                px = float(old.get("price") or old.get("current") or 0.0)
                                qty = float(old.get("size") or 0.0)
                                margin = float(old.get("margin") or 0.0)
                                if entry > 0 and px > 0 and qty != 0.0:
                                    pnl = ((entry - px) * qty) if side_old == "SHORT" else ((px - entry) * qty)
                                    roe = (float(pnl) / float(margin)) if margin > 0 else None
                            except Exception:
                                pnl = None
                                roe = None
                            self._last_trade_event_by_sym[str(sym)] = "EXIT"
                            self._paper_append_trade(
                                {
                                    "time": int(ts_ms),
                                    "sym": str(sym),
                                    "type": "EXIT",
                                    "action_type": "EXIT",
                                    "side": side_old,
                                    "entry_price": old.get("entry_price"),
                                    "price": old.get("price"),
                                    "qty": old.get("size"),
                                    "leverage": old.get("leverage"),
                                    "cap_frac": old.get("cap_frac"),
                                    "notional": old.get("notional"),
                                    "pnl": pnl,
                                    "roe": roe,
                                    "pnl_estimated": True,
                                    "reason": str(reason),
                                }
                            )
                            try:
                                self._last_exit_time[str(sym)] = int(ts_ms)
                            except Exception:
                                pass

                        # Opened
                        for sym in sorted(opened):
                            cur = live_positions.get(sym) or {}
                            side_new = str(cur.get("side") or "").upper()
                            if side_new not in ("LONG", "SHORT"):
                                side_new = "-"
                            try:
                                reason = self._live_pending_entry_reason.pop(str(sym), None)
                            except Exception:
                                reason = None
                            if not reason:
                                reason = "live_sync"
                            self._last_trade_event_by_sym[str(sym)] = "ENTER"
                            self._paper_append_trade(
                                {
                                    "time": int(ts_ms),
                                    "sym": str(sym),
                                    "type": "ENTER",
                                    "action_type": "ENTER",
                                    "side": side_new,
                                    "entry_price": cur.get("entry_price", cur.get("entry")),
                                    "price": cur.get("entry_price", cur.get("entry")),
                                    "qty": cur.get("size"),
                                    "leverage": cur.get("leverage"),
                                    "cap_frac": cur.get("cap_frac"),
                                    "notional": cur.get("notional"),
                                    "reason": str(reason),
                                }
                            )

                        # Side flips (treat as EXIT+ENTER)
                        for sym in sorted(stayed):
                            old = prev_open.get(sym) or {}
                            cur = live_positions.get(sym) or {}
                            side_old = str(old.get("side") or "").upper()
                            side_new = str(cur.get("side") or "").upper()
                            if side_old in ("LONG", "SHORT") and side_new in ("LONG", "SHORT") and side_old != side_new:
                                self._last_trade_event_by_sym[str(sym)] = "EXIT"
                                self._paper_append_trade(
                                    {
                                        "time": int(ts_ms),
                                        "sym": str(sym),
                                        "type": "EXIT",
                                        "action_type": "EXIT",
                                        "side": side_old,
                                        "entry_price": old.get("entry_price"),
                                        "price": old.get("price"),
                                        "leverage": old.get("leverage"),
                                        "cap_frac": old.get("cap_frac"),
                                        "notional": old.get("notional"),
                                        "note": "live_sync_flip",
                                    }
                                )
                                self._last_trade_event_by_sym[str(sym)] = "ENTER"
                                self._paper_append_trade(
                                    {
                                        "time": int(ts_ms),
                                        "sym": str(sym),
                                        "type": "ENTER",
                                        "action_type": "ENTER",
                                        "side": side_new,
                                        "entry_price": cur.get("entry_price", cur.get("entry")),
                                        "price": cur.get("entry_price", cur.get("entry")),
                                        "leverage": cur.get("leverage"),
                                        "cap_frac": cur.get("cap_frac"),
                                        "notional": cur.get("notional"),
                                        "note": "live_sync_flip",
                                    }
                                )
                    except Exception:
                        pass

                    # Merge into orchestrator state (keep meta/policy fields when possible)
                    for sym, live in live_positions.items():
                        old = self.positions.get(sym)
                        if isinstance(old, dict):
                            old_side = str(old.get("side") or "")
                            new_side = str(live.get("side") or "")
                            for k, v in live.items():
                                old[k] = v
                            # Refresh cap_frac now that balance is synced
                            if isinstance(old.get("margin"), (int, float)) and float(self.balance) > 0:
                                try:
                                    old["cap_frac"] = float(old.get("margin") or 0.0) / float(self.balance)
                                except Exception:
                                    pass

                            # New position / flipped side => refresh entry meta
                            if old_side != new_side or (sym not in self._pos_meta):
                                self._pos_meta[sym] = {
                                    "entry_group": self._get_validated_entry_group(sym) or "OTHER",
                                    "entry_rank": self._get_current_rank(sym),
                                    "entry_order": self._entry_order_counter,
                                    "entry_t_star": self._symbol_t_star.get(sym, 0.0),
                                }
                                self._entry_order_counter += 1
                            meta = self._pos_meta.get(sym) or {}
                            old["entry_group"] = meta.get("entry_group")
                            old["entry_rank"] = meta.get("entry_rank")
                            old["entry_order"] = meta.get("entry_order")
                            old["entry_t_star"] = meta.get("entry_t_star")
                            if meta.get("dynamic_min_hold") is not None:
                                try:
                                    old["dynamic_min_hold"] = int(meta.get("dynamic_min_hold") or 0)
                                except Exception:
                                    pass
                            self.positions[sym] = old
                        else:
                            meta = self._pos_meta.get(sym)
                            if not isinstance(meta, dict):
                                meta = {
                                    "entry_group": self._get_validated_entry_group(sym) or "OTHER",
                                    "entry_rank": self._get_current_rank(sym),
                                    "entry_order": self._entry_order_counter,
                                    "entry_t_star": self._symbol_t_star.get(sym, 0.0),
                                }
                                self._pos_meta[sym] = meta
                                self._entry_order_counter += 1
                            live["entry_group"] = meta.get("entry_group")
                            live["entry_rank"] = meta.get("entry_rank")
                            live["entry_order"] = meta.get("entry_order")
                            live["entry_t_star"] = meta.get("entry_t_star")
                            if meta.get("dynamic_min_hold") is not None:
                                try:
                                    live["dynamic_min_hold"] = int(meta.get("dynamic_min_hold") or 0)
                                except Exception:
                                    pass
                            if float(self.balance) > 0:
                                try:
                                    live["cap_frac"] = float(live.get("margin") or 0.0) / float(self.balance)
                                except Exception:
                                    pass
                            self.positions[sym] = live

                        # --- 1% Price Reversal Auto-Close Logic ---
                        try:
                            entry_price = float(live.get("entry_price") or live.get("entry") or 0.0)
                            current_price = float(live.get("current") or live.get("price") or 0.0)
                            if entry_price > 0 and current_price > 0:
                                price_change = (current_price - entry_price) / entry_price
                                side = str(live.get("side") or "").upper()
                                
                                trigger_close = False
                                if side == "LONG" and price_change <= -0.01:
                                    trigger_close = True
                                elif side == "SHORT" and price_change >= 0.01:
                                    trigger_close = True
                                
                                if trigger_close:
                                    if self._live_is_pending(sym, ts_ms):
                                        continue
                                    
                                    self._log(f"🛑 [AUTO_EXIT] {sym} {side} moved {price_change*100:.2f}% (price={current_price:.4f})")
                                    await self._close_position(
                                        sym=sym,
                                        exit_price=current_price,
                                        ts_ms=ts_ms,
                                        reason=f"price_move_{price_change*100:.1f}pct"
                                    )
                                    self._live_mark_pending(sym, ts_ms)
                        except Exception as e:
                            self._log_err(f"[AUTO_EXIT_ERR] {sym}: {e}")

                    # Drop symbols no longer open on exchange
                    for sym in list(self.positions.keys()):
                        if sym not in live_positions:
                            self.positions.pop(sym, None)

                    # Keep targets consistent with currently open positions
                    for sym in list(getattr(self, "_rebalance_targets", {}).keys()):
                        if sym not in self.positions:
                            try:
                                self._rebalance_targets.pop(sym, None)
                            except Exception:
                                pass

                    # Execute any queued live rotations once the source position is confirmed closed.
                    try:
                        self._process_live_pending_rotations(ts_ms=int(ts_ms))
                    except Exception:
                        pass
                except Exception as e:
                    self._last_live_sync_err = f"positions:{type(e).__name__}:{e}"
                    self._log_err(f"[LIVE_SYNC_ERR] positions: {e}")

                self._last_live_sync_ms = int(ts_ms)
                self._last_live_sync_err = None
            except Exception as e:
                self._last_live_sync_err = f"loop:{type(e).__name__}:{e}"
                self._log_err(f"[LIVE_SYNC_ERR] loop: {e}")
            await asyncio.sleep(max(0.2, float(self.live_sync_interval_ms) / 1000.0))

    async def _cleanup_live_open_orders(self, ts_ms: int, *, reason: str, force: bool = False) -> Dict[str, Any]:
        """
        Cancel open non-reduceOnly orders to free initial margin.
        In low-liquidity/testnet, entry LIMIT orders may remain open and consume IM, pushing margin ratio
        above the guard and blocking new entries (making position util% look "stuck").
        """
        if not (self.enable_orders and getattr(self, "exchange", None)):
            return {"ok": False, "skipped": "not_live"}
        if not bool(getattr(self, "live_open_order_cleanup_enabled", False)):
            return {"ok": False, "skipped": "disabled"}
        try:
            now = int(ts_ms)
        except Exception:
            now = int(now_ms())
        try:
            last = int(getattr(self, "_last_live_open_order_cleanup_ms", 0) or 0)
        except Exception:
            last = 0
        try:
            interval = int(getattr(self, "live_open_order_cleanup_interval_ms", 0) or 0)
        except Exception:
            interval = 0
        if (not force) and interval > 0 and (now - last) < interval:
            return {"ok": True, "canceled": 0, "kept": 0, "throttled": True}
        self._last_live_open_order_cleanup_ms = int(now)

        try:
            stale_ms = int(getattr(self, "live_open_order_stale_ms", 15_000) or 15_000)
        except Exception:
            stale_ms = 15_000
        stale_ms = max(0, int(stale_ms))
        try:
            max_cancel = int(getattr(self, "live_open_order_cleanup_max_cancel", 25) or 25)
        except Exception:
            max_cancel = 25
        max_cancel = max(1, int(max_cancel))

        canceled = 0
        kept_reduce_only = 0
        kept_recent = 0
        kept_other = 0
        failed = 0

        try:
            open_orders = await self._ccxt_call("fetch_open_orders(cleanup)", self.exchange.fetch_open_orders)
        except Exception as e:
            self._log_err(f"[RISK] Open-order cleanup fetch failed: {e}")
            return {"ok": False, "err": str(e)}
        if not isinstance(open_orders, list) or not open_orders:
            return {"ok": True, "canceled": 0, "kept": 0, "empty": True}

        for o in open_orders:
            if canceled >= max_cancel:
                break
            if not isinstance(o, dict):
                continue
            sym = str(o.get("symbol") or "").strip()
            oid = o.get("id")
            if not oid:
                continue
            status = str(o.get("status") or "").lower()
            if status and status not in ("open", "new", "pending"):
                kept_other += 1
                continue
            info = o.get("info") if isinstance(o.get("info"), dict) else {}
            reduce_only = False
            try:
                reduce_only = bool(o.get("reduceOnly"))
            except Exception:
                reduce_only = False
            if not reduce_only and isinstance(info, dict):
                try:
                    reduce_only = bool(info.get("reduceOnly") or info.get("reduce_only"))
                except Exception:
                    pass
            if reduce_only:
                kept_reduce_only += 1
                continue

            t0 = o.get("timestamp")
            if t0 is None and isinstance(info, dict):
                t0 = info.get("createdTime") or info.get("created_time")
            try:
                created = int(t0) if t0 is not None else None
            except Exception:
                created = None
            age_ms = (now - created) if created is not None else None

            if (not force) and age_ms is not None and age_ms < stale_ms:
                kept_recent += 1
                continue
            if (not force) and age_ms is None:
                kept_other += 1
                continue

            try:
                # Bybit/ccxt expects (id, symbol) for cancel_order; pass symbol when available.
                if sym:
                    await self._ccxt_call("cancel_order(cleanup)", self.exchange.cancel_order, str(oid), str(sym))
                else:
                    await self._ccxt_call("cancel_order(cleanup)", self.exchange.cancel_order, str(oid))
                canceled += 1
            except Exception as e:
                failed += 1
                self._log_err(f"[RISK] Open-order cleanup cancel failed: {sym} id={oid} err={e}")

        kept = int(kept_reduce_only + kept_recent + kept_other)
        try:
            tag = str(reason or "").strip()
            tag = f" ({tag})" if tag else ""
            self._log(
                f"[RISK] Open-order cleanup{tag}: canceled={canceled} kept={kept} reduceOnly={kept_reduce_only} recent={kept_recent} failed={failed}"
            )
        except Exception:
            pass
        return {
            "ok": True,
            "canceled": int(canceled),
            "kept": int(kept),
            "kept_reduce_only": int(kept_reduce_only),
            "kept_recent": int(kept_recent),
            "failed": int(failed),
            "force": bool(force),
            "stale_ms": int(stale_ms),
        }

    def _apply_mc_runtime_to_engines(self) -> None:
        for eng in getattr(self.hub, "engines", []) or []:
            if hasattr(eng, "N_PATHS_EXIT_POLICY"):
                try:
                    setattr(eng, "N_PATHS_EXIT_POLICY", int(self.mc_n_paths_exit))
                except Exception:
                    pass

    def _total_open_notional(self) -> float:
        total = 0.0
        for sym, pos in (self.positions or {}).items():
            try:
                size = float(pos.get("size", pos.get("quantity", pos.get("qty", 0.0))) or 0.0)
            except Exception:
                size = 0.0
            if size == 0.0:
                continue

            notional = pos.get("notional")
            if notional is None:
                price = pos.get("price") or pos.get("entry_price") or (self.market.get(sym) or {}).get("price")
                try:
                    px = float(price) if price is not None else 0.0
                except Exception:
                    px = 0.0
                notional = abs(size) * px
            try:
                total += abs(float(notional) or 0.0)
            except Exception:
                continue
        return float(total)

    def _live_margin_used(self, *, ts_ms: Optional[int] = None) -> float:
        total = 0.0
        for _sym, pos in (self.positions or {}).items():
            if not isinstance(pos, dict):
                continue
            try:
                size = float(pos.get("size", pos.get("quantity", pos.get("qty", 0.0))) or 0.0)
            except Exception:
                size = 0.0
            if size == 0.0:
                continue
            m = pos.get("margin")
            if m is None:
                try:
                    notional = float(pos.get("notional") or 0.0)
                except Exception:
                    notional = 0.0
                try:
                    lev = float(pos.get("leverage") or self.leverage or 1.0)
                except Exception:
                    lev = 1.0
                if lev <= 0:
                    lev = 1.0
                m = notional / lev
            try:
                total += max(0.0, float(m) or 0.0)
            except Exception:
                continue

        # Add reserved margin for pending orders (best-effort).
        try:
            now = int(ts_ms) if ts_ms is not None else int(now_ms())
        except Exception:
            now = int(now_ms())
        reserved = 0.0
        try:
            dead = []
            for sym, rec in (self._live_margin_reserved_by_sym or {}).items():
                try:
                    until = int(rec.get("until_ms") or 0)
                    amt = float(rec.get("amount") or 0.0)
                except Exception:
                    until = 0
                    amt = 0.0
                if until <= now:
                    dead.append(sym)
                    continue
                reserved += max(0.0, amt)
            for sym in dead:
                self._live_margin_reserved_by_sym.pop(sym, None)
        except Exception:
            reserved = 0.0

        return float(total + reserved)

    def _reserve_live_margin(self, sym: str, margin: float, ts_ms: int) -> None:
        try:
            dur = int(self.live_margin_reserve_ms)
        except Exception:
            dur = 0
        if dur <= 0:
            return
        try:
            amt = float(margin)
        except Exception:
            return
        if amt <= 0:
            return
        self._live_margin_reserved_by_sym[str(sym)] = {"until_ms": float(int(ts_ms) + dur), "amount": float(amt)}

    def _live_notional_used(self, *, ts_ms: Optional[int] = None) -> float:
        open_notional = 0.0
        try:
            open_notional = float(self._total_open_notional())
        except Exception:
            open_notional = 0.0

        try:
            now = int(ts_ms) if ts_ms is not None else int(now_ms())
        except Exception:
            now = int(now_ms())
        reserved = 0.0
        try:
            dead = []
            for sym, rec in (self._live_notional_reserved_by_sym or {}).items():
                try:
                    until = int(rec.get("until_ms") or 0)
                    amt = float(rec.get("amount") or 0.0)
                except Exception:
                    until = 0
                    amt = 0.0
                if until <= now:
                    dead.append(sym)
                    continue
                reserved += max(0.0, amt)
            for sym in dead:
                self._live_notional_reserved_by_sym.pop(sym, None)
        except Exception:
            reserved = 0.0
        return float(open_notional + reserved)

    def _reserve_live_notional(self, sym: str, notional: float, ts_ms: int) -> None:
        try:
            dur = int(self.live_margin_reserve_ms)
        except Exception:
            dur = 0
        if dur <= 0:
            return
        try:
            amt = float(notional)
        except Exception:
            return
        if amt <= 0:
            return
        self._live_notional_reserved_by_sym[str(sym)] = {"until_ms": float(int(ts_ms) + dur), "amount": float(amt)}

    def _max_exchange_leverage(self, sym: str) -> Optional[float]:
        """
        Best-effort lookup of max leverage for a symbol from ccxt market metadata.
        Returns None if unknown.
        """
        try:
            mkt = None
            markets = getattr(self.exchange, "markets", None) or {}
            if isinstance(markets, dict) and str(sym) in markets:
                mkt = markets.get(str(sym))
            if mkt is None and hasattr(self.exchange, "market"):
                mkt = self.exchange.market(str(sym))
            if not isinstance(mkt, dict):
                return None
            lim = mkt.get("limits")
            if isinstance(lim, dict):
                lev = lim.get("leverage")
                if isinstance(lev, dict) and lev.get("max") is not None:
                    try:
                        return float(lev.get("max"))
                    except Exception:
                        return None
            info = mkt.get("info")
            if isinstance(info, dict):
                lf = info.get("leverageFilter")
                if isinstance(lf, dict) and lf.get("maxLeverage") is not None:
                    try:
                        return float(lf.get("maxLeverage"))
                    except Exception:
                        return None
        except Exception:
            return None
        return None

    def _get_current_rank(self, sym: str) -> Optional[int]:
        """Get current rank of symbol in latest rankings."""
        try:
            if hasattr(self, '_latest_rankings') and sym in self._latest_rankings:
                return self._latest_rankings.index(sym) + 1
            return None
        except Exception:
            return None
    
    def _get_validated_entry_group(self, sym: str) -> Optional[str]:
        """Get validated entry group for symbol at entry."""
        try:
            if hasattr(self, '_group_info'):
                info = self._group_info.get(sym)
                if info:
                    return info.get("group")
            return None
        except Exception:
            return None
    
    def _recalculate_groups(self, force: bool = False) -> None:
        """
        Recalculate rankings and group assignments.
        
        TOP10: Rank 1-10 (Kelly-based asset allocation target)
        OTHER: Rest
        """
        try:
            now = now_ms()
            if not force and (now - self._last_group_update_ts) < 2000:
                return
            
            self._last_group_update_ts = now
            
            # Get all symbols with scores
            scored_symbols = [(sym, self._symbol_scores.get(sym, 0.0)) for sym in self.symbols]
            scored_symbols.sort(key=lambda x: x[1], reverse=True)
            
            # Update rankings
            self._latest_rankings = [sym for sym, score in scored_symbols]
            
            # Clear and rebuild group_info
            self._group_info.clear()
            
            for i, (sym, score) in enumerate(scored_symbols):
                rank = i + 1
                
                if rank <= 10:
                    self._group_info[sym] = {
                        "group": "TOP10",
                        "rank": rank,
                        "score": score,
                        "boost": 1.0,
                        "cap": 0.25,
                    }
                else:
                    self._group_info[sym] = {
                        "group": "OTHER",
                        "rank": rank,
                        "score": score,
                        "boost": 0.5,
                        "cap": 0.05,
                    }
        except Exception as e:
            if hasattr(self, '_log'):
                self._log(f"[ERR] _recalculate_groups: {e}")
    
    def _get_top_k_symbols(self, k: int) -> list[str]:
        """Get top K symbols by current score (RESTORED)."""
        return self._latest_rankings[:k] if len(self._latest_rankings) >= k else self._latest_rankings

    def _economic_brain_from_meta(self, meta: Dict[str, Any], *, leverage: float) -> EconomicBrain:
        """
        Build an EconomicBrain instance whose cost parameters are in ROE units (per-margin),
        consistent with MC directional EV curves (which are also ROE).
        """
        lev = float(max(1e-6, leverage))
        fee_rt = None
        try:
            fee_rt = meta.get("fee_roundtrip_total", None)
        except Exception:
            fee_rt = None
        if fee_rt is None:
            try:
                fee_rt = meta.get("execution_cost", None)
            except Exception:
                fee_rt = None
        try:
            fee_rt_f = float(fee_rt) if fee_rt is not None else None
        except Exception:
            fee_rt_f = None
        if fee_rt_f is None or (not math.isfinite(fee_rt_f)) or fee_rt_f < 0.0:
            fee_rt_f = float(self.paper_fee_roundtrip) if float(self.paper_fee_roundtrip) > 0 else 0.0008

        # Treat fee_roundtrip_total as "all-in roundtrip cost" (fees+spread+slip) in per-notional units.
        # Convert to ROE by multiplying by leverage, and split into entry/exit halves.
        entry_cost_roe = 0.5 * float(fee_rt_f) * lev
        exit_cost_roe = 0.5 * float(fee_rt_f) * lev

        # Switch buffer is expressed in return units; match ROE units by scaling with leverage.
        buffer_roe = float(max(0.0, float(self.paper_economic_switch_buffer))) * lev
        return EconomicBrain(
            entry_cost=float(entry_cost_roe),
            exit_cost=float(exit_cost_roe),
            slippage=0.0,
            switch_buffer=float(buffer_roe),
        )

    def _economic_extract_curve(
        self, detail_or_decision: Dict[str, Any]
    ) -> tuple[Optional[np.ndarray], Optional[np.ndarray], Optional[Dict[str, Any]], Optional[float]]:
        """
        Extract (horizons_sec, signed_ev_rate_per_sec_vector, mc_meta, leverage_used) for EconomicBrain.
        """
        if not isinstance(detail_or_decision, dict):
            return None, None, None, None
        meta = self._extract_mc_meta(detail_or_decision)
        ev_rate_by_h = extract_signed_ev_rate_by_horizon_from_meta(meta)
        if not ev_rate_by_h:
            return None, None, meta, None
        hs = sorted(int(h) for h in ev_rate_by_h.keys() if int(h) > 0)
        if len(hs) < 2:
            return None, None, meta, None
        horizons = np.asarray(hs, dtype=float)
        ev_rate = np.asarray([float(ev_rate_by_h[h]) for h in hs], dtype=float)

        lev = None
        for k in ("leverage_used", "optimal_leverage", "leverage"):
            try:
                if meta.get(k) is not None:
                    lev = float(meta.get(k))
                    break
            except Exception:
                continue
        if lev is None:
            try:
                if detail_or_decision.get("optimal_leverage") is not None:
                    lev = float(detail_or_decision.get("optimal_leverage"))
            except Exception:
                lev = None
        return horizons, ev_rate, meta, lev

    def _economic_best_switch_candidate(self, *, exclude_symbols: set[str]) -> Optional[Candidate]:
        """
        Candidate_Best = argmax NAPV(All_Market - Current_Portfolio_Symbols).
        """
        rho = calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)
        r_f = float(self.paper_rf_per_sec)

        best: Optional[Candidate] = None
        for sym in (self.symbols or []):
            if sym in exclude_symbols:
                continue
            cached = self._decision_cache.get(sym) or {}
            decision = cached.get("decision")
            if not isinstance(decision, dict):
                continue
            horizons, ev_rate, meta, lev = self._economic_extract_curve(decision)
            if horizons is None or ev_rate is None or meta is None:
                continue
            lev_f = float(lev) if lev is not None and float(lev) > 0 else float(self.leverage)
            brain = self._economic_brain_from_meta(meta, leverage=lev_f)

            napv_long, t_long = brain.calculate_napv_vectorized(
                horizons_sec=horizons,
                ev_rate_vector=ev_rate,
                side=+1,
                rho=rho,
                r_f=r_f,
                cost_mode="full",
            )
            napv_short, t_short = brain.calculate_napv_vectorized(
                horizons_sec=horizons,
                ev_rate_vector=ev_rate,
                side=-1,
                rho=rho,
                r_f=r_f,
                cost_mode="full",
            )
            if float(napv_short) > float(napv_long):
                cand = Candidate(symbol=sym, side=-1, napv=float(napv_short), t_star_sec=float(t_short))
            else:
                cand = Candidate(symbol=sym, side=+1, napv=float(napv_long), t_star_sec=float(t_long))

            if best is None or float(cand.napv) > float(best.napv):
                best = cand

        return best

    def score_debug_for_symbol(self, sym: str) -> Dict[str, Any]:
        """
        Return a compact debug payload showing why a symbol's Score_A / EV can be negative.
        Safe for dashboard use (no secrets).
        """
        symbol = str(sym or "").strip()
        if not symbol:
            return {"ok": False, "error": "empty symbol"}

        cached = self._decision_cache.get(symbol) or {}
        decision = cached.get("decision") if isinstance(cached, dict) else None
        if not isinstance(decision, dict):
            return {"ok": False, "symbol": symbol, "error": "no cached decision"}

        meta = self._extract_mc_meta(decision)
        ev_long, ev_short = extract_directional_ev_by_horizon_from_meta(meta)
        ev_single = None
        if not ev_long and not ev_short:
            ev_single = extract_ev_by_horizon_from_meta(meta)

        # Cost extraction (same precedence as Score_A scoring)
        fee_rt_total = meta.get("fee_roundtrip_total") if isinstance(meta, dict) else None
        if fee_rt_total is None and isinstance(meta, dict):
            fee_rt_total = meta.get("execution_cost")
        fee_mix = meta.get("fee_roundtrip_fee_mix") if isinstance(meta, dict) else None
        spread_cost = meta.get("expected_spread_cost") if isinstance(meta, dict) else None
        slip_cost = meta.get("slippage_dyn") if isinstance(meta, dict) else None

        total = None
        try:
            if fee_rt_total is not None:
                total = float(fee_rt_total)
        except Exception:
            total = None
        if total is None:
            parts = []
            for v in (fee_mix, spread_cost, slip_cost):
                try:
                    if v is not None:
                        fv = float(v)
                        if math.isfinite(fv) and fv >= 0:
                            parts.append(fv)
                except Exception:
                    continue
            if parts:
                total = float(sum(parts))
        if total is None:
            try:
                total = float(self.paper_fee_roundtrip)
            except Exception:
                total = 0.0
        if (not math.isfinite(float(total))) or float(total) < 0:
            total = 0.0

        entry_fee = 0.5 * float(total)
        exit_fee = 0.5 * float(total)

        pos = self.positions.get(symbol) or {}
        age_sec = None
        try:
            age_sec = float(pos.get("age_sec")) if pos.get("age_sec") is not None else None
        except Exception:
            age_sec = None

        scoreL, tL = self._get_symbol_score_a_for_side(
            sym=symbol, detail=decision, side="LONG", is_current=bool(pos), age_sec=float(age_sec or 0.0)
        )
        scoreS, tS = self._get_symbol_score_a_for_side(
            sym=symbol, detail=decision, side="SHORT", is_current=bool(pos), age_sec=float(age_sec or 0.0)
        )
        best_side = "LONG" if float(scoreL) >= float(scoreS) else "SHORT"
        best_score = float(scoreL) if best_side == "LONG" else float(scoreS)

        return {
            "ok": True,
            "symbol": symbol,
            "have_position": bool(pos),
            "age_sec": age_sec,
            "cost_total": float(total),
            "entry_fee": float(entry_fee),
            "exit_fee": float(exit_fee),
            "slippage": 0.0,
            "rho": float(calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)),
            "score_a_long": float(scoreL),
            "t_star_long": float(tL),
            "score_a_short": float(scoreS),
            "t_star_short": float(tS),
            "best_side": best_side,
            "best_score": float(best_score),
            # raw curves (small dicts; safe)
            "ev_by_horizon_long": ev_long or None,
            "ev_by_horizon_short": ev_short or None,
            "ev_by_horizon_single": ev_single or None,
            # engine meta summary (for cross-check)
            "meta": {
                "ev": meta.get("ev") if isinstance(meta, dict) else None,
                "ev_raw": meta.get("ev_raw") if isinstance(meta, dict) else None,
                "policy_ev_score_long": meta.get("policy_ev_score_long") if isinstance(meta, dict) else None,
                "policy_ev_score_short": meta.get("policy_ev_score_short") if isinstance(meta, dict) else None,
                "policy_horizons": meta.get("policy_horizons") if isinstance(meta, dict) else None,
                "fee_roundtrip_total": fee_rt_total,
                "execution_cost": meta.get("execution_cost") if isinstance(meta, dict) else None,
                "fee_roundtrip_fee_mix": fee_mix,
                "expected_spread_cost": spread_cost,
                "slippage_dyn": slip_cost,
                "policy_ev_neighbor_veto_abs": meta.get("policy_ev_neighbor_veto_abs") if isinstance(meta, dict) else None,
            },
        }

    def _get_symbol_expected_value(self, sym: str, detail: Dict, use_optimal_horizon: bool = False) -> float:
        """
        Calculate discounted EV integral score (Score_A).

        Notes:
            - This is used as the ranking score across symbols.
            - Direction is handled as a vector (LONG/SHORT); we return the best-side score.
        """
        try:
            if not detail or not isinstance(detail, dict):
                return 0.0
            meta = self._extract_mc_meta(detail)
            if use_optimal_horizon and bool(getattr(self, "paper_economic_brain_enabled", False)):
                horizons, ev_rate, meta2, lev = self._economic_extract_curve(detail)
                if horizons is not None and ev_rate is not None and meta2 is not None:
                    rho = calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)
                    r_f = float(self.paper_rf_per_sec)
                    lev_f = float(lev) if lev is not None and float(lev) > 0 else float(self.leverage)
                    brain = self._economic_brain_from_meta(meta2, leverage=lev_f)
                    napv_long, t_long = brain.calculate_napv_vectorized(
                        horizons_sec=horizons,
                        ev_rate_vector=ev_rate,
                        side=+1,
                        rho=rho,
                        r_f=r_f,
                        cost_mode="full",
                    )
                    napv_short, t_short = brain.calculate_napv_vectorized(
                        horizons_sec=horizons,
                        ev_rate_vector=ev_rate,
                        side=-1,
                        rho=rho,
                        r_f=r_f,
                        cost_mode="full",
                    )
                    if float(napv_short) > float(napv_long):
                        self._symbol_best_side[sym] = "SHORT"
                        self._symbol_t_star[sym] = float(t_short)
                        return float(napv_short)
                    self._symbol_best_side[sym] = "LONG"
                    self._symbol_t_star[sym] = float(t_long)
                    return float(napv_long)

            ev_long, ev_short = extract_directional_ev_by_horizon_from_meta(meta)
            ev_single = None
            if not ev_long and not ev_short:
                ev_single = extract_ev_by_horizon_from_meta(meta)

            # Set default T* first (will be overridden if we can calculate it)
            self._symbol_t_star[sym] = 3600.0  # Default 1 hour
            self._symbol_best_side[sym] = "LONG"

            if use_optimal_horizon and (ev_long or ev_short or ev_single):
                # 1) Dynamic decay rho
                rho = calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)

                # 2) Cost model (use engine meta if present; do NOT hardcode defaults).
                # Meta fields:
                #  - fee_roundtrip_total: all-in roundtrip (fees+spread+slip) in per-notional units
                #  - execution_cost: fallback all-in roundtrip
                #  - fee_roundtrip_fee_mix + expected_spread_cost + slippage_dyn: components
                fee_mix = None
                spread_cost = None
                slip_cost = None
                fee_rt_total = None
                try:
                    fee_rt_total = meta.get("fee_roundtrip_total")
                except Exception:
                    fee_rt_total = None
                if fee_rt_total is None:
                    try:
                        fee_rt_total = meta.get("execution_cost")
                    except Exception:
                        fee_rt_total = None
                try:
                    fee_mix = meta.get("fee_roundtrip_fee_mix")
                except Exception:
                    fee_mix = None
                try:
                    spread_cost = meta.get("expected_spread_cost")
                except Exception:
                    spread_cost = None
                try:
                    slip_cost = meta.get("slippage_dyn")
                except Exception:
                    slip_cost = None

                total = None
                try:
                    if fee_rt_total is not None:
                        total = float(fee_rt_total)
                except Exception:
                    total = None
                if total is None:
                    parts = []
                    for v in (fee_mix, spread_cost, slip_cost):
                        try:
                            if v is not None:
                                fv = float(v)
                                if math.isfinite(fv) and fv >= 0:
                                    parts.append(fv)
                        except Exception:
                            continue
                    if parts:
                        total = float(sum(parts))

                if total is None:
                    # Fall back to user config (can be 0.0 intentionally).
                    try:
                        total = float(self.paper_fee_roundtrip)
                    except Exception:
                        total = 0.0
                if (not math.isfinite(float(total))) or float(total) < 0:
                    total = 0.0

                entry_fee = 0.5 * float(total)
                exit_fee = 0.5 * float(total)
                slippage = 0.0

                def _score_for_curve(ev_dict: Dict[int, float], *, side_label: str) -> tuple[float, float]:
                    fee_for_opt = float(total)  # new position: roundtrip cost
                    t_star, _ = find_optimal_horizon(ev_dict, fee_for_opt)
                    score = calculate_opportunity_score(
                        ev_by_horizon=ev_dict,
                        optimal_horizon=t_star,
                        rho=rho,
                        current_age_sec=0.0,
                        entry_fee=entry_fee,
                        exit_fee=exit_fee,
                        slippage=slippage,
                    )
                    return float(score), float(t_star)

                score_long, t_long = (0.0, 3600.0)
                score_short, t_short = (0.0, 3600.0)
                if ev_long and len(ev_long) >= 2:
                    score_long, t_long = _score_for_curve(ev_long, side_label="LONG")
                if ev_short and len(ev_short) >= 2:
                    score_short, t_short = _score_for_curve(ev_short, side_label="SHORT")
                if (not ev_long) and (not ev_short) and ev_single and len(ev_single) >= 2:
                    # Back-compat: treat the single curve as "best-side" only.
                    score_long, t_long = _score_for_curve(ev_single, side_label="LONG")
                    score_short, t_short = (0.0, 3600.0)

                if score_short > score_long:
                    self._symbol_best_side[sym] = "SHORT"
                    self._symbol_t_star[sym] = float(t_short)
                    best_score = float(score_short)
                else:
                    self._symbol_best_side[sym] = "LONG"
                    self._symbol_t_star[sym] = float(t_long)
                    best_score = float(score_long)

                self._log(
                    f"[SCORE_DEBUG] {sym} | side={self._symbol_best_side[sym]} | rho={rho:.2e} | "
                    f"T*={self._symbol_t_star[sym]:.0f} | score={best_score:.6f}"
                )
                return float(best_score)
            else:
                # No EV data available, use default
                self._symbol_t_star[sym] = 3600.0  # Default 1 hour when no EV data
            
            # Fallback: best-side mix EV (prefer meta; never use `or` because negatives are truthy).
            v_long = None
            v_short = None
            try:
                if isinstance(meta, dict):
                    v_long = meta.get("policy_ev_mix_long")
                    v_short = meta.get("policy_ev_mix_short")
            except Exception:
                v_long = None
                v_short = None
            if v_long is None and v_short is None:
                try:
                    v_long = detail.get("policy_ev_mix_long")
                    v_short = detail.get("policy_ev_mix_short")
                except Exception:
                    v_long = None
                    v_short = None

            v_long_f = None
            v_short_f = None
            try:
                if v_long is not None:
                    v_long_f = float(v_long)
            except Exception:
                v_long_f = None
            try:
                if v_short is not None:
                    v_short_f = float(v_short)
            except Exception:
                v_short_f = None

            if v_long_f is None and v_short_f is None:
                return 0.0
            if v_short_f is None or (v_long_f is not None and float(v_long_f) >= float(v_short_f)):
                self._symbol_best_side[sym] = "LONG"
                return float(v_long_f) if v_long_f is not None else 0.0
            self._symbol_best_side[sym] = "SHORT"
            return float(v_short_f)
        except Exception as e:
            self._log_err(f"[ERR] _get_symbol_expected_value {sym}: {e}")
            return 0.0

    def _get_symbol_score_a_for_side(
        self,
        *,
        sym: str,
        detail: Dict[str, Any],
        side: str,
        is_current: bool,
        age_sec: float,
    ) -> tuple[float, float]:
        """
        Direction-aware Score_A for a given side.

        Args:
            sym: symbol
            detail: decision dict or engine detail dict (must contain MC meta)
            side: "LONG" or "SHORT"
            is_current: True if evaluating an existing position held right now
            age_sec: current holding age (only used when is_current=True)

        Returns:
            (score_a, t_star_sec)
        """
        side_u = str(side or "").upper()
        if side_u not in ("LONG", "SHORT"):
            return 0.0, 3600.0
        if not isinstance(detail, dict):
            return 0.0, 3600.0

        meta = self._extract_mc_meta(detail)
        ev_long, ev_short = extract_directional_ev_by_horizon_from_meta(meta)
        ev_dict = ev_long if side_u == "LONG" else ev_short
        if not ev_dict:
            # Back-compat: fall back to the (single) curve if directional curves are missing.
            ev_dict = extract_ev_by_horizon_from_meta(meta)
        if not ev_dict or len(ev_dict) < 2:
            return 0.0, 3600.0

        rho = calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)

        # Cost model: use engine meta when available; no hardcoded defaults.
        fee_mix = None
        spread_cost = None
        slip_cost = None
        fee_rt_total = None
        try:
            fee_rt_total = meta.get("fee_roundtrip_total")
        except Exception:
            fee_rt_total = None
        if fee_rt_total is None:
            try:
                fee_rt_total = meta.get("execution_cost")
            except Exception:
                fee_rt_total = None
        try:
            fee_mix = meta.get("fee_roundtrip_fee_mix")
        except Exception:
            fee_mix = None
        try:
            spread_cost = meta.get("expected_spread_cost")
        except Exception:
            spread_cost = None
        try:
            slip_cost = meta.get("slippage_dyn")
        except Exception:
            slip_cost = None

        total = None
        try:
            if fee_rt_total is not None:
                total = float(fee_rt_total)
        except Exception:
            total = None
        if total is None:
            parts = []
            for v in (fee_mix, spread_cost, slip_cost):
                try:
                    if v is not None:
                        fv = float(v)
                        if math.isfinite(fv) and fv >= 0:
                            parts.append(fv)
                except Exception:
                    continue
            if parts:
                total = float(sum(parts))

        if total is None:
            try:
                total = float(self.paper_fee_roundtrip)
            except Exception:
                total = 0.0
        if (not math.isfinite(float(total))) or float(total) < 0:
            total = 0.0

        entry_fee = 0.5 * float(total)
        exit_fee = 0.5 * float(total)
        slippage = 0.0

        fee_for_opt = float(exit_fee) if is_current else float(total)
        t_star, _ = find_optimal_horizon(ev_dict, fee_for_opt)

        score = calculate_opportunity_score(
            ev_by_horizon=ev_dict,
            optimal_horizon=t_star,
            rho=rho,
            current_age_sec=float(max(0.0, float(age_sec))) if is_current else 0.0,
            entry_fee=0.0 if is_current else entry_fee,
            exit_fee=exit_fee,
            slippage=0.0 if is_current else slippage,
        )
        return float(score), float(t_star)

    def _calculate_covariance_kelly(self, symbols: list[str], scores: list[float]) -> Dict[str, float]:
        """Portfolio Kelly with covariance (Abolished G1/G2, using TOP10)."""
        if not symbols: return {}
        try:
            data, valid = [], []
            for s in symbols:
                h = list(self._score_history.get(s, []))
                if len(h) >= 5:
                    v = [x[1] for x in h[-100:]]
                    if len(v) < 100: v = [v[0]] * (100 - len(v)) + v
                    data.append(v)
                    valid.append(s)
            
            # Default: no allocation unless there is positive expected value.
            weights: Dict[str, float] = {s: 0.0 for s in symbols}

            # If we have enough history, calculate Kelly weights
            if len(valid) >= 1:
                mu = np.array([scores[symbols.index(s)] for s in valid])
                mu_pos = np.array([max(0.0, float(m)) for m in mu])
                if float(np.sum(mu_pos)) <= 0.0:
                    return {s: 0.0 for s in symbols}
                
                try:
                    if len(valid) >= 2:
                        c_mat = np.cov(np.array(data))
                        c_mat += np.eye(len(valid)) * (np.mean(np.diag(c_mat)) * 0.1 + 1e-6)
                        f_raw = np.linalg.solve(c_mat, mu_pos) * 0.5
                    else:
                        var = np.var(data[0]) if np.var(data[0]) > 0 else 0.0001
                        f_raw = np.array([0.5 * mu_pos[0] / var])

                    final_raw = {s: float(f_raw[i]) for i, s in enumerate(valid)}
                    
                    # --- RESCALE BY GROUPS ---
                    top10_syms = [s for s in valid if self._group_info.get(s, {}).get("group") == "TOP10"]
                    
                    def apply_group_rescale(grp_syms, total_target_frac):
                        if not grp_syms: return
                        curr_sum = sum(max(0.001, final_raw.get(s, 0)) for s in grp_syms)
                        scale = total_target_frac / curr_sum
                        for s in grp_syms:
                            final_raw[s] = final_raw.get(s, 0) * scale

                    # Target total cap_frac (before leverage)
                    # TOP10: 200% total allocation (across 10 assets -> 20% each avg)
                    apply_group_rescale(top10_syms, 2.00) 
                    
                    for s in valid:
                        info = self._group_info.get(s, {})
                        group = info.get("group", "OTHER")
                        cap = float(info.get("cap", 0.25 if group == "TOP10" else 0.05))
                        # Final cap_frac
                        weights[s] = max(0.0, min(final_raw.get(s, 0.0), cap))
                except:
                    pass # Keep defaults from above
            else:
                # Not enough history: allocate proportionally, but only to positive scores.
                top10_syms = [s for s in symbols if self._group_info.get(s, {}).get("group") == "TOP10"]
                if top10_syms:
                    top10_scores = [max(0.0, float(scores[symbols.index(s)])) for s in top10_syms]
                    total_score = float(sum(top10_scores))
                    if total_score > 0:
                        for i, s in enumerate(top10_syms):
                            proportion = float(top10_scores[i]) / total_score if total_score > 0 else 0.0
                            weights[s] = max(0.0, min(0.25, proportion * 2.0))  # 2.0 = 200% total
            
            return weights
        except Exception as e:
            if hasattr(self, '_log'):
                self._log(f"[ERR] Kelly calc failed: {e}")
            return {s: 0.0 for s in symbols}

    async def liquidate_all(self, reason: str = "User triggered") -> None:
        """Emergency Close All (RESTORED)."""
        if hasattr(self, '_log'):
            self._log(f"🚨 [LIQUIDATE] {reason}")
        for s in list(self.positions.keys()):
            p = self.positions.get(s)
            if p:
                await self._close_position(s, float(p.get("mark_price", p.get("price", 0.0))), now_ms(), f"Liquidate: {reason}")
        
        # Reset equity history with new format
        self._equity_history.clear()
        self._equity_history.append({"time": int(now_ms()), "equity": float(self.balance)})
        try:
            import json # Import json if not already imported
            self.state_files["equity"].write_text(json.dumps(list(self._equity_history)), encoding="utf-8")
        except Exception:
            pass # Silently fail if state file cannot be written

    @staticmethod
    def _pmaker_paper_sigma(closes: list[float], window: int = 60) -> float:
        if not closes:
            return 0.01
        n = len(closes)
        w = int(max(5, min(int(window), n)))
        xs = closes[-w:]
        try:
            arr = np.asarray(xs, dtype=np.float64)
            if arr.size < 6:
                return 0.01
            rets = np.diff(np.log(arr))
            if rets.size < 5:
                return 0.01
            sig = float(np.std(rets))
            if not math.isfinite(sig) or sig <= 0:
                return 0.01
            return float(max(1e-6, min(0.10, sig)))
        except Exception:
            return 0.01

    @staticmethod
    def _pmaker_paper_momentum_z(closes: list[float], sigma: float, window: int = 10) -> float:
        if not closes or len(closes) < int(window) + 2:
            return 0.0
        try:
            w = int(max(2, min(int(window), len(closes) - 1)))
            p0 = float(closes[-w - 1])
            p1 = float(closes[-1])
            if p0 <= 0 or p1 <= 0:
                return 0.0
            lr = float(math.log(p1 / p0))
            denom = float(max(1e-6, float(sigma))) * math.sqrt(float(w))
            z = float(lr / denom)
            if not math.isfinite(z):
                return 0.0
            return float(max(-8.0, min(8.0, z)))
        except Exception:
            return 0.0

    def _pmaker_paper_probe_tick(self, *, sym: str, ts_ms: int, ctx: Dict[str, Any]) -> None:
        """
        Paper-only PMaker training: simulate maker-limit fills at touch and update PMakerSurvivalMLP.
        """
        if not (self.paper_trading_enabled or self.enable_orders):
            return
        if not self.pmaker_paper_enabled:
            return
        pm = getattr(self, "pmaker", None)
        surv = getattr(pm, "surv", None) if pm is not None else None
        if pm is None or (not getattr(pm, "enabled", False)) or surv is None:
            return

        price = ctx.get("price")
        best_bid = ctx.get("best_bid")
        best_ask = ctx.get("best_ask")
        spread_pct = ctx.get("spread_pct")
        closes = ctx.get("closes") or []
        ofi_score = float(ctx.get("ofi_score") or 0.0)
        liq_score = float(ctx.get("liquidity_score") or 1.0)

        try:
            px = float(price) if price is not None else None
        except Exception:
            px = None
        if px is None or px <= 0:
            return

        try:
            bid = float(best_bid) if best_bid is not None else None
        except Exception:
            bid = None
        try:
            ask = float(best_ask) if best_ask is not None else None
        except Exception:
            ask = None
        try:
            sp = float(spread_pct) if spread_pct is not None else 0.0
        except Exception:
            sp = 0.0

        active = self._pmaker_paper_active.get(sym)
        if active is not None:
            side = str(active.get("side") or "")
            limit_px = active.get("limit_px")
            start_ms = int(active.get("start_ms") or ts_ms)
            timeout_ms = int(active.get("timeout_ms") or self.pmaker_paper_probe_timeout_ms)

            try:
                limit_px_f = float(limit_px) if limit_px is not None else None
            except Exception:
                limit_px_f = None
            if limit_px_f is None or limit_px_f <= 0:
                self._pmaker_paper_active.pop(sym, None)
                return

            filled = False
            if side == "buy":
                filled = bool(px <= float(limit_px_f))
            elif side == "sell":
                filled = bool(px >= float(limit_px_f))

            age_ms = int(ts_ms) - int(start_ms)
            if filled or (age_ms >= int(timeout_ms)):
                try:
                    first_fill_delay_ms = int(max(0, age_ms)) if filled else None
                    x = active.get("x")
                    if x is not None:
                        surv.update_one_attempt(
                            sym=sym,
                            x=x,
                            timeout_ms=int(timeout_ms),
                            first_fill_delay_ms=first_fill_delay_ms,
                            qty_attempt=1.0,
                            qty_filled=1.0 if filled else 0.0,
                        )
                        self._pmaker_paper_updates += 1
                        if self.pmaker_paper_train_every_n > 0 and (self._pmaker_paper_updates % int(self.pmaker_paper_train_every_n) == 0):
                            try:
                                surv.train_from_replay(steps=int(getattr(pm, "train_steps", 1)), batch_size=int(getattr(pm, "batch", 32)))
                            except Exception:
                                pass
                        if self.pmaker_paper_save_every_sec > 0:
                            if (ts_ms - int(self._pmaker_paper_last_save_ms)) >= int(self.pmaker_paper_save_every_sec * 1000):
                                self._pmaker_paper_last_save_ms = int(ts_ms)
                                try:
                                    pm.save_model()
                                except Exception:
                                    pass
                except Exception:
                    pass
                finally:
                    self._pmaker_paper_active.pop(sym, None)
            return

        # start a new probe (rate-limited)
        last_start = int(self._pmaker_paper_last_start_ms.get(sym) or 0)
        if (ts_ms - last_start) < int(max(0.1, float(self.pmaker_paper_probe_interval_sec)) * 1000):
            return
        if bid is None or ask is None or bid <= 0 or ask <= 0:
            return

        next_side = str(self._pmaker_paper_next_side.get(sym) or "buy")
        side = next_side if next_side in ("buy", "sell") else "buy"
        self._pmaker_paper_next_side[sym] = "sell" if side == "buy" else "buy"

        limit_px = float(bid) if side == "buy" else float(ask)
        mid = 0.5 * (float(bid) + float(ask))
        rel_px = (float(limit_px) - float(mid)) / float(mid) if mid > 0 else 0.0

        sigma = self._pmaker_paper_sigma(list(closes))
        mom_z = self._pmaker_paper_momentum_z(list(closes), sigma, window=10)

        try:
            x = surv.featurize(
                {
                    "spread_pct": float(sp),
                    "sigma": float(sigma),
                    "ofi_z": float(ofi_score),
                    "momentum_z": float(mom_z),
                    "liq_score": float(liq_score),
                    "attempt_idx": 0.0,
                    "rel_px": float(rel_px),
                }
            )
        except Exception:
            return

        self._pmaker_paper_active[sym] = {
            "side": side,
            "limit_px": float(limit_px),
            "start_ms": int(ts_ms),
            "timeout_ms": int(max(250, int(self.pmaker_paper_probe_timeout_ms))),
            "x": x,
        }
        self._pmaker_paper_last_start_ms[sym] = int(ts_ms)

    def runtime_config(self) -> Dict[str, Any]:
        return {
            "symbols": list(self.symbols),
            "decision_refresh_sec": float(self.decision_refresh_sec),
            "decision_eval_min_interval_sec": float(self.decision_eval_min_interval_sec),
            "decision_worker_sleep_sec": float(self.decision_worker_sleep_sec),
            "enable_orders": bool(self.enable_orders),
            "paper_trading_enabled": bool(self.paper_trading_enabled),
            "paper_flat_on_wait": bool(self.paper_flat_on_wait),
            "paper_use_engine_sizing": bool(self.paper_use_engine_sizing),
            "paper_engine_size_mult": float(self.paper_engine_size_mult),
            "paper_engine_size_min_frac": float(self.paper_engine_size_min_frac),
            "paper_engine_size_max_frac": float(self.paper_engine_size_max_frac),
            "paper_size_frac_default": float(self.paper_size_frac_default),
            "paper_leverage_default": float(self.paper_leverage_default),
            "paper_fee_roundtrip": float(self.paper_fee_roundtrip),
            "paper_slippage_bps": float(self.paper_slippage_bps),
            "paper_min_hold_sec": int(self.paper_min_hold_sec),
            "paper_max_hold_sec": int(self.paper_max_hold_sec),
            "paper_max_positions": int(self.paper_max_positions),
            "paper_exit_policy_only": bool(self.paper_exit_policy_only),
            "mc_n_paths_live": int(self.mc_n_paths_live),
            "mc_n_paths_exit": int(self.mc_n_paths_exit),
            "mc_use_jax": bool(self.mc_use_jax),
            "mc_tail_mode": str(self.mc_tail_mode),
            "mc_student_t_df": float(self.mc_student_t_df),
            "exec_mode": str(os.environ.get("EXEC_MODE", config.EXEC_MODE)).strip().lower(),
            "pmaker_enabled": bool(getattr(self.pmaker, "enabled", False)),
            "alpha_hit_enabled": any(getattr(e, "alpha_hit_enabled", False) for e in self.hub.engines),
        }

    def _paper_mark_position(self, sym: str, mark_price: Optional[float], ts_ms: int) -> None:
        # In live mode, positions/PnL are synced from the exchange.
        if bool(getattr(self, "enable_orders", False)) and bool(getattr(self, "live_sync_enabled", False)):
            return
        pos = self.positions.get(sym)
        if not pos or mark_price is None:
            return
        try:
            entry = float(pos.get("entry_price") or 0.0)
            qty = float(pos.get("size", 0.0) or 0.0)
            side = str(pos.get("side") or "").upper()
            if entry <= 0 or qty == 0:
                return
            if side == "SHORT":
                pnl = (entry - float(mark_price)) * qty
            else:
                pnl = (float(mark_price) - entry) * qty
            pos["current"] = float(mark_price)
            pos["price"] = float(mark_price)
            pos["unrealized_pnl"] = float(pnl)
            pos["pnl"] = float(pnl)

            margin = float(pos.get("margin") or 0.0)
            roe = (float(pnl) / margin) if margin > 0 else 0.0
            pos["roe"] = float(roe)
            
            # ✅ Track Max ROE for Trailing Stop
            current_max = float(pos.get("max_roe") or -999.0)
            if roe > current_max:
                pos["max_roe"] = float(roe)

            t0 = int(pos.get("time") or ts_ms)
            pos["age_sec"] = max(0.0, (int(ts_ms) - t0) / 1000.0)
        except Exception:
            return

    @staticmethod
    def _mark_price(best_bid: Optional[float], best_ask: Optional[float], last_price: Optional[float]) -> Optional[float]:
        try:
            if best_bid is not None and best_ask is not None:
                b = float(best_bid)
                a = float(best_ask)
                if b > 0 and a > 0:
                    return 0.5 * (b + a)
        except Exception:
            pass
        try:
            if last_price is not None:
                p = float(last_price)
                if p > 0:
                    return p
        except Exception:
            pass
        return None

    def _paper_append_trade(self, trade: Dict[str, Any]) -> None:
        # Prefer a human-readable clock time for the dashboard, while keeping the epoch in `ts`.
        try:
            ts_ms = trade.get("ts")
            if ts_ms is None:
                ts_ms = trade.get("ts_ms")
            if ts_ms is None:
                ts_ms = trade.get("time")
            ts_i = int(ts_ms) if ts_ms is not None else None
            if ts_i is not None and ts_i > 0:
                trade.setdefault("ts", int(ts_i))
                # keep `time` stable even if it's already a string from legacy data
                if not isinstance(trade.get("time"), str):
                    trade["time"] = time.strftime("%H:%M:%S", time.localtime(int(ts_i) / 1000.0))
        except Exception:
            pass
        self.trade_tape.append(trade)

    def _paper_fee_roundtrip_from_engine_meta(self, meta: Dict[str, Any]) -> Optional[float]:
        """
        Engine `fee_roundtrip_total` includes `expected_spread_cost`.
        Paper trading entries/exits are filled at bid/ask, so spread is already realized in PnL.
        Subtract spread here to avoid double-counting costs in paper PnL.
        """
        if not isinstance(meta, dict):
            return None
        try:
            total = float(meta.get("fee_roundtrip_total") or 0.0)
        except Exception:
            return None
        if total <= 0.0 or (not math.isfinite(total)):
            return None
        try:
            spread = float(meta.get("expected_spread_cost") or 0.0)
        except Exception:
            spread = 0.0
        if (not math.isfinite(spread)) or spread < 0.0:
            spread = 0.0
        fee = float(total) - float(spread)
        if (not math.isfinite(fee)) or fee < 0.0:
            fee = 0.0
        return float(fee)

    @staticmethod
    def _paper_exec_mode() -> str:
        return str(os.environ.get("EXEC_MODE", config.EXEC_MODE)).strip().lower()

    @staticmethod
    def _paper_p_maker_from_detail(detail: Optional[Dict[str, Any]], *, leg: str) -> float:
        if not isinstance(detail, dict):
            return 0.0
        meta = detail.get("meta") if isinstance(detail.get("meta"), dict) else {}
        keys = ("pmaker_entry", "p_maker") if leg == "entry" else ("pmaker_exit", "pmaker_entry", "p_maker")
        p = None
        for k in keys:
            if meta.get(k) is not None:
                p = meta.get(k)
                break
        try:
            v = float(p) if p is not None else 0.0
        except Exception:
            v = 0.0
        if not math.isfinite(v):
            v = 0.0
        return float(max(0.0, min(1.0, v)))

    def _paper_fill_price(
        self,
        *,
        side: str,
        leg: str,
        best_bid: Optional[float],
        best_ask: Optional[float],
        mark_price: Optional[float],
        detail: Optional[Dict[str, Any]],
    ) -> tuple[Optional[float], str]:
        """
        Paper execution model aligned to EXEC_MODE:
        - market: always taker at bid/ask
        - maker_then_market: Bernoulli(p_maker) maker at touch, else taker

        Returns (fill_price, exec_tag) where exec_tag ∈ {"maker","taker","mark"}.
        """
        side_u = str(side or "").upper()
        if side_u not in ("LONG", "SHORT"):
            return None, "mark"
        leg_u = str(leg or "").lower()
        if leg_u not in ("entry", "exit"):
            leg_u = "entry"

        exec_mode = self._paper_exec_mode()

        def _f(x):
            try:
                v = float(x) if x is not None else None
            except Exception:
                v = None
            if v is None or (not math.isfinite(v)) or v <= 0.0:
                return None
            return float(v)

        bid = _f(best_bid)
        ask = _f(best_ask)
        mark = _f(mark_price)

        if leg_u == "entry":
            px_taker = ask if side_u == "LONG" else bid
            px_maker = bid if side_u == "LONG" else ask
            is_buy = side_u == "LONG"
        else:
            px_taker = bid if side_u == "LONG" else ask
            px_maker = ask if side_u == "LONG" else bid
            is_buy = side_u == "SHORT"

        px = px_taker
        tag = "taker"
        if exec_mode == "maker_then_market":
            p_maker = self._paper_p_maker_from_detail(detail, leg=leg_u)
            if p_maker > 0.0 and px_maker is not None and random.random() < p_maker:
                px = px_maker
                tag = "maker"
        if px is None:
            return (mark, "mark") if mark is not None else (None, "mark")

        # Optional slippage (bps): apply to taker fills only (maker fills assume near-zero slip).
        slip = float(max(0.0, self.paper_slippage_bps)) / 10000.0
        if tag == "taker" and slip > 0:
            if is_buy:
                px = float(px) * (1.0 + slip)
            else:
                px = float(px) * (1.0 - slip)
        return float(px), tag

    def _exchange_symbol_id(self, sym: str) -> str:
        """Symbol as used by ccxt (keep settlement suffix for swaps)."""
        return str(sym)

    async def _place_live_order(
        self,
        sym: str,
        side: str,
        amount: float,
        price: Optional[float],
        *,
        leverage: Optional[float] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> Optional[Dict[str, Any]]:
        if not (self.enable_orders and getattr(self, "exchange", None)):
            return None
        amount = float(max(0.0, amount))
        if amount <= 0.0:
            return None
        order_side = str(side or "").lower()
        if order_side not in ("buy", "sell"):
            return None
        symbol = self._exchange_symbol_id(sym)
        reduce_only = False
        try:
            reduce_only = bool((params or {}).get("reduceOnly"))
        except Exception:
            reduce_only = False
        try:
            # Ensure markets are loaded so we can apply amount precision/min checks.
            try:
                if not (getattr(self.exchange, "markets", None) or {}):
                    await self._ccxt_call("load_markets(order)", self.exchange.load_markets)
            except Exception:
                pass

            # Apply exchange amount precision/minimums (prevents hard rejects like BTC min 0.001).
            try:
                raw_amount = float(amount)
                amt_prec = self.exchange.amount_to_precision(symbol, float(amount))
                amount = float(amt_prec)
                # Some exchanges round tiny amounts down to 0.0; for reduceOnly closes, prefer attempting
                # the raw amount so we can finish flattening residual positions.
                if amount <= 0.0 and reduce_only and raw_amount > 0.0:
                    amount = float(raw_amount)
            except Exception:
                pass
            if amount <= 0.0:
                return None
            try:
                mkt = (getattr(self.exchange, "markets", {}) or {}).get(symbol) or self.exchange.market(symbol)
                lim = (mkt.get("limits") or {}).get("amount") if isinstance(mkt, dict) else None
                min_amt = lim.get("min") if isinstance(lim, dict) else None
                if min_amt is not None and float(min_amt) > 0 and float(amount) < float(min_amt) and (not reduce_only):
                    if hasattr(self, "_log"):
                        self._log(
                            f"[LIVE_ORDER_SKIP] {sym} {order_side.upper()} amt={amount:.8f} < min={float(min_amt):.8f}"
                        )
                    try:
                        self._last_trade_event_by_sym[str(sym)] = "ORDER_SKIP"
                    except Exception:
                        pass
                    return None
                if min_amt is not None and float(min_amt) > 0 and float(amount) < float(min_amt) and reduce_only:
                    # For reduceOnly closes, prefer bumping to the minimum.
                    # Bybit often rejects sub-min close orders (e.g. SUI min=10), which can leave "dust" positions.
                    old_amt = float(amount)
                    try:
                        amount = float(min_amt)
                        try:
                            amount = float(self.exchange.amount_to_precision(symbol, float(amount)))
                        except Exception:
                            pass
                    except Exception:
                        amount = float(old_amt)
                    try:
                        self._log_err(
                            f"[LIVE_ORDER_WARN] {sym} reduceOnly {order_side.upper()} amt={old_amt:.8f} < min={float(min_amt):.8f} -> bumped to {float(amount):.8f}"
                        )
                    except Exception:
                        pass
            except Exception:
                pass

            # Ensure leverage is applied before submitting the order.
            if leverage is not None:
                await self._ensure_live_leverage(sym, float(leverage))

            # Bybit: use MARKET when no price is provided; otherwise submit a LIMIT order.
            order_type = "market"
            price_arg = None
            px_in = None
            if price is not None:
                try:
                    px_in = float(price)
                except Exception:
                    px_in = None
            if px_in is not None and math.isfinite(px_in) and px_in > 0:
                order_type = "limit"
                try:
                    price_arg = float(self.exchange.price_to_precision(symbol, px_in))
                except Exception:
                    price_arg = float(px_in)
                if params is None:
                    params = {}
                # Default to GTC for limit orders unless explicitly set.
                if (params.get("timeInForce") is None) and (params.get("time_in_force") is None):
                    params["timeInForce"] = "GTC"

            res = self.exchange.create_order(
                symbol,
                str(order_type),
                order_side,
                amount,
                price_arg,
                params or {},
            )
            result = await res if asyncio.iscoroutine(res) else res
            if hasattr(self, "_log"):
                self._log(f"[DEBUG_ORDER_RES] {sym} res={result}")
            if hasattr(self, "_log"):
                self._log(
                    f"[LIVE_ORDER] {sym} {order_side.upper()} {str(order_type).upper()} x{amount:.4f} @ {price_arg if price_arg is not None else None} params={params or {}}"
                )
            # Some venues (notably Bybit TESTNET) can return an order immediately as canceled/rejected
            # (e.g. one-sided book: EC_NoImmediateQtyToFill). Treat these as "failed to place" so
            # callers can fall back (e.g. to a reduceOnly limit close).
            try:
                status = result.get("status") if isinstance(result, dict) else None
                status_s = str(status or "").lower()
                info = (result.get("info") if isinstance(result, dict) else None) or {}
                reject_reason = ""
                ret_code = None
                ret_msg = ""
                if isinstance(info, dict):
                    try:
                        reject_reason = str(info.get("rejectReason") or info.get("reject_reason") or "")
                    except Exception:
                        reject_reason = ""
                    try:
                        ret_code = info.get("retCode")
                    except Exception:
                        ret_code = None
                    try:
                        ret_msg = str(info.get("retMsg") or info.get("ret_msg") or "")
                    except Exception:
                        ret_msg = ""
                if status_s in ("canceled", "cancelled", "rejected", "expired") or bool(reject_reason):
                    if hasattr(self, "_log_err"):
                        self._log_err(
                            f"[LIVE_ORDER_REJECT] {sym} {order_side.upper()} {str(order_type).upper()} x{amount:.4f} status={status_s or None} retCode={ret_code} rejectReason={reject_reason} retMsg={ret_msg}"
                        )
                    try:
                        self._last_trade_event_by_sym[str(sym)] = "ORDER_REJECT"
                    except Exception:
                        pass
                    return None
            except Exception:
                pass
            try:
                self._last_trade_event_by_sym[str(sym)] = "ORDER_OK"
            except Exception:
                pass
            return result
        except Exception as e:
            if hasattr(self, "_log_err"):
                self._log_err(f"[LIVE_ORDER_ERR] {sym} {order_side.upper()} x{amount:.4f} @ {price}: {e}")
            # Risk reaction: insufficient margin / balance for new order.
            try:
                msg = str(e) or type(e).__name__
                if ("110007" in msg) or ("insufficient" in msg.lower()) or ("not enough" in msg.lower()):
                    if hasattr(self, "risk"):
                        self.risk.on_insufficient_margin_error(now_ms(), sym=str(sym), err_msg=msg)
            except Exception:
                pass
            try:
                self._last_trade_event_by_sym[str(sym)] = "ORDER_ERR"
            except Exception:
                pass
            return None

    async def _ensure_live_leverage(self, sym: str, leverage: float) -> None:
        """
        Best-effort leverage setter for Bybit.
        - Throttles calls per symbol.
        - Treats "leverage not modified" as success, but can verify if our view still shows 1x.
        """
        if not (self.enable_orders and getattr(self, "exchange", None)):
            return
        try:
            target = int(max(1, round(float(leverage))))
        except Exception:
            return
        if target <= 0:
            return

        now = int(now_ms())
        last = int(self._live_leverage_last_set_ms.get(str(sym), 0) or 0)
        if self.live_leverage_min_interval_ms > 0 and (now - last) < int(self.live_leverage_min_interval_ms):
            return

        # If we already observe the desired leverage, skip.
        curr = None
        try:
            pos = (self.positions or {}).get(str(sym))
            if isinstance(pos, dict) and pos.get("leverage") is not None:
                curr = float(pos.get("leverage"))
        except Exception:
            curr = None
        if curr is not None and abs(float(curr) - float(target)) < 0.25:
            return

        symbol = self._exchange_symbol_id(sym)
        try:
            await self._ccxt_call(f"set_leverage {sym}", self.exchange.set_leverage, int(target), symbol)
            self._live_leverage_last_set_ms[str(sym)] = now
            self._live_leverage_target[str(sym)] = float(target)
            return
        except Exception as e:
            msg = str(e) or type(e).__name__
            # Bybit returns retCode=110043 when leverage is already set; treat as non-fatal.
            if "110043" in msg or "leverage not modified" in msg.lower():
                self._live_leverage_last_set_ms[str(sym)] = now
                self._live_leverage_target[str(sym)] = float(target)
                # If our observed leverage is still far from target (common when stuck at 1x),
                # verify once by fetching the position and log the actual leverage.
                try:
                    if curr is None or abs(float(curr) - float(target)) >= 0.25:
                        res = await self._ccxt_call(f"fetch_positions(lev_verify) {sym}", self.exchange.fetch_positions, [symbol])
                        if isinstance(res, list) and res:
                            p = res[0] if len(res) == 1 else next((x for x in res if (x or {}).get("symbol") == str(sym)), res[0])
                            lev_now = None
                            if isinstance(p, dict):
                                try:
                                    lev_now = float(p.get("leverage")) if p.get("leverage") is not None else None
                                except Exception:
                                    lev_now = None
                            if lev_now is not None and abs(float(lev_now) - float(target)) >= 0.25:
                                self._log_err(f"[LIVE_LEVERAGE_VERIFY] {sym} target={target} observed={curr} exchange={lev_now} (still mismatched)")
                except Exception:
                    pass
                return
            # Bybit retCode=110013 when requested leverage exceeds risk-limit max; clamp and retry once.
            if "110013" in msg or "maxLeverage" in msg:
                try:
                    max_lev = self._max_exchange_leverage(sym)
                except Exception:
                    max_lev = None
                if max_lev is not None and float(max_lev) > 0:
                    try:
                        clamped = int(max(1, min(int(target), int(float(max_lev)))))
                    except Exception:
                        clamped = None
                    if clamped is not None and clamped != int(target):
                        try:
                            await self._ccxt_call(f"set_leverage(clamp) {sym}", self.exchange.set_leverage, int(clamped), symbol)
                            self._live_leverage_last_set_ms[str(sym)] = now
                            self._live_leverage_target[str(sym)] = float(clamped)
                            return
                        except Exception:
                            pass
            self._log_err(f"[LIVE_LEVERAGE_ERR] {sym} target={target}: {e}")
            self._live_leverage_last_set_ms[str(sym)] = now
            return

    def _schedule_live_order(
        self,
        sym: str,
        side: str,
        amount: float,
        price: Optional[float] = None,
        *,
        leverage: Optional[float] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> bool:
        if not (self.enable_orders and getattr(self, "exchange", None)):
            return False
        # Manual pause: block non-reduceOnly orders (entry / increase / rebalance adds).
        try:
            now = int(now_ms())
            reduce_only = bool((params or {}).get("reduceOnly"))
            if self._manual_pause_active(now) and (not reduce_only):
                if hasattr(self, "_log"):
                    self._log(f"[PAUSE] Blocked non-reduceOnly order during manual pause: {sym} {side} amt={amount}")
                return False
        except Exception:
            pass
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = None
        if loop is None:
            # Fallback: run synchronously to avoid losing orders in tests/out-of-loop contexts.
            asyncio.run(self._place_live_order(sym, side, amount, price, leverage=leverage, params=params))
        else:
            loop.create_task(self._place_live_order(sym, side, amount, price, leverage=leverage, params=params))
        return True
    async def _open_position(self, **kwargs) -> None:
        if self.enable_orders:
            await self._live_open_position(**kwargs)
        else:
            await self._paper_open_position(**kwargs)

    async def _close_position(self, **kwargs) -> None:
        if self.enable_orders:
            await self._live_close_position(**kwargs)
        else:
            await self._paper_close_position(**kwargs)

    async def _live_open_position(
        self,
        *,
        sym: str,
        side: str,
        entry_price: float,
        ts_ms: int,
        cap_frac: float,
        leverage: float,
        fee_roundtrip: float,
        reason: str,
        detail: Optional[Dict[str, Any]] = None,
    ) -> None:
        balance = float(self.balance)
        if hasattr(self, "risk") and hasattr(self.risk, "get_total_equity"):
            balance = float(self.risk.get_total_equity(balance))
        
        notional_target = balance * cap_frac * leverage
        amount = notional_target / entry_price if entry_price > 0 else 0
        
        res = await self._place_live_order(
            sym=sym,
            side="buy" if side.upper() == "LONG" else "sell",
            amount=amount,
            price=entry_price, # LIMIT order for entry
            leverage=leverage
        )
        if res:
            # Sync to local positions
            if sym not in self._pos_meta:
                self._pos_meta[sym] = {
                    "entry_group": self._get_validated_entry_group(sym) or "OTHER",
                    "entry_rank": self._get_current_rank(sym),
                    "entry_order": self._entry_order_counter,
                    "entry_t_star": self._symbol_t_star.get(sym, 0.0),
                }
                self._entry_order_counter += 1
            
            meta = self._pos_meta.get(sym) or {}
            self.positions[sym] = {
                "symbol": sym,
                "side": side.upper(),
                "entry_price": entry_price,
                "price": entry_price,
                "current": entry_price,
                "size": amount,
                "quantity": amount,
                "leverage": leverage,
                "time": ts_ms,
                "cap_frac": cap_frac,
                "margin": notional_target / leverage if leverage > 0 else 0,
                "notional": notional_target,
                "entry_group": meta.get("entry_group"),
                "entry_rank": meta.get("entry_rank"),
                "entry_order": meta.get("entry_order"),
                "entry_t_star": meta.get("entry_t_star"),
                "reason": reason,
            }
            self._log(f"🟢 [LIVE_OPEN] {sym} {side.upper()} @ {entry_price:.4f} (notional={notional_target:.2f} lev={leverage:.1f})")

    async def _live_close_position(
        self,
        *,
        sym: str,
        exit_price: float,
        ts_ms: int,
        reason: str,
    ) -> None:
        pos = self.positions.get(sym)
        if not pos:
            return
        
        side = str(pos.get("side") or "").upper()
        size = abs(float(pos.get("size") or pos.get("quantity") or 0.0))
        
        if size > 0:
            params = {"reduceOnly": True}
            p_idx = pos.get("position_idx")
            if p_idx is not None:
                params["positionIdx"] = int(p_idx)
            else:
                params["positionIdx"] = 0 # Default to 0 (one-way / hedge-side 0)

            res = await self._place_live_order(
                sym=sym,
                side="sell" if side == "LONG" else "buy",
                amount=size,
                price=None, # MARKET close
                params=params
            )
            if res:
                self.positions.pop(sym, None)
                self._pos_meta.pop(sym, None)
                self._log(f"🔴 [LIVE_CLOSE] {sym} {side} @ {exit_price:.4f} reason={reason}")

    async def _paper_open_position(
        self,
        *,
        sym: str,
        side: str,
        entry_price: float,
        ts_ms: int,
        cap_frac: float,
        leverage: float,
        fee_roundtrip: float,
        reason: str,
        detail: Optional[Dict[str, Any]] = None,
    ) -> None:
        side_u = str(side).upper()
        if side_u not in ("LONG", "SHORT"): return
        if entry_price <= 0: return

        # Risk clamping
        cap = float(max(0.0, min(1.0, cap_frac)))
        lev = float(max(1.0, float(leverage or 1.0)))
        
        # Enforce exposure caps (if enabled)
        if self.exposure_cap_enabled:
            try:
                allowed_notional = float(self.balance) * float(self.max_notional_exposure)
                current_notional = float(self._total_open_notional())
                if current_notional >= allowed_notional: return
                
                # Clamp entry cap if it would exceed total allowed
                req_notional = float(self.balance) * cap * lev
                if (current_notional + req_notional) > allowed_notional:
                    remaining = allowed_notional - current_notional
                    cap = remaining / (float(self.balance) * lev)
                    cap = max(0.0, cap)
                    if cap <= 0: return
            except Exception:
                pass
        
        notional = float(self.balance) * cap * lev
        size = notional / entry_price if entry_price > 0 else 0
        
        # Meta Initialization
        if sym not in self._pos_meta:
            self._pos_meta[sym] = {
                "entry_group": self._get_validated_entry_group(sym) or "OTHER",
                "entry_rank": self._get_current_rank(sym),
                "entry_order": self._entry_order_counter,
                "entry_t_star": self._symbol_t_star.get(sym, 0.0),
            }
            self._entry_order_counter += 1
            
        meta = self._pos_meta.get(sym) or {}
        self.positions[sym] = {
            "symbol": sym,
            "side": side_u,
            "entry_price": float(entry_price),
            "price": float(entry_price),
            "current": float(entry_price),
            "size": float(size),
            "quantity": float(size),
            "leverage": float(lev),
            "time": int(ts_ms),
            "cap_frac": float(cap),
            "margin": notional / lev if lev > 0 else 0,
            "notional": float(notional),
            "entry_group": meta.get("entry_group"),
            "entry_rank": meta.get("entry_rank"),
            "entry_order": meta.get("entry_order"),
            "entry_t_star": meta.get("entry_t_star"),
            "reason": str(reason),
        }
        self._log(f"🟢 [OPEN] {sym} {side_u} @ {entry_price:.4f} (cap={cap:.3f} lev={lev:.1f})")

    async def _paper_close_position(
        self,
        *,
        sym: str,
        exit_price: float,
        ts_ms: int,
        reason: str,
    ) -> None:
        pos = self.positions.get(sym)
        if not pos: return
        
        side = str(pos.get("side") or "").upper()
        entry = float(pos.get("entry_price") or 0.0)
        size = float(pos.get("size") or pos.get("quantity") or 0.0)
        margin = float(pos.get("margin") or 1.0)
        
        if entry > 0 and size > 0:
            if side == "LONG":
                pnl = (exit_price - entry) * size
            else:
                pnl = (entry - exit_price) * size
            
            roe = pnl / margin if margin > 0 else 0
            self.balance = float(self.balance) + pnl
            
            self._paper_append_trade({
                "time": int(ts_ms),
                "sym": sym,
                "type": "EXIT",
                "side": side,
                "entry_price": entry,
                "price": exit_price,
                "qty": size,
                "pnl": pnl,
                "roe": roe,
                "reason": reason,
            })
            
        self.positions.pop(sym, None)
        self._pos_meta.pop(sym, None)
        self._log(f"🔴 [CLOSE] {sym} {side} @ {exit_price:.4f} reason={reason}")

    def _trigger_position_refill(self, ts_ms: int) -> None:
        """
        청산 후 포지션 슬롯을 채우기 위해 상위 랭크 종목 재평가.
        최대 10개 포지션 유지.
        """
        try:
            # 현재 포지션 개수 확인
            current_positions = len(self.positions)
            
            if current_positions >= self._max_positions:
                return  # 이미 최대 포지션
            
            # 상위 랭크 종목 중 포지션 없는 종목 찾기
            available_slots = self._max_positions - current_positions
            
            if not self._latest_rankings:
                return  # 랭킹 정보 없음
            
            filled_count = 0
            for sym in self._latest_rankings[:self._max_positions]:
                if filled_count >= available_slots:
                    break
                
                if sym in self.positions:
                    continue  # 이미 포지션 있음
                
                # 쿨다운 체크
                last_exit = self._last_exit_time.get(sym, 0)
                if (ts_ms - last_exit) < self._exit_cooldown_ms:
                    if hasattr(self, '_log'):
                        self._log(f"[REFILL] {sym} in cooldown, skipping")
                    continue  # 쿨다운 중
                
                # 해당 종목의 스코어 확인
                score = self._symbol_scores.get(sym, 0.0)
                if score <= 0:
                    continue  # 스코어가 없거나 음수
                
                # 다음 사이클에서 진입 시도하도록 마킹
                # (실제 진입은 _paper_trade_step에서 처리됨)
                if hasattr(self, '_log'):
                    rank = self._latest_rankings.index(sym) + 1 if sym in self._latest_rankings else '?'
                    self._log(f"[REFILL] Slot available for {sym} (rank {rank}, score {score:.4f})")
                
                filled_count += 1
                
        except Exception as e:
            if hasattr(self, '_log'):
                self._log(f"[ERR] _trigger_position_refill: {e}")

    def _paper_init_exit_policy_state(self, sym: str, detail: Optional[Dict[str, Any]], ts_ms: int) -> None:
        pos = self.positions.get(sym)
        if not pos:
            return

        meta = detail.get("meta") if isinstance(detail, dict) and isinstance(detail.get("meta"), dict) else {}
        horizon = None
        # Prefer the targeted horizon (Plan A: best single horizon) over weighted effective horizon.
        for k in ("policy_horizon_eff_sec", "policy_h_eff_sec", "best_horizon_steps"):
            try:
                v = meta.get(k)
                if v is None:
                    continue
                horizon = int(max(0, float(v)))
                break
            except Exception:
                continue
        if horizon is None or horizon <= 0:
            horizon = int(max(1, int(self.paper_exit_policy_horizon_sec_default)))

        pos["policy_horizon_sec"] = int(horizon)
        pos["policy_flip_streak"] = 0
        pos["policy_hold_bad"] = 0
        pos["policy_last_eval_ms"] = int(ts_ms)
        try:
            pos["policy_mu_annual"] = float(meta.get("mu_adjusted")) if meta.get("mu_adjusted") is not None else None
        except Exception:
            pos["policy_mu_annual"] = None
        try:
            sigma_v = None
            for k in ("sigma_annual", "policy_paths_sigma_annual", "sigma_sim"):
                if meta.get(k) is not None:
                    sigma_v = meta.get(k)
                    break
            pos["policy_sigma_annual"] = float(sigma_v) if sigma_v is not None else None
        except Exception:
            pos["policy_sigma_annual"] = None

    def _paper_exit_policy_signal(
        self,
        *,
        sym: str,
        pos: Dict[str, Any],
        ts_ms: int,
        best_bid: Optional[float],
        best_ask: Optional[float],
        mark_price: Optional[float],
        detail: Optional[Dict[str, Any]],
    ) -> tuple[str, str]:
        """
        Returns (action, reason) where action ∈ {"HOLD","EXIT","FLIP_LONG","FLIP_SHORT"}.
        This is a lightweight, real-time approximation of the engine's exit-policy rules.
        """
        side = str(pos.get("side") or "").upper()
        if side not in ("LONG", "SHORT"):
            return "HOLD", "policy:bad_side"
        side_now = 1 if side == "LONG" else -1
        alt_side = -side_now
        alt_label = "LONG" if alt_side == 1 else "SHORT"

        age_sec = float(pos.get("age_sec") or 0.0)
        try:
            t0 = int(pos.get("time") or ts_ms)
            age_sec = max(age_sec, max(0.0, (int(ts_ms) - t0) / 1000.0))
        except Exception:
            pass

        min_hold = int(max(0, int(self.paper_exit_policy_min_hold_sec)))
        horizon = int(max(1, int(pos.get("policy_horizon_sec") or 0) or int(self.paper_exit_policy_horizon_sec_default)))
        tau = float(max(0.0, float(horizon) - float(age_sec)))

        # time_stop (Relaxed: Do not exit solely on time, rely on score/trailing_stop)
        # if horizon > 0 and age_sec >= float(horizon):
        #     px_exit = best_bid if side == "LONG" else best_ask
        #     if px_exit is None:
        #         px_exit = mark_price
        #     if px_exit is None:
        #         return "HOLD", "policy:time_stop(no_px)"
        #     return "EXIT", f"policy:time_stop(h={horizon}s age={age_sec:.1f}s)"

        # Resolve a usable detail object for scoring (engine detail preferred; fall back to cached decision).
        score_detail: Optional[Dict[str, Any]] = detail if isinstance(detail, dict) else None
        if score_detail is None:
            cached = self._decision_cache.get(sym) or {}
            cand = cached.get("decision")
            if isinstance(cand, dict):
                score_detail = cand

        # Throttle decision ticks to the policy DT (avoid counter explosion on fast loops)
        dt_sec = int(max(1, int(self.paper_exit_policy_decision_dt_sec)))
        last_eval = pos.get("policy_last_eval_ms")
        if last_eval is not None:
            try:
                if (int(ts_ms) - int(last_eval)) < int(dt_sec * 1000):
                    return "HOLD", "policy:dt_skip"
            except Exception:
                pass
        pos["policy_last_eval_ms"] = int(ts_ms)

        # EconomicBrain 4-way decision (HOLD / REVERSE / SWITCH / CASH).
        if bool(getattr(self, "paper_economic_brain_enabled", False)) and score_detail is not None:
            # Min-hold gating (dynamic horizon-aware)
            dynamic_hold = int(pos.get("dynamic_min_hold") or 0)
            effective_min_hold = max(float(min_hold), float(dynamic_hold))
            if age_sec < effective_min_hold:
                return "HOLD", f"economic:min_hold(age={age_sec:.0f}s<{effective_min_hold:.0f}s)"

            horizons, ev_rate, meta, lev_meta = self._economic_extract_curve(score_detail)
            if horizons is None or ev_rate is None or meta is None:
                cached2 = self._decision_cache.get(sym) or {}
                cand2 = cached2.get("decision")
                if isinstance(cand2, dict) and cand2 is not score_detail:
                    horizons, ev_rate, meta, lev_meta = self._economic_extract_curve(cand2)
            if horizons is None or ev_rate is None or meta is None:
                return "HOLD", "economic:no_curve"

            # Evaluate in the leverage space of the *current* position (so hold/reverse are comparable to what we hold).
            lev_pos = None
            try:
                if pos.get("leverage") is not None:
                    lev_pos = float(pos.get("leverage"))
            except Exception:
                lev_pos = None
            lev_used = float(lev_meta) if lev_meta is not None and float(lev_meta) > 0 else None
            lev_eval = float(lev_pos) if lev_pos is not None and lev_pos > 0 else (float(lev_used) if lev_used else float(self.leverage))

            ev_rate_eval = np.asarray(ev_rate, dtype=float)
            if lev_used and lev_eval and float(lev_used) > 0 and float(lev_eval) > 0:
                try:
                    scale = float(lev_eval) / float(lev_used)
                    if math.isfinite(scale) and abs(scale - 1.0) > 1e-6:
                        ev_rate_eval = ev_rate_eval * float(scale)
                except Exception:
                    pass

            brain = self._economic_brain_from_meta(meta, leverage=float(lev_eval))
            rho = calculate_dynamic_decay_rho(self.trade_tape, initial_capital=10000.0)
            r_f = float(self.paper_rf_per_sec)

            exclude = set(self.positions.keys())
            best_switch = self._economic_best_switch_candidate(exclude_symbols=exclude)

            econ_action, winning_score = brain.evaluate_4way(
                current_symbol=str(sym),
                current_side=int(side_now),
                current_horizons_sec=horizons,
                current_ev_rate_vector=ev_rate_eval,
                best_switch_candidate=best_switch,
                rho=rho,
                r_f=r_f,
            )

            if econ_action == "CASH":
                return "EXIT", f"economic:cash(napv={winning_score:.6f})"
            if econ_action == "REVERSE":
                return f"FLIP_{alt_label}", f"economic:reverse(napv={winning_score:.6f})"
            if econ_action == "SWITCH" and best_switch is not None:
                tgt_side = "LONG" if int(best_switch.side) == 1 else "SHORT"
                return (
                    f"SWITCH_{tgt_side}|{best_switch.symbol}",
                    f"economic:switch_to({best_switch.symbol},{tgt_side}) napv={winning_score:.6f}",
                )
            return "HOLD", f"economic:hold(napv={winning_score:.6f})"

        # Direction-aware Score_A (vector: LONG/SHORT) exit/flip policy.
        # Core rules (requested):
        #  1) If current-side discounted EV integral < 0 → EXIT (or FLIP if opposite is better enough).
        #  2) Prefer FLIP when opposite-side Score_A dominates after min_hold.
        if score_detail is not None:
            # Min-hold gating (dynamic horizon-aware)
            dynamic_hold = int(pos.get("dynamic_min_hold") or 0)
            effective_min_hold = max(float(min_hold), float(dynamic_hold))
            if age_sec < effective_min_hold:
                return "HOLD", f"policy:min_hold(age={age_sec:.0f}s<{effective_min_hold:.0f}s)"

            cur_side = "LONG" if side_now == 1 else "SHORT"
            alt_side_str = "SHORT" if cur_side == "LONG" else "LONG"

            try:
                score_cur, t_cur = self._get_symbol_score_a_for_side(
                    sym=sym,
                    detail=score_detail,
                    side=cur_side,
                    is_current=True,
                    age_sec=age_sec,
                )
                score_alt, t_alt = self._get_symbol_score_a_for_side(
                    sym=sym,
                    detail=score_detail,
                    side=alt_side_str,
                    is_current=False,
                    age_sec=0.0,
                )
            except Exception:
                score_cur, t_cur = 0.0, float(horizon)
                score_alt, t_alt = 0.0, float(horizon)

            # Convert a per-ROE margin into score-units (area) using the smaller relevant horizon.
            # This keeps the old `paper_exit_policy_score_margin` usable without introducing new knobs.
            mgn_roe = float(max(0.0, float(self.paper_exit_policy_score_margin)))
            scale_h = float(max(1.0, min(float(t_cur or horizon), float(t_alt or horizon))))
            mgn = float(mgn_roe) * float(scale_h)

            gain = float(score_alt) - float(score_cur)

            # Immediate exit/flip when current score turns negative (rule 1).
            if float(score_cur) < 0.0:
                if float(score_alt) > 0.0 and gain > float(mgn):
                    return (
                        f"FLIP_{alt_label}",
                        f"score_a:flip(cur={score_cur:.6f} alt={score_alt:.6f} gain={gain:.6f} mgn={mgn:.6f} "
                        f"t_cur={t_cur:.0f}s t_alt={t_alt:.0f}s)",
                    )
                return "EXIT", f"score_a:exit_negative(cur={score_cur:.6f} t_cur={t_cur:.0f}s)"

            # Opportunistic flip when opposite dominates (rule 2), with streak confirmation.
            if gain > float(mgn):
                flip_streak = int(pos.get("policy_flip_streak") or 0) + 1
                pos["policy_flip_streak"] = int(flip_streak)
                if flip_streak >= int(max(1, int(self.paper_exit_policy_flip_confirm_ticks))):
                    return (
                        f"FLIP_{alt_label}",
                        f"score_a:flip(cur={score_cur:.6f} alt={score_alt:.6f} gain={gain:.6f} mgn={mgn:.6f} "
                        f"t_cur={t_cur:.0f}s t_alt={t_alt:.0f}s)",
                    )
            else:
                pos["policy_flip_streak"] = 0

            return "HOLD", f"score_a:hold(cur={score_cur:.6f} alt={score_alt:.6f} gain={gain:.6f} mgn={mgn:.6f})"

        # If we can't compute Score_A (no detail/meta), do nothing.
        return "HOLD", "score_a:no_detail"

        meta = detail.get("meta") if isinstance(detail, dict) and isinstance(detail.get("meta"), dict) else {}
        mu_annual = meta.get("mu_adjusted")
        sigma_annual = None
        for k in ("sigma_annual", "policy_paths_sigma_annual", "sigma_sim"):
            if meta.get(k) is not None:
                sigma_annual = meta.get(k)
                break
        if mu_annual is None:
            mu_annual = pos.get("policy_mu_annual")
        if sigma_annual is None:
            sigma_annual = pos.get("policy_sigma_annual")
        try:
            mu_annual_f = float(mu_annual)
        except Exception:
            return "HOLD", "policy:no_mu"
        try:
            sigma_annual_f = float(sigma_annual)
        except Exception:
            return "HOLD", "policy:no_sigma"
        if sigma_annual_f <= 0:
            return "HOLD", "policy:bad_sigma"

        # convert annualized -> per-second (dt=1/SECONDS_PER_YEAR)
        mu_ps = float(mu_annual_f) / float(SECONDS_PER_YEAR)
        sigma_ps = float(sigma_annual_f) / math.sqrt(float(SECONDS_PER_YEAR))

        try:
            lev = float(pos.get("leverage") or 0.0)
        except Exception:
            lev = 0.0
        if lev <= 0:
            return "HOLD", "policy:bad_lev"

        try:
            fee_rt = float(pos.get("fee_roundtrip") or 0.0)
        except Exception:
            fee_rt = 0.0
        # `fee_roundtrip` is stored as a per-notional rate (paper PnL: fee = notional * fee_rt).
        # `_approx_p_pos_and_ev_hold` operates in ROE units, so scale costs by leverage.
        fee_exit_only_notional = max(0.0, 0.5 * float(fee_rt))
        fee_exit_only = float(fee_exit_only_notional) * float(lev)
        exec_oneway = float(fee_exit_only)
        switch_cost = float(max(0.0, 2.0 * float(exec_oneway)))

        # scores / probabilities (deterministic approximation)
        p_pos_cur, score_cur = _approx_p_pos_and_ev_hold(mu_ps, sigma_ps, tau, side_now, lev, fee_exit_only)
        p_pos_alt, score_alt_raw = _approx_p_pos_and_ev_hold(mu_ps, sigma_ps, tau, alt_side, lev, fee_exit_only)
        score_alt = float(score_alt_raw) - float(switch_cost)
        gap_eff = float(score_cur) - float(score_alt)

        mgn = float(max(0.0, float(self.paper_exit_policy_score_margin)))
        hold_value_ok = bool(gap_eff >= -mgn)
        hold_ok = bool(hold_value_ok and (float(p_pos_cur) >= float(self.paper_exit_policy_p_pos_hold_floor)))

        hold_bad = int(pos.get("policy_hold_bad") or 0)
        if (float(score_cur) < -mgn) or (not hold_ok):
            hold_bad += 1
        else:
            hold_bad = 0
        pos["policy_hold_bad"] = int(hold_bad)

        alt_value_after_cost = float(score_alt_raw) - float(exec_oneway)
        flip_ok = bool(
            (float(p_pos_alt) >= float(self.paper_exit_policy_p_pos_enter_floor))
            and ((alt_value_after_cost > 0.0) or (alt_value_after_cost > float(self.paper_exit_policy_soft_floor)))
        )
        pref_side = alt_side if (gap_eff < -mgn and flip_ok) else None

        flip_streak = int(pos.get("policy_flip_streak") or 0)
        if pref_side is not None and int(pref_side) == int(alt_side):
            flip_streak += 1
        else:
            flip_streak = 0
        pos["policy_flip_streak"] = int(flip_streak)

        # emit actions only after min_hold (Dynamic)
        dynamic_hold = int(pos.get("dynamic_min_hold") or 0)
        effective_min_hold = max(float(min_hold), float(dynamic_hold))
        
        if age_sec >= effective_min_hold:
            if flip_streak >= int(max(1, int(self.paper_exit_policy_flip_confirm_ticks))):
                return (
                    f"FLIP_{alt_label}",
                    f"policy:score_flip(gap={gap_eff:.6f} p_cur={p_pos_cur:.3f} p_alt={p_pos_alt:.3f} score_cur={score_cur:.6f} score_alt={score_alt_raw:.6f})",
                )
            if hold_bad >= int(max(1, int(self.paper_exit_policy_hold_bad_ticks))):
                return (
                    "EXIT",
                    f"policy:hold_bad(n={hold_bad} p_cur={p_pos_cur:.3f} score_cur={score_cur:.6f} gap={gap_eff:.6f})",
                )

        return "HOLD", f"policy:hold(p={p_pos_cur:.3f} gap={gap_eff:.6f} tau={tau:.0f}s)"

    async def _paper_trade_step(
        self,
        *,
        sym: str,
        desired_action: str,
        ts_ms: int,
        best_bid: Optional[float],
        best_ask: Optional[float],
        mark_price: Optional[float],
        detail: Optional[Dict[str, Any]],
        decision_reason: str,
    ) -> None:
        if not (self.paper_trading_enabled or self.enable_orders):
            return
        if sym is None:
            return
        # In live mode, require a fresh exchange sync before emitting any orders.
        if bool(getattr(self, "enable_orders", False)) and bool(getattr(self, "live_sync_enabled", False)):
            try:
                last_sync = int(getattr(self, "_last_live_sync_ms", 0) or 0)
            except Exception:
                last_sync = 0
            if last_sync <= 0 or (int(ts_ms) - int(last_sync)) > 10_000:
                return

        # Update symbol score from engine detail (RESTORED & ROBUST)
        consensus_score = float(self._symbol_scores.get(sym, 0.0))
        try:
            target_detail = detail
            if (not target_detail) or (not isinstance(target_detail, dict)):
                # Fallback: check decision cache for this symbol
                cached = self._decision_cache.get(sym) or {}
                cached_decision = cached.get("decision")
                if cached_decision and isinstance(cached_decision, dict):
                    target_detail = cached_decision

            if target_detail and isinstance(target_detail, dict):
                # Use the new discounted EV integral as the consensus score for ranking
                consensus_score = self._get_symbol_expected_value(sym, target_detail, use_optimal_horizon=True)

            self._symbol_scores[sym] = float(consensus_score)
            self._score_update_time[sym] = ts_ms

            # Track in history for covariance calculation
            if hasattr(self, '_score_history'):
                self._score_history[sym].append((ts_ms, float(consensus_score)))
        except Exception as e:
            if hasattr(self, '_log'):
                self._log(f"[WARN] Score extract {sym} failed: {e}")

        try:
            self._maybe_rebalance_portfolio(ts_ms, mark_price)
        except Exception as e:
            if hasattr(self, '_log'):
                self._log(f"[WARN] Rebalance attempt failed: {e}")

        # Update group/rank classifications (RESTORED)
        try:
            self._recalculate_groups(force=True)
        except Exception as e:
            pass

        # Continuous Opportunity Replacement (Score_A-based)
        try:
            if (not bool(getattr(self, "paper_economic_brain_enabled", False))) and hasattr(self, "_opportunity_checker"):
                await self._opportunity_checker.check_and_replace_if_better(sym, detail, ts_ms)
        except Exception:
            pass

        # mark existing position before applying signals
        self._paper_mark_position(sym, mark_price, ts_ms)
        
        # --- HARD STOP LOSS CHECK ---
        pos = self.positions.get(sym)
        live_mode = bool(getattr(self, "enable_orders", False)) and (not bool(getattr(self, "paper_trading_enabled", False)))
        # In live mode, prefer exchange-synced mark/current price for stop checks (not mainnet data feed).
        mark_for_stop = mark_price
        if live_mode and isinstance(pos, dict):
            try:
                v = pos.get("current")
                if v is None:
                    v = pos.get("price")
                if v is not None:
                    mark_for_stop = float(v)
            except Exception:
                pass
        if pos and mark_for_stop is not None:
            entry = float(pos.get("entry_price") or 0.0)
            side = str(pos.get("side") or "").upper()
            if entry > 0:
                # Price move (unlevered)
                price_chg = (float(mark_for_stop) / entry - 1.0) if side == "LONG" else (1.0 - float(mark_for_stop) / entry)
                price_hit = False
                if float(self.hard_stop_loss_price_frac) > 0:
                    price_hit = bool(price_chg <= -float(self.hard_stop_loss_price_frac))

                # ROE drawdown (levered, margin-based)
                roe_val = None
                try:
                    if pos.get("roe") is not None:
                        roe_val = float(pos.get("roe"))
                except Exception:
                    roe_val = None
                if roe_val is None:
                    # Best-effort: ROE ≈ price_chg * leverage (when margin/notional is consistent).
                    lev = None
                    try:
                        if pos.get("notional") is not None and float(pos.get("margin") or 0.0) > 0:
                            lev = float(pos.get("notional")) / float(pos.get("margin"))
                    except Exception:
                        lev = None
                    if lev is None:
                        try:
                            lev = float(pos.get("leverage") or 1.0)
                        except Exception:
                            lev = 1.0
                    roe_val = float(price_chg) * float(lev)
                roe_hit = False
                if float(self.hard_stop_loss_roe_frac) > 0:
                    roe_hit = bool(float(roe_val) <= -float(self.hard_stop_loss_roe_frac))
                
                # Debug log: throttled manually to avoid flood but ensure visibility
                last_debug = pos.get("_last_sl_debug_ts", 0)
                if (int(ts_ms) - int(last_debug)) > 5000: # Every 5 seconds per symbol
                    try:
                        self._log(
                            f"[DEBUG_SL] {sym} {side} | entry={entry:.6f} mark={float(mark_for_stop):.6f} "
                            f"prc={price_chg*100:.2f}% (limit={-self.hard_stop_loss_price_frac*100:.2f}%) "
                            f"roe={float(roe_val)*100:.2f}% (limit={-self.hard_stop_loss_roe_frac*100:.2f}%)"
                        )
                    except Exception:
                        pass
                    pos["_last_sl_debug_ts"] = int(ts_ms)

                is_hit = bool(price_hit or roe_hit)
                if is_hit:
                    trigger = "PRICE" if price_hit else "ROE"
                    # Live: force reduceOnly MARKET close (limit close can sit open and not protect).
                    if live_mode:
                        try:
                            if self._live_is_pending(sym, ts_ms):
                                return
                            self._live_mark_pending(sym, ts_ms)
                            close_side = "sell" if side == "LONG" else "buy"
                            try:
                                qty = abs(float(pos.get("size") or pos.get("quantity") or 0.0))
                            except Exception:
                                qty = 0.0
                            if qty > 0:
                                params = {"reduceOnly": True}
                                try:
                                    if pos.get("position_idx") is not None:
                                        params["positionIdx"] = int(pos.get("position_idx"))
                                except Exception:
                                    pass
                                self._schedule_live_order(sym, close_side, float(qty), price=None, leverage=None, params=params)
                                try:
                                    self._live_pending_exit_reason[str(sym)] = f"HARD_STOP_{trigger}"
                                except Exception:
                                    pass
                                self._log_err(
                                    f"[HARD_STOP] {sym} {side} trigger={trigger} prc={price_chg*100:.2f}% roe={float(roe_val)*100:.2f}% -> MARKET reduceOnly close"
                                )
                        except Exception as e:
                            self._log_err(f"[HARD_STOP_ERR] {sym}: {e}")
                        return

                    px_exit, exec_tag = self._paper_fill_price(
                        side=side,
                        leg="exit",
                        best_bid=best_bid,
                        best_ask=best_ask,
                        mark_price=mark_for_stop,
                        detail=detail,
                    )
                    await self._close_position(
                        sym=sym,
                        exit_price=float(px_exit) if px_exit is not None else float(mark_for_stop),
                        ts_ms=ts_ms,
                        reason=(
                            f"Hard Stop ({trigger}) hit "
                            f"prc={price_chg*100:.2f}% roe={float(roe_val)*100:.2f}% "
                            f"@ {float(mark_for_stop):.6f} (entry={entry:.6f})"
                        ),
                    )
                    return # Exit immediately

        pos = self.positions.get(sym)
        age_sec = float(pos.get("age_sec") or 0.0) if pos else 0.0
        if pos and self.paper_exit_policy_only:
            live_mode = bool(getattr(self, "enable_orders", False)) and (not bool(getattr(self, "paper_trading_enabled", False)))
            # LIVE에서는 exit-policy-only가 WAIT 신호를 영구적으로 무시하면 곤란합니다.
            # (예: 현재 신호는 WAIT인데 포지션이 계속 남아 큰 손실로 이어짐)
            try:
                act = str(desired_action or "WAIT").upper()
            except Exception:
                act = "WAIT"
            want_side = act if act in ("LONG", "SHORT") else None
            if live_mode and want_side is None and bool(self.paper_flat_on_wait) and (age_sec >= float(self.paper_min_hold_sec)):
                px_exit, exec_tag = self._paper_fill_price(
                    side=str(pos.get("side") or ""),
                    leg="exit",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_exit is not None:
                    await self._close_position(
                        sym=sym,
                        exit_price=float(px_exit),
                        ts_ms=ts_ms,
                        reason=f"EXIT_WAIT {decision_reason} | live_override_exit_policy_only | exec={exec_tag}",
                    )
                return
            action, pol_reason = self._paper_exit_policy_signal(
                sym=sym,
                pos=pos,
                ts_ms=ts_ms,
                best_bid=best_bid,
                best_ask=best_ask,
                mark_price=mark_price,
                detail=detail,
            )
            if action == "EXIT":
                px_exit, exec_tag = self._paper_fill_price(
                    side=str(pos.get("side") or ""),
                    leg="exit",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_exit is not None:
                    await self._close_position(
                        sym=sym,
                        exit_price=float(px_exit),
                        ts_ms=ts_ms,
                        reason=f"{pol_reason} | {decision_reason} | exec={exec_tag}",
                    )
                return
            if action in ("FLIP_LONG", "FLIP_SHORT"):
                new_side = "LONG" if action == "FLIP_LONG" else "SHORT"
                # close
                px_exit, exec_tag_exit = self._paper_fill_price(
                    side=str(pos.get("side") or ""),
                    leg="exit",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_exit is None:
                    return
                close_reason = f"{pol_reason} | {decision_reason} | exec={exec_tag_exit}"
                await self._close_position(sym=sym, exit_price=float(px_exit), ts_ms=ts_ms, reason=close_reason)

                # LIVE: queue the entry and wait for exchange sync to confirm the close.
                if live_mode:
                    cap_frac = float(pos.get("cap_frac") or self.paper_size_frac_default)
                    leverage_hint = float(pos.get("leverage") or self.paper_leverage_default)
                    if detail:
                        try:
                            lev_opt = detail.get("optimal_leverage")
                            if lev_opt is not None and float(lev_opt) > 0:
                                leverage_hint = float(lev_opt)
                        except Exception:
                            pass
                    self._queue_live_rotation(
                        from_sym=str(sym),
                        target_sym=str(sym),
                        target_side=str(new_side),
                        cap_frac=float(cap_frac),
                        leverage_hint=float(leverage_hint),
                        reason=str(close_reason),
                        ts_ms=int(ts_ms),
                    )
                    return
                # open
                px_entry, exec_tag_entry = self._paper_fill_price(
                    side=new_side,
                    leg="entry",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_entry is None:
                    return
                cap_frac = float(pos.get("cap_frac") or self.paper_size_frac_default)
                leverage = float(pos.get("leverage") or self.paper_leverage_default)
                # Apply engine-suggested leverage on flips as well (if provided).
                if detail:
                    try:
                        lev_opt = detail.get("optimal_leverage")
                        if lev_opt is not None and float(lev_opt) > 0:
                            leverage = float(lev_opt)
                    except Exception:
                        pass
                fee_roundtrip = float(pos.get("fee_roundtrip") or self.paper_fee_roundtrip)
                if fee_roundtrip <= 0.0 and detail:
                    meta = detail.get("meta") if isinstance(detail.get("meta"), dict) else {}
                    fee_from_meta = self._paper_fee_roundtrip_from_engine_meta(meta)
                    if fee_from_meta is not None:
                        fee_roundtrip = float(fee_from_meta)
                await self._open_position(
                    sym=sym,
                    side=new_side,
                    entry_price=float(px_entry),
                    ts_ms=ts_ms,
                    cap_frac=cap_frac,
                    leverage=leverage,
                    fee_roundtrip=fee_roundtrip,
                    reason=f"{pol_reason} | {decision_reason} | exec={exec_tag_entry}",
                )
                self._paper_init_exit_policy_state(sym, detail, ts_ms)
                return
            if isinstance(action, str) and action.startswith("SWITCH_"):
                # Format: SWITCH_{LONG|SHORT}|{target_symbol}
                try:
                    head, target_sym = action.split("|", 1)
                except ValueError:
                    return
                target_sym = str(target_sym or "").strip()
                if not target_sym or target_sym == sym:
                    return
                new_side = "LONG" if head == "SWITCH_LONG" else "SHORT"

                # close current
                px_exit, exec_tag_exit = self._paper_fill_price(
                    side=str(pos.get("side") or ""),
                    leg="exit",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_exit is None:
                    return
                close_reason = f"{pol_reason} | {decision_reason} | exec={exec_tag_exit}"
                await self._close_position(sym=sym, exit_price=float(px_exit), ts_ms=ts_ms, reason=close_reason)

                # LIVE: queue the switch entry and wait for exchange sync to confirm the close.
                if live_mode:
                    cap_frac = float(pos.get("cap_frac") or self.paper_size_frac_default)
                    leverage_hint = float(pos.get("leverage") or self.paper_leverage_default)
                    self._queue_live_rotation(
                        from_sym=str(sym),
                        target_sym=str(target_sym),
                        target_side=str(new_side),
                        cap_frac=float(cap_frac),
                        leverage_hint=float(leverage_hint),
                        reason=str(close_reason),
                        ts_ms=int(ts_ms),
                    )
                    return

                # Avoid duplicate symbol positions (dict is keyed by symbol)
                if target_sym in self.positions:
                    return

                # Use cached decision for the target symbol (already computed by decision worker)
                cached_t = self._decision_cache.get(target_sym) or {}
                decision_t = cached_t.get("decision")
                target_detail = None
                if isinstance(decision_t, dict):
                    details = decision_t.get("details", []) if isinstance(decision_t.get("details", []), list) else []
                    cand = [d for d in details if isinstance(d, dict)]
                    if cand:
                        target_detail = max(cand, key=lambda d: float(d.get("ev", 0.0) or 0.0))

                # Snapshot prices for target fills
                price_t, _closes_t, _candles_t, bid_t, ask_t, _spread_t = self._snapshot_inputs(target_sym)
                mark_t = self._mark_price(bid_t, ask_t, float(price_t) if price_t is not None else None)
                px_entry, exec_tag_entry = self._paper_fill_price(
                    side=new_side,
                    leg="entry",
                    best_bid=bid_t,
                    best_ask=ask_t,
                    mark_price=mark_t,
                    detail=target_detail,
                )
                if px_entry is None:
                    return

                # sizing: keep cap_frac, but allow engine-optimal leverage for the new symbol
                cap_frac = float(pos.get("cap_frac") or self.paper_size_frac_default)
                leverage = float(pos.get("leverage") or self.paper_leverage_default)
                if target_detail is not None:
                    try:
                        lev_opt = target_detail.get("optimal_leverage")
                        if lev_opt is not None and float(lev_opt) > 0:
                            leverage = float(lev_opt)
                    except Exception:
                        pass

                fee_roundtrip = float(pos.get("fee_roundtrip") or self.paper_fee_roundtrip)
                if fee_roundtrip <= 0.0 and target_detail is not None:
                    meta_t = target_detail.get("meta") if isinstance(target_detail.get("meta"), dict) else {}
                    fee_from_meta = self._paper_fee_roundtrip_from_engine_meta(meta_t)
                    if fee_from_meta is not None:
                        fee_roundtrip = float(fee_from_meta)

                await self._open_position(
                    sym=target_sym,
                    side=new_side,
                    entry_price=float(px_entry),
                    ts_ms=ts_ms,
                    cap_frac=cap_frac,
                    leverage=leverage,
                    fee_roundtrip=fee_roundtrip,
                    reason=f"{pol_reason} | {decision_reason} | exec={exec_tag_entry}",
                    detail=target_detail,
                )
                self._paper_init_exit_policy_state(target_sym, target_detail or {}, ts_ms)
                return
            # HOLD: ignore legacy WAIT->FLAT / max_hold / signal flips for open positions
            return
        max_hold_sec = None
        if pos is not None:
            try:
                max_hold_sec = float(pos.get("policy_horizon_sec") or self.paper_max_hold_sec)
            except Exception:
                max_hold_sec = float(self.paper_max_hold_sec)
        if pos and max_hold_sec and (float(max_hold_sec) > 0) and (age_sec >= float(max_hold_sec)):
            px_exit, exec_tag = self._paper_fill_price(
                side=str(pos.get("side") or ""),
                leg="exit",
                best_bid=best_bid,
                best_ask=best_ask,
                mark_price=mark_price,
                detail=detail,
            )
            if px_exit is not None:
                await self._close_position(
                    sym=sym,
                    exit_price=float(px_exit),
                    ts_ms=ts_ms,
                    reason=f"TIME_EXIT {decision_reason} | exec={exec_tag}",
                )
            return

        action = str(desired_action or "WAIT").upper()
        want_side = action if action in ("LONG", "SHORT") else None

        # default: WAIT -> flat
        if want_side is None:
            if pos and self.paper_flat_on_wait and (age_sec >= float(self.paper_min_hold_sec)):
                px_exit, exec_tag = self._paper_fill_price(
                    side=str(pos.get("side") or ""),
                    leg="exit",
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=detail,
                )
                if px_exit is not None:
                    await self._close_position(
                        sym=sym,
                        exit_price=float(px_exit),
                        ts_ms=ts_ms,
                        reason=f"EXIT_WAIT {decision_reason} | exec={exec_tag}",
                    )
            return

        # respect min hold on flips
        if pos and str(pos.get("side") or "").upper() != str(want_side).upper() and (age_sec < float(self.paper_min_hold_sec)):
            return

        # 🎯 Score-Based Portfolio Kelly Sizing - MOVED HERE to execute before cap_frac init
        # Calculate Kelly weights FIRST, then use as initial cap_frac values
        cap_frac_from_kelly = None
        leverage_from_kelly = None
        
        can_rebalance = (want_side in ("LONG", "SHORT")) or (pos is not None)
        if can_rebalance and not pos:  # Only for NEW positions
            try:
                info = self._group_info.get(sym, {})
                group = info.get("group", "OTHER")
                
                # Update symbol list for Kelly (current positions + current candidate)
                curr_syms = list(self.positions.keys())
                if sym not in curr_syms: curr_syms.append(sym)
                scores = [self._symbol_scores.get(s, 0.0) for s in curr_syms]
                
                kelly_weights = self._calculate_covariance_kelly(curr_syms, scores)
                my_weight = kelly_weights.get(sym, 0.05)
                
                # Target sizing by group
                if group == "TOP10":
                    target_cap_frac = float(my_weight)
                    target_leverage = float(self.leverage)
                else:
                    target_cap_frac = 0.01
                    target_leverage = 2.0
                
                group_cap = float(info.get("cap", 0.25 if group == "TOP10" else 0.05))
                cap_frac_calculated = max(0.02, min(target_cap_frac, group_cap))
                leverage_calculated = max(1.0, min(target_leverage, self.max_leverage))
                
                # Apply EMA smoothing
                alpha = 0.2
                prev_cap = self._cap_frac_ema.get(sym, cap_frac_calculated)
                cap_frac_from_kelly = alpha * cap_frac_calculated + (1.0 - alpha) * prev_cap
                self._cap_frac_ema[sym] = cap_frac_from_kelly
                leverage_from_kelly = leverage_calculated
                
                if hasattr(self, '_log'):
                    self._log(f"💰 [KELLY] {sym} | Group={group} Rank={info.get('rank', '?')} | cap_frac={cap_frac_from_kelly:.3f} lev={leverage_from_kelly:.1f}")
                    
            except Exception as e:
                if hasattr(self, '_log_err'):
                    self._log_err(f"[ERR] Kelly calc for {sym}: {e}")

        # Choose sizing: Use Kelly if calculated, otherwise defaults
        if cap_frac_from_kelly is not None:
            cap_frac = cap_frac_from_kelly
            leverage = leverage_from_kelly
        else:
            cap_frac = float(self.paper_size_frac_default)
            leverage = float(self.paper_leverage_default)
        
        fee_roundtrip = float(self.paper_fee_roundtrip)
        # Apply engine-suggested leverage even when engine sizing is disabled (keeps sizing toggle about cap_frac).
        if detail:
            try:
                lev_opt = detail.get("optimal_leverage")
                if lev_opt is not None and float(lev_opt) > 0:
                    leverage = float(lev_opt)
                    self._log(f"🔍 [PAPER_DEBUG] {sym} | Applied OPTIMAL_LEVERAGE from engine: {leverage}")
                else:
                    self._log(f"🔍 [PAPER_DEBUG] {sym} | No optimal leverage in detail, using default: {leverage}")
            except Exception:
                pass
        
        # OLD Kelly block removed - now calculated BEFORE cap_frac initialization (line ~1474)

        # Standard fee extraction
        if detail:
            meta = detail.get("meta") if isinstance(detail.get("meta"), dict) else {}
            if fee_roundtrip <= 0.0 and isinstance(meta, dict):
                try:
                    fee_from_meta = self._paper_fee_roundtrip_from_engine_meta(meta)
                    if fee_from_meta is not None:
                        fee_roundtrip = float(fee_from_meta)
                except Exception:
                    pass

        cap_frac = float(max(0.0, min(1.0, cap_frac)))
        leverage = float(max(0.0, min(float(leverage), float(self.max_leverage))))

        # exposure / position cap
        if not pos:
            if (self.paper_max_positions > 0) and (len(self.positions) >= int(self.paper_max_positions)):
                return
            try:
                max_expo = float(getattr(config, "MAX_NOTIONAL_EXPOSURE", 0.0) or 0.0)
            except Exception:
                max_expo = 0.0
            if self.exposure_cap_enabled and max_expo > 0 and self.balance > 0:
                new_notional = float(self.balance) * cap_frac * leverage
                if (self._total_open_notional() + new_notional) / max(1.0, float(self.balance)) > max_expo:
                    return

        # execute: close/flip/open
        if pos and str(pos.get("side") or "").upper() != want_side:
            px_exit, exec_tag = self._paper_fill_price(
                side=str(pos.get("side") or ""),
                leg="exit",
                best_bid=best_bid,
                best_ask=best_ask,
                mark_price=mark_price,
                detail=detail,
            )
            if px_exit is not None:
                await self._close_position(
                    sym=sym,
                    exit_price=float(px_exit),
                    ts_ms=ts_ms,
                    reason=f"FLIP_EXIT {decision_reason} | exec={exec_tag}",
                )
            pos = None

        # ✅ ONLY allow TOP10 to enter new positions
        if not pos:
            info = self._group_info.get(sym, {})
            group = info.get("group", "OTHER")
            if group != "TOP10":
                # Skip entry for non-TOP10 symbols
                return
        
        if not pos:
            px_entry, exec_tag = self._paper_fill_price(
                side=want_side,
                leg="entry",
                best_bid=best_bid,
                best_ask=best_ask,
                mark_price=mark_price,
                detail=detail,
            )
            if px_entry is None:
                return

            # If the discounted integral score for the chosen side is negative, do not enter.
            # (User expectation: 음수 점수/음수 적분이면 신규 진입 금지)
            try:
                if isinstance(detail, dict):
                    score_side, _t_star = self._get_symbol_score_a_for_side(
                        sym=sym,
                        detail=detail,
                        side=str(want_side),
                        is_current=False,
                        age_sec=0.0,
                    )
                    if float(score_side) <= 0.0:
                        return
            except Exception:
                pass
            
            await self._open_position(
                sym=sym,
                side=want_side,
                entry_price=float(px_entry),
                ts_ms=ts_ms,
                cap_frac=cap_frac,
                leverage=leverage,
                fee_roundtrip=fee_roundtrip,
                reason=f"{decision_reason} | exec={exec_tag}",
                detail=detail,
            )
            self._paper_init_exit_policy_state(sym, detail, ts_ms)
            return

        # mark after
        self._paper_mark_position(sym, mark_price, ts_ms)

    def _maybe_rebalance_portfolio(
        self,
        ts_ms: int,
        mark_price: Optional[float] = None,
    ) -> None:
        if not (self.paper_trading_enabled or self.enable_orders):
            return

        # Always refresh targets for dashboard display, even when execution is rate-limited.
        try:
            self._update_rebalance_targets(ts_ms)
        except Exception:
            pass

        if (ts_ms - self._last_rebalance_ts) < int(self.paper_rebalance_interval_ms):
            return
        if self._rebalance_in_progress:
            return

        symbols = list(self.positions.keys())
        if not symbols:
            self._rebalance_targets.clear()
            return

        self._last_rebalance_ts = ts_ms
        self._rebalance_in_progress = True
        try:
            targets: Dict[str, float] = {}
            if isinstance(self._rebalance_targets, dict):
                targets = {s: float(self._rebalance_targets.get(s, 0.0) or 0.0) for s in symbols}
            if not targets:
                scores = [self._symbol_scores.get(sym, 0.0) for sym in symbols]
                targets = self._calculate_covariance_kelly(symbols, scores)
            self._rebalance_targets = targets
            slip = float(max(0.0, self.paper_slippage_bps)) / 10000.0
            live_mode = bool(self.enable_orders) and (not bool(getattr(self, "paper_trading_enabled", False)))
            balance = max(1.0, float(self.balance))
            # In cross margin live mode, size/rebalance against total equity (wallet + uPnL) when available.
            if live_mode:
                try:
                    balance = max(1.0, float(self.risk.get_total_equity(float(balance))))
                except Exception:
                    balance = max(1.0, float(balance))
            for sym in symbols:
                pos = self.positions.get(sym)
                if not pos:
                    continue
                target_cap = float(targets.get(sym, 0.0) or 0.0)
                curr_cap = float(pos.get("cap_frac") or 0.0)
                diff = target_cap - curr_cap
                if abs(diff) < float(self.paper_rebalance_min_cap_diff):
                    continue

                lev = float(pos.get("leverage") or self.leverage)
                target_margin = balance * target_cap
                target_notional = target_margin * lev
                curr_notional = float(pos.get("notional") or (float(pos.get("margin") or 0.0) * lev))
                delta_notional = target_notional - curr_notional
                min_notional = abs(balance) * lev * float(self.paper_rebalance_min_notional_frac)
                if abs(delta_notional) < min_notional:
                    continue

                fee_rt = float(pos.get("fee_roundtrip") or self.paper_fee_roundtrip)
                cost = abs(delta_notional) * (fee_rt + slip)
                score = float(self._symbol_scores.get(sym, 0.0) or 0.0)
                score_pos = max(0.0, score)
                expected_gain = abs(delta_notional) * score
                # Never *increase* exposure on a non-positive score.
                if delta_notional > 0 and score_pos <= 0.0:
                    continue
                expected_gain = abs(delta_notional) * score_pos
                if expected_gain < cost * float(self.paper_rebalance_fee_mult):
                    continue

                price = float(pos.get("current") or mark_price or pos.get("entry_price") or 0.0)
                if price <= 0.0:
                    continue

                cap_frac = max(0.0, target_cap)
                if live_mode:
                    # Live: place delta orders only; do not mutate local position sizing.
                    if self._live_is_pending(sym, ts_ms):
                        continue
                    # Emergency margin guard: if margin ratio is too high, block increases and deleverage elsewhere.
                    try:
                        if hasattr(self, "risk") and self.risk.maybe_trigger_margin_guard(int(ts_ms)):
                            continue
                    except Exception:
                        pass
                    # Total leverage guard (max 7x by default): block increases and deleverage if exceeded.
                    try:
                        if hasattr(self, "risk") and self.risk.maybe_trigger_total_leverage_guard(int(ts_ms)):
                            continue
                    except Exception:
                        pass
                    # Enforce global margin budget in live mode (prevents "ab not enough for new order").
                    if delta_notional > 0:
                        try:
                            max_m = float(self.live_max_margin_frac)
                        except Exception:
                            max_m = 0.95
                        max_m = float(max(0.0, min(1.0, max_m)))
                        try:
                            used_m = float(self._live_margin_used(ts_ms=int(ts_ms)))
                        except Exception:
                            used_m = 0.0
                        allowed_m = float(balance) * float(max_m)
                        remaining_m = float(allowed_m) - float(used_m)
                        if remaining_m <= 0.0:
                            continue
                        if lev > 0:
                            delta_margin = float(delta_notional) / float(lev)
                            if delta_margin > remaining_m:
                                delta_notional = float(remaining_m) * float(lev)
                                # Re-check minimum notional after scaling.
                                if abs(delta_notional) < min_notional:
                                    continue
                    # Recompute qty after possible scaling.
                    delta_qty = abs(delta_notional) / price if price > 0 else 0.0
                    if delta_qty <= 0.0:
                        continue

                    pos_side = str(pos.get("side") or "").upper()
                    if pos_side == "SHORT":
                        order_side = "sell" if delta_notional > 0 else "buy"
                    else:
                        order_side = "buy" if delta_notional > 0 else "sell"

                    params = {"reduceOnly": delta_notional < 0}
                    if params.get("reduceOnly"):
                        try:
                            curr_qty = abs(float(pos.get("size", pos.get("quantity", 0.0)) or 0.0))
                        except Exception:
                            curr_qty = 0.0
                        if curr_qty <= 0.0:
                            continue
                        delta_qty = min(float(delta_qty), float(curr_qty))
                        if delta_qty <= 0.0:
                            continue

                    self._live_mark_pending(sym, ts_ms)
                    self._schedule_live_order(sym, order_side, float(delta_qty), price=price, leverage=float(lev), params=params)
                    if delta_notional > 0:
                        try:
                            self._reserve_live_margin(sym, float(delta_notional) / float(max(1e-9, lev)), int(ts_ms))
                        except Exception:
                            pass
                        try:
                            self._reserve_live_notional(sym, float(delta_notional), int(ts_ms))
                        except Exception:
                            pass

                    self._paper_append_trade(
                        {
                            "time": int(ts_ms),
                            "sym": sym,
                            "type": "REBALANCE",
                            "side": pos_side,
                            "price": float(price),
                            "cap_frac": float(cap_frac),
                            "notional": float(target_notional),
                            "delta_notional": float(delta_notional),
                            "reason": "kelly rebalance",
                            "note": "live_order",
                        }
                    )

                    if hasattr(self, "_log"):
                        self._log(f"[REBALANCE-COST] {sym} estimated cost={cost:.2f}")
                        self._log(
                            f"[REBALANCE] {sym} cap {curr_cap:.3f}->{cap_frac:.3f} "
                            f"∆notional={delta_notional:.0f} cost={cost:.2f}"
                        )
                    continue

                pos["cap_frac"] = cap_frac
                pos["margin"] = target_margin
                pos["notional"] = target_notional
                entry_price = float(pos.get("entry_price") or price)
                size = float(target_notional / entry_price) if entry_price > 0 else 0.0
                pos["size"] = size
                pos["quantity"] = size

                trade_record = {
                    "time": int(ts_ms),
                    "sym": sym,
                    "type": "REBALANCE",
                    "side": pos.get("side"),
                    "price": price,
                    "cap_frac": cap_frac,
                    "notional": target_notional,
                    "delta_notional": delta_notional,
                    "reason": "kelly rebalance"
                }
                self._paper_append_trade(trade_record)

                if self.enable_orders:
                    delta_qty = abs(delta_notional) / price if price > 0 else 0.0
                    if delta_qty > 0.0:
                        pos_side = str(pos.get("side") or "").upper()
                        if pos_side == "SHORT":
                            order_side = "sell" if delta_notional > 0 else "buy"
                        else:
                            order_side = "buy" if delta_notional > 0 else "sell"
                        params = {"reduceOnly": delta_notional < 0}
                        self._schedule_live_order(sym, order_side, delta_qty, price=price, leverage=float(lev), params=params)

                # We track the hypothetical cost but do not debit balance because no fills are executed here.
                if hasattr(self, '_log'):
                    self._log(f"[REBALANCE-COST] {sym} estimated cost={cost:.2f}")
                if hasattr(self, '_log'):
                    self._log(
                        f"[REBALANCE] {sym} cap {curr_cap:.3f}->{cap_frac:.3f} "
                        f"∆notional={delta_notional:.0f} cost={cost:.2f}"
                    )
        finally:
            self._rebalance_in_progress = False

    def _update_rebalance_targets(self, ts_ms: int) -> None:
        if not (self.paper_trading_enabled or self.enable_orders):
            return

        try:
            interval_ms = int(getattr(self, "rebalance_targets_interval_ms", 0) or 0)
        except Exception:
            interval_ms = 0

        try:
            last_ts = int(getattr(self, "_last_rebalance_targets_ts", 0) or 0)
        except Exception:
            last_ts = 0

        if interval_ms > 0 and (int(ts_ms) - int(last_ts)) < int(interval_ms):
            return

        symbols = list(self.positions.keys())
        if not symbols:
            self._rebalance_targets.clear()
            self._last_rebalance_targets_ts = int(ts_ms)
            return

        scores = [self._symbol_scores.get(sym, 0.0) for sym in symbols]
        new_targets = self._calculate_covariance_kelly(symbols, scores)
        
        # Apply EMA to rebalance targets
        alpha = float(getattr(self, "rebalance_target_ema_alpha", 0.2))
        for sym in symbols:
            old_ema = float(self._rebalance_targets.get(sym, 0.0) or 0.0)
            new_val = float(new_targets.get(sym, 0.0) or 0.0)
            self._rebalance_targets[sym] = (alpha * new_val) + ((1.0 - alpha) * old_ema)
            
        self._last_rebalance_targets_ts = int(ts_ms)

    # -----------------------------
    # logging / retry helpers
    # -----------------------------
    def _log(self, text: str) -> None:
        ts = time.strftime("%H:%M:%S")
        self.logs.append({"time": ts, "level": "INFO", "msg": str(text)})
        if config.LOG_STDOUT:
            print(text)

    def _log_err(self, text: str) -> None:
        ts = time.strftime("%H:%M:%S")
        self.logs.append({"time": ts, "level": "ERROR", "msg": str(text)})
        if config.LOG_STDOUT:
            print(text)

    async def _ccxt_call(self, label: str, fn, *args, **kwargs):
        timeout_sec = float(getattr(config, "CCXT_TIMEOUT_MS", 0) or 0) / 1000.0
        retry_keys = (
            "TimeoutError",
            "RequestTimeout",
            "DDoSProtection",
            "ExchangeNotAvailable",
            "NetworkError",
            "ETIMEDOUT",
            "ECONNRESET",
            "502",
            "503",
            "504",
        )
        for attempt in range(1, int(config.MAX_RETRY) + 1):
            try:
                async with self._net_sem:
                    coro = fn(*args, **kwargs)
                    if timeout_sec > 0:
                        return await asyncio.wait_for(coro, timeout=timeout_sec)
                    return await coro
            except Exception as e:
                exc_name = type(e).__name__
                msg = str(e) or exc_name
                is_retryable = isinstance(e, asyncio.TimeoutError) or any(k in msg for k in retry_keys) or any(
                    k in exc_name for k in retry_keys
                )
                if (attempt >= int(config.MAX_RETRY)) or (not is_retryable):
                    raise
                backoff = (float(config.RETRY_BASE_SEC) * (2 ** (attempt - 1))) + random.uniform(0, 0.25)
                self._log_err(f"[WARN] {label} retry {attempt}/{config.MAX_RETRY} err={msg} sleep={backoff:.2f}s")
                await asyncio.sleep(backoff)

    # -----------------------------
    # persistence (best-effort)
    # -----------------------------
    def _load_json(self, path: Path, default):
        try:
            if path.exists():
                with path.open("r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception as e:
            self._log_err(f"[ERR] load {path.name}: {e}")
        return default

    def _load_persisted_state(self) -> None:
        """Load paper state resume data (RESTORED)."""
        try:
            # Load balance
            val = self._load_json(self.state_files["balance"], None)
            if val is not None:
                self.balance = float(val)
                self._log(f"✅ [STATE_LOAD] Balance: ${self.balance:.2f}")

            # Load positions
            pos_data = self._load_json(self.state_files["positions"], {})
            if isinstance(pos_data, dict) and pos_data:
                for sym, p in pos_data.items():
                    try:
                        ts = int(p.get("time") or 0)
                        now = now_ms()
                        p["age_sec"] = max(0.0, (now - ts) / 1000.0)
                        p["mark_price"] = p.get("price", 0.0)
                    except Exception:
                        pass
                self.positions.update(pos_data)
                self._log(f"✅ [STATE_LOAD] Positions: {len(self.positions)} restored")

            # Load trade tape
            tape = self._load_json(self.state_files["trade"], [])
            if isinstance(tape, list):
                self.trade_tape.extend(tape)
                self._log(f"✅ [STATE_LOAD] Trades: {len(self.trade_tape)} restored")
            
            # Load equity history
            equity_data = self._load_json(self.state_files["equity"], None)
            if equity_data is not None:
                if isinstance(equity_data, list) and len(equity_data) > 0:
                    # Clear current history and load saved data
                    self._equity_history.clear()
                    for item in equity_data:
                        if isinstance(item, dict):
                            # New format: {"time": ts, "equity": value}
                            self._equity_history.append(item)
                        elif isinstance(item, (int, float)):
                            # Old format: just equity values - skip for now  
                            pass
                    if len(self._equity_history) > 0:
                        self._log(f"✅ [STATE_LOAD] Equity History: {len(self._equity_history)} data points restored")
                    else:
                        # Start with initial balance if no valid history
                        self._equity_history.append({"time": int(now_ms()), "equity": float(self.balance)})
                else:
                    # Start with initial balance if no history
                    self._equity_history.append({"time": int(now_ms()), "equity": float(self.balance)})
            else:
                # Initialize equity history if file doesn't exist
                self._equity_history.append({"time": int(now_ms()), "equity": float(self.balance)})

            self._paper_state_loaded = True
        except Exception as e:
            self._log(f"⚠️ [STATE_LOAD_ERR] {e}")

    def _persist_state(self, force: bool = False) -> None:
        # Persisted state is for paper simulation resume only.
        if not bool(getattr(self, "paper_trading_enabled", False)):
            return
        ts = now_ms()
        if not force and (ts - self._last_state_persist_ms < 5_000):
            return
        self._last_state_persist_ms = ts
        # NOTE: Persist should not mutate live positions.
        try:
            self.state_files["balance"].write_text(str(self.balance), encoding="utf-8")
            self.state_files["positions"].write_text(json.dumps(self.positions), encoding="utf-8")
            self.state_files["trade"].write_text(json.dumps(list(self.trade_tape)), encoding="utf-8")
        except Exception:
            pass

    def set_enable_orders(self, enabled: bool) -> None:
        enabled = bool(enabled)
        if bool(self.enable_orders) == enabled:
            return
        # When switching modes at runtime, keep paper vs live state strictly separated
        # (positions/balance + trade tape + equity curve), so the dashboard doesn't
        # mix "our records" with exchange-synced live state.
        if enabled:
            # PAPER -> LIVE
            try:
                if bool(getattr(self, "paper_trading_enabled", False)):
                    self._persist_state(force=True)
            except Exception:
                pass
            try:
                self._paper_balance = float(self.balance)
            except Exception:
                pass

            self.enable_orders = True
            self.paper_trading_enabled = False
            self._record_mode = "live"

            # Switch active namespaces
            self.positions = self._live_positions
            self._pos_meta = self._live_pos_meta
            self.trade_tape = self._live_trade_tape
            self._equity_history = self._live_equity_history

            # Force a fresh exchange sync before any orders can be emitted.
            self._last_live_sync_ms = 0
            self._last_live_sync_err = None
            try:
                self._live_pos_open_time_ms.clear()
            except Exception:
                pass
            try:
                self._live_pending_entry_reason.clear()
                self._live_pending_exit_reason.clear()
            except Exception:
                pass
            self.positions.clear()
            self._pos_meta.clear()
            self._rebalance_targets.clear()
            self._cap_frac_ema.clear()

            # Start with last known wallet/equity if available; otherwise 0 until sync.
            if self._live_wallet_balance is not None:
                self.balance = float(self._live_wallet_balance)
            elif self._live_equity is not None:
                self.balance = float(self._live_equity)
            else:
                self.balance = float(self._live_balance)

            self._log("[MODE] Live orders ENABLED; switched dashboard namespace to LIVE (paper state preserved).")
        else:
            # LIVE -> PAPER
            try:
                self._live_balance = float(self.balance)
            except Exception:
                pass

            self.enable_orders = False
            self.paper_trading_enabled = True
            self._record_mode = "paper"

            # Switch active namespaces back to paper
            self.balance = float(self._paper_balance)
            self.positions = self._paper_positions
            self._pos_meta = self._paper_pos_meta
            self.trade_tape = self._paper_trade_tape
            self._equity_history = self._paper_equity_history
            try:
                self._live_pos_open_time_ms.clear()
            except Exception:
                pass
            try:
                self._live_pending_entry_reason.clear()
                self._live_pending_exit_reason.clear()
            except Exception:
                pass

            # If we started in live mode, paper resume files were never loaded.
            if not bool(getattr(self, "_paper_state_loaded", False)):
                try:
                    self._load_persisted_state()
                except Exception:
                    pass

            self._log("[MODE] Live orders DISABLED; switched dashboard namespace to PAPER.")

    # -----------------------------
    # market feature helpers
    # -----------------------------
    def _compute_returns_and_vol(self, prices, *, bar_seconds: float = 60.0):
        """
        Estimate (mu, sigma) from close prices and annualize to match MC units.

        Returns:
            (mu_annual, sigma_annual) in log-return drift/vol per-year.
        """
        if prices is None or len(prices) < 10:
            return None, None
        log_returns = []
        for i in range(1, len(prices)):
            p0, p1 = prices[i - 1], prices[i]
            if p0 and p1 and p0 > 0 and p1 > 0:
                log_returns.append(math.log(p1 / p0))
        if len(log_returns) < 5:
            return None, None
        mu_bar = sum(log_returns) / len(log_returns)
        var_bar = sum((r - mu_bar) ** 2 for r in log_returns) / len(log_returns)
        sigma_bar = math.sqrt(float(max(0.0, var_bar)))

        try:
            bs = float(bar_seconds)
        except Exception:
            bs = 60.0
        if not math.isfinite(bs) or bs <= 0:
            bs = 60.0
        bars_per_year = float(SECONDS_PER_YEAR) / float(bs)
        mu_annual = float(mu_bar) * float(bars_per_year)
        sigma_annual = float(sigma_bar) * math.sqrt(float(bars_per_year))
        return float(mu_annual), float(max(sigma_annual, 1e-9))

    def _infer_regime(self, closes) -> str:
        if not closes or len(closes) < 30:
            return "chop"
        fast_period = min(80, len(closes))
        slow_period = min(200, len(closes))
        fast = sum(closes[-fast_period:]) / fast_period
        slow = sum(closes[-slow_period:]) / slow_period
        slope_short = closes[-1] - closes[max(0, len(closes) - 6)]
        slope_long = closes[-1] - closes[max(0, len(closes) - 40)]
        rets = [math.log(closes[i] / closes[i - 1]) for i in range(1, min(len(closes), 180))]
        vol = float(np.std(rets)) if rets else 0.0
        if vol > 0.01 and abs(slope_short) < closes[-1] * 0.0015:
            return "volatile"
        if fast > slow and slope_long > 0 and slope_short > 0:
            return "bull"
        if fast < slow and slope_long < 0 and slope_short < 0:
            return "bear"
        return "chop"

    def _compute_ofi_score(self, sym: str) -> float:
        ob = self.orderbook.get(sym) or {}
        bids = ob.get("bids") or []
        asks = ob.get("asks") or []
        weights = [1.0, 0.8, 0.6, 0.4, 0.2]
        bid_vol = sum(float(b[1]) * weights[i] for i, b in enumerate(bids[: len(weights)]) if len(b) >= 2)
        ask_vol = sum(float(a[1]) * weights[i] for i, a in enumerate(asks[: len(weights)]) if len(a) >= 2)
        denom = bid_vol + ask_vol
        if denom <= 0:
            return 0.0
        return float((bid_vol - ask_vol) / denom)

    def _liquidity_score(self, sym: str) -> float:
        ob = self.orderbook.get(sym) or {}
        bids = ob.get("bids") or []
        asks = ob.get("asks") or []
        vol = sum(float(b[1]) for b in bids[:5] if len(b) >= 2) + sum(float(a[1]) for a in asks[:5] if len(a) >= 2)
        return float(max(vol, 1.0))

    # -----------------------------
    # dashboard rows
    # -----------------------------
    def _extract_mc_meta(self, decision: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        if not decision:
            return {}
        for d in decision.get("details", []) or []:
            if d.get("_engine") in ("mc_barrier", "mc_engine", "mc"):
                return d.get("meta", {}) or {}
        return decision.get("meta", {}) or {}

    def _row(self, sym: str, price: Any, ts: int, decision: Optional[Dict[str, Any]], candles: int, ctx: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        status = "WAIT"
        conf = 0.0
        reason = "-"

        meta = decision.get("meta", {}) if decision else {}
        mc_meta = self._extract_mc_meta(decision)
        mc_detail = None
        if decision:
            try:
                for d in decision.get("details", []) or []:
                    if d.get("_engine") in ("mc_barrier", "mc_engine", "mc"):
                        mc_detail = d
                        break
            except Exception:
                mc_detail = None

        if decision:
            status = str(decision.get("action", "WAIT"))
            conf = _safe_float(decision.get("confidence", 0.0), 0.0)
            reason = str(decision.get("reason", "")) or "-"

        market_ts = (self.market.get(sym) or {}).get("ts") or 0
        trade_age = ts - int(market_ts) if market_ts else None
        kline_age = ts - int((self._last_kline_ok_ms.get(sym) or 0)) if self._last_kline_ok_ms.get(sym) else None

        ob_ts = (self.orderbook.get(sym) or {}).get("ts") or 0
        ob_age = ts - int(ob_ts) if ob_ts else None
        ob_ready = bool((self.orderbook.get(sym) or {}).get("ready"))
        ev = _safe_float(decision.get("ev", mc_meta.get("ev", meta.get("ev", 0.0))) if decision else 0.0, 0.0)
        ev_raw = _safe_float(decision.get("ev_raw", mc_meta.get("ev_raw", meta.get("ev_raw", 0.0))) if decision else 0.0, 0.0)
        kelly = _safe_float(mc_meta.get("kelly", meta.get("kelly", 0.0)), 0.0)
        regime = (ctx or {}).get("regime") or meta.get("regime") or "-"

        def _opt_float(val):
            if val is None:
                return None
            try:
                return float(val)
            except Exception:
                return None

        # MC event diagnostics
        event_p_tp = _opt_float(mc_meta.get("event_p_tp", meta.get("event_p_tp")))
        event_p_timeout = _opt_float(mc_meta.get("event_p_timeout", meta.get("event_p_timeout")))
        event_t_median = _opt_float(mc_meta.get("event_t_median", meta.get("event_t_median")))
        event_ev_r = _opt_float(mc_meta.get("event_ev_r", meta.get("event_ev_r")))
        event_cvar_r = _opt_float(mc_meta.get("event_cvar_r", meta.get("event_cvar_r")))

        mc_win_rate = _opt_float(mc_meta.get("win_rate"))
        mc_cvar = _opt_float(mc_meta.get("cvar05"))

        funnel_reason = mc_meta.get("funnel_reason") or meta.get("funnel_reason")

        # mu_alpha diagnostics (direct fields for dashboard)
        mu_alpha = _opt_float(mc_meta.get("mu_alpha"))
        mu_alpha_raw = _opt_float(mc_meta.get("mu_alpha_raw"))
        mu_alpha_pmaker_fill_rate = _opt_float(mc_meta.get("mu_alpha_pmaker_fill_rate"))
        mu_alpha_pmaker_boost = _opt_float(mc_meta.get("mu_alpha_pmaker_boost"))

        pos = self.positions.get(sym) or {}
        pos_roe = _opt_float(pos.get("roe")) or 0.0
        pos_leverage = _opt_float(pos.get("leverage"))
        pos_cap_frac = _opt_float(pos.get("cap_frac"))
        pos_pnl = _opt_float(pos.get("unrealized_pnl"))
        action_type = self._last_trade_event_by_sym.get(sym, "-")

        # Diff 2/3/4/5/6/7 payload keys (mostly forwarded from mc_meta)
        policy_horizons = mc_meta.get("policy_horizons")
        policy_w_h = mc_meta.get("policy_w_h")
        policy_h_eff_sec = _opt_float(mc_meta.get("policy_h_eff_sec"))
        policy_ev_mix_long = _opt_float(mc_meta.get("policy_ev_mix_long"))
        policy_ev_mix_short = _opt_float(mc_meta.get("policy_ev_mix_short"))
        paths_reused = mc_meta.get("paths_reused")
        policy_ev_target = _opt_float(mc_meta.get("policy_ev_target"))
        policy_ev_bonus = _opt_float(mc_meta.get("policy_ev_bonus"))
        policy_ev_penalty = _opt_float(mc_meta.get("policy_ev_penalty"))
        policy_ev_adjust = _opt_float(mc_meta.get("policy_ev_adjust"))
        policy_ev_score_long = _opt_float(mc_meta.get("policy_ev_score_long"))
        policy_ev_score_short = _opt_float(mc_meta.get("policy_ev_score_short"))
        policy_best_ev_gap = _opt_float(mc_meta.get("policy_best_ev_gap"))
        policy_ev_gap = _opt_float(mc_meta.get("policy_ev_gap"))
        policy_ev_neighbor_veto_abs = _opt_float(mc_meta.get("policy_ev_neighbor_veto_abs"))

        policy_signal_strength = _opt_float(mc_meta.get("policy_signal_strength"))
        policy_h_eff_sec_prior = _opt_float(mc_meta.get("policy_h_eff_sec_prior"))
        policy_w_short_sum = _opt_float(mc_meta.get("policy_w_short_sum"))

        policy_exit_reason_counts_per_h_long = mc_meta.get("policy_exit_reason_counts_per_h_long")
        policy_exit_reason_counts_per_h_short = mc_meta.get("policy_exit_reason_counts_per_h_short")
        policy_exit_unrealized_dd_frac = _opt_float(mc_meta.get("policy_exit_unrealized_dd_frac"))
        policy_exit_hold_bad_frac = _opt_float(mc_meta.get("policy_exit_hold_bad_frac"))
        policy_exit_score_flip_frac = _opt_float(mc_meta.get("policy_exit_score_flip_frac"))

        exec_mode = str(os.environ.get("EXEC_MODE", config.EXEC_MODE)).strip().lower()
        pmaker_entry = _opt_float(mc_meta.get("pmaker_entry"))
        pmaker_entry_delay_sec = _opt_float(mc_meta.get("pmaker_entry_delay_sec"))
        pmaker_entry_delay_penalty_r = _opt_float(mc_meta.get("pmaker_entry_delay_penalty_r"))
        policy_entry_shift_steps = mc_meta.get("policy_entry_shift_steps")

        fee_roundtrip_fee_mix = _opt_float(mc_meta.get("fee_roundtrip_fee_mix"))
        fee_roundtrip_fee_taker = _opt_float(mc_meta.get("fee_roundtrip_fee_taker"))
        fee_roundtrip_fee_maker = _opt_float(mc_meta.get("fee_roundtrip_fee_maker"))
        execution_cost = _opt_float(mc_meta.get("execution_cost"))
        expected_spread_cost = _opt_float(mc_meta.get("expected_spread_cost"))
        slippage_dyn = _opt_float(mc_meta.get("slippage_dyn"))
        spread_pct_used = _opt_float(mc_meta.get("spread_pct"))

        optimal_leverage = _opt_float((mc_detail or {}).get("optimal_leverage"))

        return {
            "symbol": sym,
            "price": price,
            "status": status,
            "action_type": action_type,
            "conf": conf,
            "mc": reason,
            "ev": ev,
            "ev_raw": ev_raw,
            "mc_win_rate": mc_win_rate,
            "mc_cvar": mc_cvar,
            "kelly": kelly,
            "optimal_leverage": optimal_leverage,
            "optimal_horizon_sec": self._symbol_t_star.get(sym, 0.0),  # Add T* to market data
            "regime": regime,
            "candles": candles,
            "pos_roe": pos_roe,
            "pos_leverage": pos_leverage,
            "pos_cap_frac": pos_cap_frac,
            "pos_pnl": pos_pnl,
            "event_p_tp": event_p_tp,
            "event_p_timeout": event_p_timeout,
            "event_t_median": event_t_median,
            "event_ev_r": event_ev_r,
            "event_cvar_r": event_cvar_r,
            "funnel_reason": funnel_reason,
            "mu_alpha": mu_alpha,
            "mu_alpha_raw": mu_alpha_raw,
            "mu_alpha_pmaker_fill_rate": mu_alpha_pmaker_fill_rate,
            "mu_alpha_pmaker_boost": mu_alpha_pmaker_boost,
            
            # Group/Rank (RESTORED For Dashboard)
            "group": self._group_info.get(sym, {}).get("group", "OTHER"),
            "rank": self._group_info.get(sym, {}).get("rank"),

            # freshness
            "trade_age": trade_age,
            "kline_age": kline_age,
            "orderbook_age": ob_age,
            "orderbook_ready": ob_ready,

            # Diff 2: Multi-Horizon Policy Mix
            "policy_horizons": policy_horizons,
            "policy_w_h": policy_w_h,
            "policy_h_eff_sec": policy_h_eff_sec,
            "policy_ev_mix_long": policy_ev_mix_long,
            "policy_ev_mix_short": policy_ev_mix_short,
            "paths_reused": paths_reused,
            "policy_ev_target": policy_ev_target,
            "policy_ev_bonus": policy_ev_bonus,
            "policy_ev_penalty": policy_ev_penalty,
            "policy_ev_adjust": policy_ev_adjust,
            "policy_ev_score_long": policy_ev_score_long,
            "policy_ev_score_short": policy_ev_score_short,
            "policy_best_ev_gap": policy_best_ev_gap,
            "policy_ev_gap": policy_ev_gap,
            "policy_ev_neighbor_veto_abs": policy_ev_neighbor_veto_abs,

            # Diff 3: Rule-based Dynamic Weights
            "policy_signal_strength": policy_signal_strength,
            "policy_h_eff_sec_prior": policy_h_eff_sec_prior,
            "policy_w_short_sum": policy_w_short_sum,

            # Diff 4: Exit Reason 통계
            "policy_exit_reason_counts_per_h_long": policy_exit_reason_counts_per_h_long,
            "policy_exit_reason_counts_per_h_short": policy_exit_reason_counts_per_h_short,
            "policy_exit_unrealized_dd_frac": policy_exit_unrealized_dd_frac,
            "policy_exit_hold_bad_frac": policy_exit_hold_bad_frac,
            "policy_exit_score_flip_frac": policy_exit_score_flip_frac,

            # Diff 5: Maker → Market 혼합 실행
            "exec_mode": exec_mode,
            "pmaker_entry": pmaker_entry,
            "fee_roundtrip_fee_mix": fee_roundtrip_fee_mix,
            "fee_roundtrip_fee_taker": fee_roundtrip_fee_taker,
            "fee_roundtrip_fee_maker": fee_roundtrip_fee_maker,
            "execution_cost": execution_cost,
            "expected_spread_cost": expected_spread_cost,
            "slippage_dyn": slippage_dyn,
            "spread_pct_used": spread_pct_used,
            "p_maker": pmaker_entry,

            # Diff 6: Maker fill delay (if present)
            "pmaker_entry_delay_sec": pmaker_entry_delay_sec,

            # Diff 7: delay penalty + horizon shift
            "pmaker_entry_delay_penalty_r": pmaker_entry_delay_penalty_r,
            "policy_entry_shift_steps": policy_entry_shift_steps,

            # extra
            "pmaker": self.pmaker.status_dict() if getattr(self, "pmaker", None) is not None else None,
            "details": (decision.get("details", []) if (decision and bool(getattr(config, "DASHBOARD_INCLUDE_DETAILS", False))) else []),
        }

    def _snapshot_inputs(
        self, sym: str
    ) -> tuple[Any, list[float], int, Optional[float], Optional[float], Optional[float]]:
        mkt = self.market.get(sym) or {}
        price = mkt.get("price")
        closes = list(self.ohlcv_buffer.get(sym) or [])
        candles = len(closes)

        best_bid = None
        best_ask = None
        try:
            if mkt.get("bid") is not None:
                best_bid = float(mkt.get("bid"))
        except Exception:
            best_bid = None
        try:
            if mkt.get("ask") is not None:
                best_ask = float(mkt.get("ask"))
        except Exception:
            best_ask = None

        ob = self.orderbook.get(sym) or {}
        bids = ob.get("bids") or []
        asks = ob.get("asks") or []
        if bids and asks:
            try:
                ob_bid = float(bids[0][0])
                ob_ask = float(asks[0][0])

                ref = None
                try:
                    if price is not None:
                        ref = float(price)
                    elif best_bid is not None and best_ask is not None:
                        ref = 0.5 * (float(best_bid) + float(best_ask))
                except Exception:
                    ref = None

                ok = True
                if ob_bid <= 0 or ob_ask <= 0 or ob_ask < ob_bid:
                    ok = False
                if ok and ref is not None and ref > 0:
                    # Orderbook sanity: reject wildly off quotes (prevents bad fills when API returns broken bids/asks).
                    lo = float(ref) * 0.5
                    hi = float(ref) * 1.5
                    if not (lo <= ob_bid <= hi and lo <= ob_ask <= hi):
                        ok = False

                if ok:
                    best_bid = ob_bid
                    best_ask = ob_ask
            except Exception:
                pass

        spread_pct = None
        # Final quote sanity vs last price (some venues occasionally return broken bid/ask like bid<<last<<ask).
        try:
            ref_price = float(price) if price is not None else None
        except Exception:
            ref_price = None
        if ref_price is not None and ref_price > 0:
            lo = ref_price * 0.5
            hi = ref_price * 1.5
            if best_bid is not None and not (lo <= float(best_bid) <= hi):
                best_bid = None
            if best_ask is not None and not (lo <= float(best_ask) <= hi):
                best_ask = None
            # If one side is missing, fall back to last price so paper fills don't blow up.
            if best_bid is None and best_ask is None:
                best_bid = ref_price
                best_ask = ref_price
            elif best_bid is None and best_ask is not None:
                best_bid = min(ref_price, float(best_ask))
            elif best_ask is None and best_bid is not None:
                best_ask = max(ref_price, float(best_bid))
            if best_bid is not None and best_ask is not None and float(best_ask) < float(best_bid):
                best_bid = ref_price
                best_ask = ref_price

        if best_bid is not None and best_ask is not None:
            mid = 0.5 * (best_bid + best_ask)
            if mid > 0:
                spread_pct = (best_ask - best_bid) / mid

        return price, closes, candles, best_bid, best_ask, spread_pct

    def _build_decide_ctx(
        self,
        *,
        sym: str,
        price: Any,
        closes: list[float],
        candles: int,
        best_bid: Optional[float],
        best_ask: Optional[float],
        spread_pct: Optional[float],
    ) -> Optional[Dict[str, Any]]:
        if price is None or candles < 20:
            return None
        try:
            px = float(price)
        except Exception:
            return None
        if px <= 0:
            return None

        regime = self._infer_regime(closes)
        ofi = self._compute_ofi_score(sym)
        liq = self._liquidity_score(sym)
        bar_seconds = 60.0
        try:
            tf = str(getattr(config, "TIMEFRAME", "") or "").strip().lower()
            if tf.endswith("s"):
                bar_seconds = float(tf[:-1])
            elif tf.endswith("m"):
                bar_seconds = float(tf[:-1]) * 60.0
            elif tf.endswith("h"):
                bar_seconds = float(tf[:-1]) * 3600.0
            elif tf.endswith("d"):
                bar_seconds = float(tf[:-1]) * 86400.0
        except Exception:
            bar_seconds = 60.0
        if not math.isfinite(float(bar_seconds)) or float(bar_seconds) <= 0:
            bar_seconds = 60.0
        
        # ✅ FIX: mu/sigma are used by MC in annualized units (per-year)
        mu_sim, sigma_sim = self._compute_returns_and_vol(closes, bar_seconds=float(bar_seconds))
        
        ctx = {
            "symbol": sym,
            "price": px,
            "closes": closes,
            "regime": regime,
            # ✅ FIX: mu_sim과 sigma_sim 추가
            "mu_sim": mu_sim,
            "sigma_sim": sigma_sim,
            "mu_base": mu_sim,  # backward compat
            "sigma": sigma_sim,  # backward compat
            # Back-compat: engines expect `ofi_score` (legacy ctx used `ofi`).
            "ofi_score": float(ofi),
            "ofi": float(ofi),
            "liquidity_score": float(liq),
            "spread_pct": float(spread_pct) if spread_pct is not None else 0.0,
            # Back-compat: some code expects `bid`/`ask`.
            "bid": best_bid,
            "ask": best_ask,
            "best_bid": best_bid,
            "best_ask": best_ask,
            "bar_seconds": float(bar_seconds),
            "leverage": float(self.leverage),
            "max_leverage": float(self.max_leverage),
            "n_paths": int(self.mc_n_paths_live),
            "use_jax": bool(self.mc_use_jax),
            "tail_mode": str(self.mc_tail_mode),
            "student_t_df": float(self.mc_student_t_df),
        }
        # PMaker: provide survival model for mu_alpha boost (paper-mode training updates sym_fill_mean).
        try:
            pm = getattr(self, "pmaker", None)
            surv = getattr(pm, "surv", None) if pm is not None else None
            if pm is not None and bool(getattr(pm, "enabled", False)) and surv is not None:
                ctx["pmaker_surv"] = surv
                ctx["pmaker_timeout_ms"] = int(os.environ.get("MAKER_TIMEOUT_MS", str(getattr(config, "MAKER_TIMEOUT_MS", 1500))))
        except Exception:
            pass
        return ctx

    async def _rows_snapshot(self, ts_ms: int, *, apply_trades: bool = False) -> list[Dict[str, Any]]:
        rows: list[Dict[str, Any]] = []
        for sym in self.symbols:
            price, closes, candles, best_bid, best_ask, spread_pct = self._snapshot_inputs(sym)

            ctx = None
            decision = None
            mark_price = self._mark_price(best_bid, best_ask, float(price) if price is not None else None)
            self._paper_mark_position(sym, mark_price, ts_ms)
            ctx = self._build_decide_ctx(
                sym=sym,
                price=price,
                closes=closes,
                candles=candles,
                best_bid=best_bid,
                best_ask=best_ask,
                spread_pct=spread_pct,
            )
            if ctx is not None:
                try:
                    decision = self.hub.decide(ctx)
                except Exception as e:
                    self._log_err(f"[ERR] decide {sym}: {e}")
                    decision = None

            if apply_trades:
                details = decision.get("details", []) if isinstance(decision, dict) else []
                best_detail = None
                if isinstance(details, list) and details:
                    cand = [d for d in details if isinstance(d, dict)]
                    if cand:
                        best_detail = max(cand, key=lambda d: float(d.get("ev", 0.0) or 0.0))
                decision_reason = str(decision.get("reason", "") or "") if isinstance(decision, dict) else ""
                desired_action = str(decision.get("action", "WAIT") if isinstance(decision, dict) else "WAIT")
                await self._paper_trade_step(
                    sym=sym,
                    desired_action=desired_action,
                    ts_ms=ts_ms,
                    best_bid=best_bid,
                    best_ask=best_ask,
                    mark_price=mark_price,
                    detail=best_detail,
                    decision_reason=decision_reason,
                )

            rows.append(self._row(sym, price, ts_ms, decision, candles, ctx=ctx))
        return rows

    def _rows_snapshot_cached(self, ts_ms: int) -> list[Dict[str, Any]]:
        rows: list[Dict[str, Any]] = []
        for sym in self.symbols:
            price, closes, candles, _best_bid, _best_ask, _spread_pct = self._snapshot_inputs(sym)
            mark_price = self._mark_price(_best_bid, _best_ask, float(price) if price is not None else None)
            self._paper_mark_position(sym, mark_price, ts_ms)
            cached = self._decision_cache.get(sym) or {}
            decision = cached.get("decision")
            regime = self._infer_regime(closes) if candles >= 20 else "-"
            rows.append(self._row(sym, price, ts_ms, decision, candles, ctx={"regime": regime}))
        return rows

    async def decision_worker_loop(self):
        """
        Continuously refresh per-symbol decisions in a background task.
        Uses asyncio.to_thread() so HTTP/WebSocket tasks stay responsive even when MC is heavy.
        """
        while True:
            cycle_t0 = time.time()
            base_syms = list(self.symbols)
            if not base_syms:
                await asyncio.sleep(0.25)
                continue

            start = int(self._decision_rr_index) % len(base_syms)
            rotated = base_syms[start:] + base_syms[:start]
            self._decision_rr_index = (start + 1) % len(base_syms)

            # Prioritize open positions for faster exit/management responsiveness.
            open_set: set[str] = set()
            for sym, pos in (self.positions or {}).items():
                try:
                    size = float(pos.get("size", pos.get("quantity", pos.get("qty", 0.0))) or 0.0)
                except Exception:
                    size = 0.0
                if size != 0.0:
                    open_set.add(sym)
            symbols = [s for s in rotated if s in open_set] + [s for s in rotated if s not in open_set]

            for sym in symbols:
                ts_ms = now_ms()
                last_ts = (self._decision_cache.get(sym) or {}).get("ts")
                try:
                    min_gap_ms = int(max(0.0, float(self.decision_eval_min_interval_sec)) * 1000.0)
                except Exception:
                    min_gap_ms = 0
                if last_ts and min_gap_ms > 0:
                    try:
                        if int(ts_ms) - int(last_ts) < int(min_gap_ms):
                            continue
                    except Exception:
                        pass

                price, closes, candles, best_bid, best_ask, spread_pct = self._snapshot_inputs(sym)
                mark_price = self._mark_price(best_bid, best_ask, float(price) if price is not None else None)
                ctx = self._build_decide_ctx(
                    sym=sym,
                    price=price,
                    closes=closes,
                    candles=candles,
                    best_bid=best_bid,
                    best_ask=best_ask,
                    spread_pct=spread_pct,
                )
                if ctx is None:
                    continue
                # PMaker paper training (simulated maker fills).
                try:
                    self._pmaker_paper_probe_tick(sym=sym, ts_ms=ts_ms, ctx=ctx)
                except Exception:
                    pass

                t0 = time.time()
                try:
                    decision = await asyncio.to_thread(self.hub.decide, ctx)
                except Exception as e:
                    self._log_err(f"[ERR] decide {sym}: {e}")
                    decision = None
                decide_ms = int((time.time() - t0) * 1000)
                
                self._decision_cache[sym] = {"decision": decision, "ctx": ctx, "ts": int(ts_ms), "decide_ms": int(decide_ms)}

                # Refresh T* for the dashboard even if not trading
                if isinstance(decision, dict):
                    # use_optimal_horizon=True will update self._symbol_t_star[sym] internally
                    self._get_symbol_expected_value(sym, decision, use_optimal_horizon=True)

                if self.paper_trading_enabled or self.enable_orders:
                    details = decision.get("details", []) if isinstance(decision, dict) else []
                    best_detail = None
                    if isinstance(details, list) and details:
                        cand = [d for d in details if isinstance(d, dict)]
                        if cand:
                            best_detail = max(cand, key=lambda d: float(d.get("ev", 0.0) or 0.0))
                    decision_reason = str(decision.get("reason", "") or "") if isinstance(decision, dict) else ""
                    desired_action = str(decision.get("action", "WAIT") if isinstance(decision, dict) else "WAIT")
                    await self._paper_trade_step(
                        sym=sym,
                        desired_action=desired_action,
                        ts_ms=ts_ms,
                        best_bid=best_bid,
                        best_ask=best_ask,
                        mark_price=mark_price,
                        detail=best_detail,
                        decision_reason=decision_reason,
                    )

                await asyncio.sleep(0)

            self._decide_cycle_ms = int((time.time() - cycle_t0) * 1000)
            sleep_sec = float(self.decision_worker_sleep_sec) if self.decision_worker_sleep_sec else 0.0
            if sleep_sec > 0:
                await asyncio.sleep(sleep_sec)
            else:
                await asyncio.sleep(0)

    async def decision_loop(self):
        while True:
            t0 = time.time()
            ts = now_ms()
            rows = self._rows_snapshot_cached(ts)
            self._last_rows = rows
            self._loop_ms = int((time.time() - t0) * 1000)

            # mark-to-market equity history for charts
            try:
                live_mode = bool(getattr(self, "enable_orders", False)) and (not bool(getattr(self, "paper_trading_enabled", False)))
                if live_mode and (getattr(self, "_live_equity", None) is not None):
                    equity = float(getattr(self, "_live_equity"))
                else:
                    unreal = sum(float((p or {}).get("unrealized_pnl", 0.0) or 0.0) for p in (self.positions or {}).values())
                    equity = float(self.balance) + float(unreal)
                self._equity_history.append({"time": int(ts), "equity": float(equity)})
            except Exception:
                pass

            # Live risk guards (run continuously even without new entries).
            try:
                if bool(getattr(self, "enable_orders", False)) and (not bool(getattr(self, "paper_trading_enabled", False))):
                    if hasattr(self, "risk"):
                        self.risk.maybe_trigger_total_leverage_guard(int(ts))
                        self.risk.maybe_trigger_margin_guard(int(ts))
            except Exception:
                pass

            if self.dashboard is not None:
                try:
                    await self.dashboard.broadcast(rows)
                except Exception as e:
                    self._log_err(f"[ERR] dashboard broadcast: {e}")

            self._persist_state(force=False)
            elapsed = time.time() - t0
            sleep_left = max(0.0, float(self.decision_refresh_sec) - float(elapsed))
            await asyncio.sleep(sleep_left)

    def reset_tape_and_equity(self) -> None:
        """
        Resets the trade tape, balance (to 10k), positions, and equity history.
        Used by the dashboard 'Clear Trade Tape' button to provide a fresh start.
        """
        import json

        live_mode = bool(getattr(self, "enable_orders", False)) and (not bool(getattr(self, "paper_trading_enabled", False)))
        if live_mode:
            # Live mode must not mutate balances/positions (exchange is source of truth).
            self.trade_tape.clear()
            self._equity_history.clear()
            try:
                ts = int(now_ms())
                eq = None
                if getattr(self, "_live_equity", None) is not None:
                    eq = float(getattr(self, "_live_equity"))
                else:
                    unreal = sum(float((p or {}).get("unrealized_pnl", 0.0) or 0.0) for p in (self.positions or {}).values())
                    eq = float(self.balance) + float(unreal)
                self._equity_history.append({"time": ts, "equity": float(eq)})
            except Exception:
                pass
            try:
                self.exec_stats.clear()
            except Exception:
                pass
            self._log("[RESET] Live 기록창(테이프/커브)만 초기화했습니다. (거래소 잔고/포지션은 변경하지 않음)")
            return
        
        # 1. Reset Trade Tape
        self.trade_tape.clear()
        try:
            self.state_files["trade"].write_text(json.dumps(list(self.trade_tape)), encoding="utf-8")
        except Exception as e:
            self._log_err(f"[RESET_ERR] trade: {e}")

        # 2. Reset Balance
        self.balance = 10000.0
        self._paper_balance = float(self.balance)
        try:
            # Balance is saved as raw string in _persist_state
            self.state_files["balance"].write_text(str(self.balance), encoding="utf-8")
        except Exception as e:
            self._log_err(f"[RESET_ERR] balance: {e}")

        # 3. Reset Positions (New)
        self.positions.clear()
        self._paper_pos_meta.clear()
        self._pos_meta.clear()
        try:
            self.state_files["positions"].write_text(json.dumps({}), encoding="utf-8")
        except Exception as e:
            self._log_err(f"[RESET_ERR] positions: {e}")

        # 4. Reset Equity History
        self._equity_history.clear()
        self._equity_history.append({"time": int(now_ms()), "equity": 10000.0})
        try:
            # Equity history is not currently persisted in _persist_state, but we write it here just in case
            self.state_files["equity"].write_text(json.dumps(list(self._equity_history)), encoding="utf-8")
        except Exception as e:
            pass
        
        # 5. Clear execution stats
        self.exec_stats.clear()
        
        self._log("[RESET] Trade tape, balance, positions, and equity history reset to initial state (10k).")

    async def liquidate_all_positions(self) -> None:
        """
        Immediately closes all open paper positions at current market prices.
        Temporarily disables paper trading during the close to prevent re-entry
        while positions are being flattened, then restores the previous setting.
        """
        ts = now_ms()
        syms = list(self.positions.keys())
        
        # 1. Disable trading first to prevent re-opening while we close
        was_enabled = bool(self.paper_trading_enabled)
        self.paper_trading_enabled = False
        self._log("🚨 [LIQUIDATE_ALL] Trading temporarily DISABLED; closing all positions...")

        if not syms:
            self._log("[LIQUIDATE] No open positions to close.")
            self._persist_state(force=True)
            # Restore previous state even if there was nothing to close
            self.paper_trading_enabled = bool(was_enabled) and (not getattr(self, "enable_orders", False))
            return

        for sym in syms:
            try:
                mkt = self.market.get(sym) or {}
                price = mkt.get("price")
                if price is None:
                    pos = self.positions.get(sym)
                    price = pos.get("current") or pos.get("entry_price")
                
                if price is not None:
                    # Close without immediate G1 replenishment for each symbol
                    # We will force one final recalculation at the end.
                    await self._close_position(
                        sym=sym,
                        exit_price=float(price),
                        ts_ms=ts,
                        reason="MANUAL_LIQUIDATE_ALL"
                    )
                else:
                    self._log(f"[LIQUIDATE_ERR] Could not find price for {sym}, skipping.")
            except Exception as e:
                self._log_err(f"[LIQUIDATE_ERR] Failed to close {sym}: {e}")
        
        # 2. Final recalculation to update G1 slots correctly
        self._recalculate_groups(force=True)
        # 3. Restore previous trading mode (paper only)
        self.paper_trading_enabled = bool(was_enabled) and (not getattr(self, "enable_orders", False))
        self._persist_state(force=True)
        state = "ON" if self.paper_trading_enabled else "OFF"
        self._log(f"✅ [LIQUIDATE_ALL] {len(syms)} positions closed. Trading is now {state}.")

    async def liquidate_all_positions_live(self) -> None:
        """
        Immediately closes *all* open exchange positions (including symbols outside SYMBOLS_CSV).
        In TESTNET, some symbols can have one-sided books; in that case, reduceOnly MARKET can be
        cancelled with EC_NoImmediateQtyToFill, so we fall back to a reduceOnly LIMIT(GTC) close.
        """
        if not (self.enable_orders and getattr(self, "exchange", None)):
            self._log_err("❌ [LIQUIDATE_ALL_LIVE] Live orders are not enabled or exchange is missing.")
            return

        ts = int(now_ms())
        self._manual_pause_orders(ts, duration_ms=int(self.manual_pause_after_liquidate_ms), reason="liquidate_all")
        try:
            self._live_pending_rotations.clear()
        except Exception:
            pass

        limit_pad_bps = float(_env_float("LIVE_LIQUIDATE_LIMIT_PAD_BPS", 50.0))
        limit_pad = float(max(0.0, limit_pad_bps)) / 10_000.0
        max_rounds = int(_env_int("LIVE_LIQUIDATE_MAX_ROUNDS", 5))
        round_sleep_ms = int(_env_int("LIVE_LIQUIDATE_ROUND_SLEEP_MS", 800))
        ob_depth = int(_env_int("LIVE_LIQUIDATE_ORDERBOOK_DEPTH", 25))
        self._log(
            f"🚨 [LIQUIDATE_ALL_LIVE] Closing ALL open exchange positions (reduceOnly; market if possible, else limit GTC pad={limit_pad_bps:.0f}bps)."
        )

        async def _fetch_positions_any(label: str) -> list[dict[str, Any]]:
            raw: list[dict[str, Any]] = []
            try:
                res = await self._ccxt_call(f"fetch_positions({label})", self.exchange.fetch_positions)
                if isinstance(res, list):
                    raw = [p for p in res if isinstance(p, dict)]
                    return raw
            except Exception as e:
                self._log_err(f"[LIQUIDATE_ALL_LIVE_WARN] fetch_positions(all) failed: {e}")
            try:
                res = await self._ccxt_call(
                    f"fetch_positions({label},fallback)",
                    self.exchange.fetch_positions,
                    list(getattr(self, "symbols", []) or []),
                )
                if isinstance(res, list):
                    raw = [p for p in res if isinstance(p, dict)]
            except Exception as e2:
                self._log_err(f"❌ [LIQUIDATE_ALL_LIVE_ERR] fetch_positions failed: {e2}")
            return raw

        market_sent = 0
        limit_sent = 0
        skipped = 0
        scheduled: set[str] = set()

        async def _place_close(
            symbol: str,
            *,
            close_side: str,
            qty: float,
            position_idx: Optional[int],
            ref_price: Optional[float],
            liq_price: Optional[float],
            label: str,
            force_limit: bool = False,
        ) -> bool:
            nonlocal market_sent, limit_sent
            if not symbol:
                return False
            try:
                q = abs(float(qty))
            except Exception:
                return False
            if q <= 0:
                return False
            cs = str(close_side or "").lower()
            if cs not in ("buy", "sell"):
                return False

            params: Dict[str, Any] = {"reduceOnly": True}
            if position_idx is not None:
                try:
                    params["positionIdx"] = int(position_idx)
                except Exception:
                    pass

            best_bid: Optional[float] = None
            best_ask: Optional[float] = None
            opp_qty = 0.0
            try:
                ob = await self._ccxt_call(
                    f"fetch_order_book(liquidate_all:{label}) {symbol}",
                    self.exchange.fetch_order_book,
                    str(symbol),
                    int(ob_depth),
                )
                bids = (ob or {}).get("bids") or []
                asks = (ob or {}).get("asks") or []
                try:
                    best_bid = float(bids[0][0]) if bids else None
                except Exception:
                    best_bid = None
                try:
                    best_ask = float(asks[0][0]) if asks else None
                except Exception:
                    best_ask = None
                try:
                    if cs == "buy":
                        opp_qty = float(sum(float(x[1]) for x in (asks or []) if x and len(x) >= 2))
                    else:
                        opp_qty = float(sum(float(x[1]) for x in (bids or []) if x and len(x) >= 2))
                except Exception:
                    opp_qty = 0.0
            except Exception:
                pass

            # Bybit TESTNET often has "fake" one-sided/insane top-of-book (e.g., ask=1999).
            # If the top-of-book deviates too far from mark/ref, treat it as unreliable and anchor to ref instead.
            ref_f = None
            try:
                if ref_price is not None:
                    ref_f = float(ref_price)
                    if (not math.isfinite(ref_f)) or ref_f <= 0:
                        ref_f = None
            except Exception:
                ref_f = None
            try:
                max_dev_bps = float(_env_float("LIVE_LIQUIDATE_MAX_BOOK_DEVIATION_BPS", 5000.0))
            except Exception:
                max_dev_bps = 5000.0
            max_dev = float(max(0.0, max_dev_bps)) / 10_000.0
            best_bid_sane = best_bid
            best_ask_sane = best_ask
            if ref_f is not None and max_dev > 0:
                try:
                    if best_ask_sane is not None and float(best_ask_sane) > float(ref_f) * (1.0 + max_dev):
                        best_ask_sane = None
                except Exception:
                    best_ask_sane = None
                try:
                    if best_bid_sane is not None and float(best_bid_sane) < float(ref_f) * (1.0 - max_dev):
                        best_bid_sane = None
                except Exception:
                    best_bid_sane = None

            def _limit_base_price() -> Optional[float]:
                # For a marketable limit close:
                # - BUY (close short) must anchor to best_ask (not best_bid), otherwise it can sit below ask forever.
                # - SELL (close long) must anchor to best_bid.
                if cs == "buy":
                    return best_ask_sane or ref_f or best_bid_sane or best_ask or best_bid
                return best_bid_sane or ref_f or best_ask_sane or best_bid or best_ask

            need_limit = bool(force_limit)
            if cs == "buy" and (not best_ask):
                need_limit = True
            if cs == "sell" and (not best_bid):
                need_limit = True
            if (not need_limit) and opp_qty > 0.0 and opp_qty < float(q):
                need_limit = True

            limit_price: Optional[float] = None
            if need_limit:
                eps = 0.0005  # 5bps safety
                try:
                    lp = float(liq_price) if liq_price is not None else None
                except Exception:
                    lp = None
                base = _limit_base_price()
                if base is not None and math.isfinite(float(base)) and float(base) > 0:
                    if cs == "buy":
                        cand = float(base) * (1.0 + float(limit_pad))
                        cap = float(lp) * (1.0 - eps) if lp and lp > 0 else None
                        if cap is not None and cap > 0:
                            limit_price = min(float(cand), float(cap))
                        else:
                            limit_price = float(cand)
                    else:
                        cand = float(base) * (1.0 - float(limit_pad))
                        floor = float(lp) * (1.0 + eps) if lp and lp > 0 else None
                        if floor is not None and floor > 0:
                            limit_price = max(float(cand), float(floor))
                        else:
                            limit_price = float(cand)

            open_orders: list[dict[str, Any]] = []
            reduce_ids: list[str] = []
            reduce_working_qty = 0.0
            reduce_first_price: Optional[float] = None
            try:
                oo = await self._ccxt_call(
                    f"fetch_open_orders(liquidate_all:{label}) {symbol}",
                    self.exchange.fetch_open_orders,
                    str(symbol),
                )
                if isinstance(oo, list):
                    open_orders = [x for x in oo if isinstance(x, dict)]
            except Exception:
                open_orders = []

            for o in open_orders:
                try:
                    if not bool(o.get("reduceOnly")):
                        continue
                except Exception:
                    continue
                oid = o.get("id")
                if oid:
                    reduce_ids.append(str(oid))
                if reduce_first_price is None:
                    try:
                        if o.get("price") is not None:
                            reduce_first_price = float(o.get("price"))
                    except Exception:
                        reduce_first_price = None
                q_work = None
                try:
                    if o.get("remaining") is not None:
                        q_work = float(o.get("remaining"))
                except Exception:
                    q_work = None
                if q_work is None:
                    try:
                        amt = float(o.get("amount") or 0.0)
                        filled = float(o.get("filled") or 0.0)
                        q_work = max(0.0, amt - filled)
                    except Exception:
                        q_work = None
                if q_work is not None and q_work > 0:
                    reduce_working_qty += float(q_work)

            if need_limit and reduce_working_qty > 0:
                try:
                    ttl = int(self.live_close_note_ttl_ms) if int(self.live_close_note_ttl_ms) > 0 else 300_000
                except Exception:
                    ttl = 300_000
                try:
                    self._live_close_note_by_sym[str(symbol)] = {
                        "until_ms": int(ts) + int(ttl),
                        "kind": "close_wait",
                        "note": "유동성 부족으로 지정가 청산 대기",
                        "price": float(reduce_first_price) if reduce_first_price is not None else None,
                        "qty": float(reduce_working_qty),
                        "side": str(cs),
                    }
                except Exception:
                    pass

                replace_for_price = False
                try:
                    if reduce_first_price is not None:
                        if cs == "buy" and best_ask is not None:
                            replace_for_price = float(reduce_first_price) + 1e-12 < float(best_ask)
                        elif cs == "sell" and best_bid is not None:
                            replace_for_price = float(reduce_first_price) - 1e-12 > float(best_bid)
                except Exception:
                    replace_for_price = False

                if (not replace_for_price) and ((not force_limit) or (float(reduce_working_qty) >= float(q) * 0.98)):
                    try:
                        self._live_pending_exit_reason[str(symbol)] = "MANUAL_LIQUIDATE_ALL"
                    except Exception:
                        pass
                    return True

            for oid in reduce_ids:
                try:
                    await self._ccxt_call(
                        f"cancel_order(liquidate_all:{label}) {symbol}",
                        self.exchange.cancel_order,
                        str(oid),
                        str(symbol),
                    )
                except Exception:
                    continue

            if (limit_price is None) or (not math.isfinite(float(limit_price))) or float(limit_price) <= 0:
                out = await self._place_live_order(str(symbol), cs, q, None, leverage=None, params=params)
                market_sent += 1
                if out is None:
                    need_limit = True
                    base = _limit_base_price()
                    if base:
                        limit_price = float(base) * (1.0 + float(limit_pad)) if cs == "buy" else float(base) * (1.0 - float(limit_pad))
                else:
                    try:
                        remaining = out.get("remaining") if isinstance(out, dict) else None
                        remaining_f = float(remaining) if remaining is not None else None
                    except Exception:
                        remaining_f = None
                    if remaining_f is not None and remaining_f > 0 and (limit_price is None):
                        base = _limit_base_price()
                        if base:
                            limit_price = float(base) * (1.0 + float(limit_pad)) if cs == "buy" else float(base) * (1.0 - float(limit_pad))
                        try:
                            q = float(remaining_f)
                        except Exception:
                            pass

            if limit_price is not None and math.isfinite(float(limit_price)) and float(limit_price) > 0:
                params.setdefault("timeInForce", "GTC")
                out = await self._place_live_order(str(symbol), cs, q, float(limit_price), leverage=None, params=params)
                limit_sent += 1
                if out is not None:
                    try:
                        ttl = int(self.live_close_note_ttl_ms) if int(self.live_close_note_ttl_ms) > 0 else 300_000
                    except Exception:
                        ttl = 300_000
                    try:
                        self._live_close_note_by_sym[str(symbol)] = {
                            "until_ms": int(ts) + int(ttl),
                            "kind": "close_wait",
                            "note": "유동성 부족으로 지정가 청산 대기",
                            "price": float(limit_price),
                            "qty": float(q),
                            "side": str(cs),
                        }
                    except Exception:
                        pass
                if need_limit:
                    try:
                        self._log_err(
                            f"[LIQUIDATE_ALL_LIVE_WARN] {symbol} low-liquidity; placed LIMIT close @ {float(limit_price):.8f}"
                        )
                    except Exception:
                        pass

            try:
                self._live_pending_exit_reason[str(symbol)] = "MANUAL_LIQUIDATE_ALL"
            except Exception:
                pass
            return True

        # Multi-round best-effort: market closes can partially fill on thin books.
        # Repeat a few times; if still open, place a resting reduceOnly limit close.
        rounds = max(1, int(max_rounds))
        for r in range(rounds):
            raw_positions = await _fetch_positions_any(f"liquidate_all_r{r+1}")
            open_positions = []
            for p in raw_positions:
                if not isinstance(p, dict):
                    continue
                try:
                    contracts = float(p.get("contracts") or 0.0)
                except Exception:
                    contracts = 0.0
                if abs(contracts) <= 0:
                    continue
                open_positions.append(p)
            if not open_positions:
                break

            for p in open_positions:
                try:
                    sym = str(p.get("symbol") or "").strip()
                    contracts = float(p.get("contracts") or 0.0)
                    if (not sym) or abs(contracts) <= 0:
                        continue
                    side_raw = str(p.get("side") or "").lower()
                    if side_raw in ("long", "buy"):
                        close_side = "sell"
                    elif side_raw in ("short", "sell"):
                        close_side = "buy"
                    else:
                        skipped += 1
                        continue
                    info = p.get("info") if isinstance(p.get("info"), dict) else {}
                    pos_idx = None
                    try:
                        if isinstance(info, dict) and info.get("positionIdx") is not None:
                            pos_idx = int(info.get("positionIdx"))
                    except Exception:
                        pos_idx = None
                    liq = None
                    try:
                        if isinstance(info, dict) and info.get("liqPrice") is not None:
                            liq = float(info.get("liqPrice")) if float(info.get("liqPrice")) > 0 else None
                    except Exception:
                        liq = None
                    ref = None
                    try:
                        ref = float(p.get("markPrice") or p.get("lastPrice") or 0.0) or None
                    except Exception:
                        ref = None
                    ok = await _place_close(
                        sym,
                        close_side=close_side,
                        qty=abs(float(contracts)),
                        position_idx=pos_idx,
                        ref_price=ref,
                        liq_price=liq,
                        label=f"ex_r{r+1}",
                    )
                    if ok:
                        scheduled.add(sym)
                except Exception:
                    skipped += 1

            if r < (rounds - 1):
                await asyncio.sleep(max(0.2, float(round_sleep_ms) / 1000.0))

        # Final pass: if anything is still open, place resting limit closes.
        still_open = await _fetch_positions_any("liquidate_all_final")
        for p in still_open:
            try:
                sym = str(p.get("symbol") or "").strip()
                contracts = float(p.get("contracts") or 0.0)
                if (not sym) or abs(contracts) <= 0:
                    continue
                side_raw = str(p.get("side") or "").lower()
                if side_raw in ("long", "buy"):
                    close_side = "sell"
                elif side_raw in ("short", "sell"):
                    close_side = "buy"
                else:
                    continue
                info = p.get("info") if isinstance(p.get("info"), dict) else {}
                pos_idx = None
                try:
                    if isinstance(info, dict) and info.get("positionIdx") is not None:
                        pos_idx = int(info.get("positionIdx"))
                except Exception:
                    pos_idx = None
                liq = None
                try:
                    if isinstance(info, dict) and info.get("liqPrice") is not None:
                        liq = float(info.get("liqPrice")) if float(info.get("liqPrice")) > 0 else None
                except Exception:
                    liq = None
                ref = None
                try:
                    ref = float(p.get("markPrice") or p.get("lastPrice") or 0.0) or None
                except Exception:
                    ref = None
                await _place_close(
                    sym,
                    close_side=close_side,
                    qty=abs(float(contracts)),
                    position_idx=pos_idx,
                    ref_price=ref,
                    liq_price=liq,
                    label="ex_final",
                    force_limit=True,
                )
            except Exception:
                continue

        # Local positions (universe-filtered view) as safety net
        for sym, pos in list((self.positions or {}).items()):
            if str(sym) in scheduled:
                continue
            if not isinstance(pos, dict):
                continue
            side_u = str(pos.get("side") or "").upper()
            if side_u == "LONG":
                close_side = "sell"
            elif side_u == "SHORT":
                close_side = "buy"
            else:
                continue
            try:
                qty = abs(float(pos.get("size") or pos.get("quantity") or 0.0))
            except Exception:
                continue
            pos_idx = None
            try:
                if pos.get("position_idx") is not None:
                    pos_idx = int(pos.get("position_idx"))
            except Exception:
                pos_idx = None
            ref = None
            try:
                ref = float(pos.get("price") or pos.get("current") or pos.get("entry_price") or 0.0) or None
            except Exception:
                ref = None
            ok = await _place_close(
                str(sym),
                close_side=close_side,
                qty=qty,
                position_idx=pos_idx,
                ref_price=ref,
                liq_price=None,
                label="local",
            )
            if ok:
                scheduled.add(str(sym))

        try:
            self._last_live_sync_ms = 0
        except Exception:
            pass

        self._log(f"✅ [LIQUIDATE_ALL_LIVE] Submitted closes: market={market_sent} limit={limit_sent} (skipped={skipped}).")


async def build_exchange() -> ccxt.Exchange:
    _load_env_file_override(str(config.BASE_DIR / "state" / "bybit.env"))
    # Only load the example template when the real env file is missing.
    # (The example often enables BYBIT_TESTNET=1 which would otherwise hijack prices.)
    if not (config.BASE_DIR / "state" / "bybit.env").exists():
        _load_env_file(str(config.BASE_DIR / "state" / "bybit.env.example"))

    # Public-data mode (paper trading / dashboards) should not require auth.
    # Invalid keys can break `load_markets()` on Bybit because it may hit private endpoints.
    ex_cfg: Dict[str, Any] = {
        "enableRateLimit": True,
        "timeout": int(config.CCXT_TIMEOUT_MS),
    }
    if bool(getattr(config, "ENABLE_LIVE_ORDERS", False)):
        ex_cfg.update(
            {
                "apiKey": os.environ.get("BYBIT_API_KEY", ""),
                "secret": os.environ.get("BYBIT_API_SECRET", ""),
            }
        )
    exchange = ccxt.bybit(ex_cfg)
    if str(os.environ.get("BYBIT_TESTNET", "0")).strip().lower() in ("1", "true", "yes"):
        exchange.set_sandbox_mode(True)
    return exchange


async def build_data_exchange() -> ccxt.Exchange:
    """
    Public-data exchange used for prices/OHLCV/orderbook feeding into MC/EV.
    By default, this uses Bybit MAINNET even when orders are on TESTNET so that
    live mode can share the same market-data distribution as paper mode.
    """
    # Load env so CCXT_TIMEOUT_MS etc are available; do not require keys.
    _load_env_file_override(str(config.BASE_DIR / "state" / "bybit.env"))
    if not (config.BASE_DIR / "state" / "bybit.env").exists():
        _load_env_file(str(config.BASE_DIR / "state" / "bybit.env.example"))

    ex_cfg: Dict[str, Any] = {
        "enableRateLimit": True,
        "timeout": int(config.CCXT_TIMEOUT_MS),
    }
    ex = ccxt.bybit(ex_cfg)
    # Separate knob for data feed; default to mainnet (0).
    data_testnet = str(os.environ.get("DATA_BYBIT_TESTNET", "0")).strip().lower() in ("1", "true", "yes")
    if data_testnet:
        ex.set_sandbox_mode(True)
    return ex
