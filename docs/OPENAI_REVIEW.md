# OpenAI Code Review — 2026-02-18 16:29

**Model:** gpt-5.2-codex
**Risk Score:** 7/10
**Summary:** 하이브리드 MC 기반 전략은 구조적으로 안정적이지만, 수수료 이중 차감/레버리지 상한 불일치/게이트 파라미터 미적용으로 인해 OOS 성능과 리스크가 악화될 가능성이 큽니다.

## Suggestions

### [P1] net_expectancy 필터의 수수료 이중 차감 제거
**Category:** logic | **Confidence:** 78%

docs/SIGNAL_PIPELINE_REFERENCE.md에 명시된 문제처럼 net_expectancy 계산에서 fee_est를 EV에 다시 차감하면 MC EV(이미 fee 포함)가 2배로 패널티됩니다. 이는 both_ev_neg 및 net_expectancy 필터 과차단을 유발합니다. fee_est를 0으로 두거나, EV를 gross로 복원한 뒤 차감하도록 수정해야 합니다.

**Env Changes:** `{'ENTRY_NET_EXPECTANCY_MIN': '-0.0003'}`

**Code Changes:** engines/mc/entry_evaluation.py 또는 main_engine의 _min_filter_states 내 net_edge 계산부에서 `net_edge = edge_raw - fee_est` → `net_edge = edge_raw` (또는 edge_raw에 fee 역보정 후 차감).

**Expected Impact:** 필터 과차단 해소로 진입 기회 회복, EV/WR 개선. 특히 chop 구간에서 both_ev_neg 감소.

### [P1] 레버리지 상한 일관화 및 저신뢰 구간 가변 하한 적용
**Category:** risk | **Confidence:** 72%

bybit.env에서 MAX_LEVERAGE=15인데 UNI_LEV_MAX=50, UNI_LEV_MIN=10이 공존합니다. decision.py에서는 ctx.max_leverage만 사용해 상위 cap 불일치 위험이 있습니다. 저신뢰/고 VPIN 구간에서는 레버리지 하한(UNI_LEV_MIN=10)이 과도해 강제 고레버리지 진입을 유발할 수 있습니다. 글로벌 캡과 저신뢰 cap을 코드에서 강제 적용하고, 저신뢰 조건에서는 레버리지 하한을 1~3으로 낮추는 조건부 정책을 권장합니다.

**Env Changes:** `{'LEVERAGE_LOW_CONF_CAP': '3.0', 'LEVERAGE_HIGH_VPIN_CAP': '3.0'}`

**Code Changes:** engines/mc/decision.py: max_leverage 계산 시 `max_leverage = min(ctx_max, config.MAX_LEVERAGE, regime_policy.max_leverage, env UNI_LEV_MAX)` 적용. 레버리지 floor도 `if conf < LEVERAGE_LOW_CONF_THRESHOLD or vpin > LEVERAGE_HIGH_VPIN_THRESHOLD: lev_floor=1~3` 로 조건부 하향.

**Expected Impact:** 과도한 레버리지 강제 진입 감소, liquidation/급락 손실 억제, 실거래 리스크 하향.

### [P1] CF 상위 개선안(Volatility gate/VPIN/Regime side block) 적용
**Category:** param | **Confidence:** 69%

CF 분석에서 유의미한 개선(+$290~$258 OOS)이 확인된 volatility_gate, vpin_filter, regime_side_block, chop_guard, direction_gate 파라미터가 현재 env에 완전 반영되지 않았습니다. 특히 VPIN 0.3, chop_only volatility gate 및 bear_long/bull_short/chop_long 차단이 핵심 개선점입니다.

**Env Changes:** `{'VOLATILITY_GATE_SCOPE': 'chop_only', 'VOLATILITY_GATE_CHOP_MIN_SIGMA': '0.1', 'VOLATILITY_GATE_CHOP_MAX_SIGMA': '2.5', 'VOLATILITY_GATE_CHOP_MAX_VPIN': '0.65', 'VOLATILITY_GATE_CHOP_MIN_DIR_CONF': '0.68', 'VOLATILITY_GATE_CHOP_MIN_ABS_MU_ALPHA': '20.0', 'VOLATILITY_GATE_CHOP_MAX_HOLD_SEC': '300', 'VPIN_MAX_FILTER': '0.3', 'REGIME_SIDE_BLOCK_LIST': 'bear_long,bull_short,chop_long', 'CHOP_ENTRY_FLOOR_ADD': '0.003', 'CHOP_ENTRY_MIN_DIR_CONF': '0.8', 'DIR_GATE_MIN_CONF': '0.65', 'DIR_GATE_MIN_EDGE': '0.1', 'DIR_GATE_MIN_SIDE_PROB': '0.5195'}`

**Code Changes:** engines/mc/entry_evaluation.py 또는 main_engine 필터 체인에 volatility gate/VPIN filter/side block 조건이 없다면 추가. 이미 존재한다면 env key 매핑 확인 및 적용.

**Expected Impact:** 거래 수 감소 대신 OOS PnL 개선, WR 및 R:R 상승. 특히 chop 구간 손실 억제.

### [P2] 결정 시드 안정성 개선 (hash 불안정성 제거)
**Category:** logic | **Confidence:** 61%

decision.py에서 `seed = hash(symbol) ^ seed_window` 사용은 Python 해시 시드 랜덤화로 프로세스 재시작 시 결과가 달라질 수 있습니다. 재현성과 디버깅을 위해 안정적 해시(sha256)를 사용하세요.

**Code Changes:** engines/mc/decision.py: `seed = int((hash(symbol) ^ seed_window) & 0xFFFFFFFF)` → `seed = int(int.from_bytes(hashlib.sha256(symbol.encode()).digest()[:4], 'little') ^ seed_window)`

**Expected Impact:** 재현성 향상, OOS 디버깅 용이, 스코어/결정 일관성 확보.

## Warnings
- state/bybit.env에 API 키 및 Telegram 토큰이 평문으로 포함되어 있습니다. 즉시 로테이션 및 비밀 관리로 전환 필요.
- MC_HYBRID_ONLY=1 환경에서는 legacy 레버리지 최적화 블록이 무시됩니다. 설정 변경 시 코드 경로가 달라질 수 있으니 실험 전 분기 확인이 필요합니다.


---
*Auto-generated by research/openai_reviewer.py*