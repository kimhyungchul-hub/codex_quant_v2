<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trading Dashboard v4 (Light, Table, Charts)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root {
      --bg: #f6f8fb;
      --panel: #ffffff;
      --text: #111827;
      --muted: #6b7280;
      --line: #e5e7eb;
      --shadow: 0 6px 18px rgba(17, 24, 39, .06);
      --radius: 14px;

      --good: #16a34a;
      --bad: #dc2626;
      --warn: #d97706;
      --accent: #2563eb;
      --accent2: #0ea5e9;
      --chip: #f3f4f6;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial
    }

    .wrap {
      max-width: 1400px;
      margin: 0 auto;
      padding: 14px
    }

    .topbar {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      padding: 10px 12px;
      box-shadow: var(--shadow);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .chip {
      display: flex;
      gap: 8px;
      align-items: baseline;
      padding: 7px 10px;
      border-radius: 999px;
      background: var(--chip);
      border: 1px solid var(--line);
      font-size: 13px
    }

    .chip.toggle {
      cursor: pointer;
      transition: border-color 0.15s ease;
    }

    .chip.toggle:hover {
      border-color: var(--accent);
    }

    .chip b {
      font-size: 12px;
      color: var(--muted);
      font-weight: 600
    }

    .chip .v {
      font-weight: 700
    }

    .chip .on {
      color: var(--bad)
    }

    .chip .off {
      color: var(--good)
    }

    .alpha-sub {
      display: block;
      font-size: 10px;
      line-height: 1.1;
      color: var(--muted);
      margin-top: 2px;
      white-space: nowrap;
    }

    .spacer {
      flex: 1
    }

    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center
    }

    .input {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
      font-size: 13px;
      min-width: 220px;
    }

    .btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      background: #fff;
      font-size: 13px;
      cursor: pointer;
    }

    .btn.mini {
      padding: 4px 6px;
      font-size: 11px;
      border-radius: 8px;
    }

    .btn:hover {
      border-color: #cbd5e1
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .btn.danger {
      border-color: #fecaca;
      background: #fff5f5;
      color: #b91c1c;
    }

    .btn.danger:hover {
      border-color: #fca5a5;
      background: #ffe4e4;
    }

    .btn.warn {
      border-color: #fde68a;
      background: #fffbeb;
      color: #b45309;
    }

    .btn.warn:hover {
      border-color: #fcd34d;
      background: #fef3c7;
    }

    .btn.info {
      border-color: #bfdbfe;
      background: #f0f9ff;
      color: #1e40af;
    }

    .btn.info:hover {
      border-color: #93c5fd;
      background: #e0f2fe;
    }

    .grid {
      display: grid;
      grid-template-columns: 1.55fr .95fr;
      gap: 12px;
      margin-top: 12px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .panel h3 {
      margin: 0;
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      font-size: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .panel h3 .sub {
      color: var(--muted);
      font-weight: 600;
      font-size: 12px
    }

    .panel .body {
      padding: 10px 12px
    }

    .tight {
      padding: 0
    }

    .tableWrap {
      overflow: visible;
      max-height: none
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      font-size: 12.5px
    }

    thead th {
      position: sticky;
      top: 0;
      z-index: 3;
      background: linear-gradient(#fff, #fbfbfd);
      border-bottom: 1px solid var(--line);
      padding: 9px 10px;
      text-align: left;
      white-space: nowrap;
      font-size: 12px;
      color: #374151;
      font-weight: 700;
      cursor: pointer;
    }

    tbody td {
      border-bottom: 1px solid var(--line);
      padding: 8px 10px;
      white-space: nowrap;
      vertical-align: middle;
    }

    tbody tr:hover {
      background: #f8fafc
    }

    tbody tr.sel {
      outline: 2px solid rgba(37, 99, 235, .25);
      background: #eff6ff
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: #fff;
      font-size: 11px;
      font-weight: 700;
    }

    .wait-reason {
      font-size: 11px;
      color: var(--warn);
      margin-bottom: 4px;
      max-width: 520px;
      white-space: normal;
      overflow: visible;
      text-overflow: clip;
      word-break: break-word;
      line-height: 1.25;
    }

    .wait-reason.muted {
      color: var(--muted);
    }

    .up {
      color: var(--good)
    }

    .down {
      color: var(--bad)
    }

    .wait {
      color: var(--warn)
    }

    .muted {
      color: var(--muted)
    }

    /* í…Œì´ë¸” ì—´ ê°„ê²© ì¤„ì´ê¸° */
    thead th {
      padding: 7px 6px !important;
      font-size: 11px !important
    }

    tbody td {
      padding: 6px !important
    }

    .right {
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .charts {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px
    }

    canvas {
      width: 100% !important;
      height: 240px !important
    }

    #equityChart {
      height: 360px !important
    }

    #liveEquityChart {
      height: 240px !important
    }

    .eq-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
      font-size: 12px
    }

    .eq-controls select,
    .eq-controls input[type="range"] {
      height: 28px
    }

    .eq-controls #eqPan {
      width: 180px
    }

    .chart-mini {
      height: 170px !important
    }

    .sectionRow {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px
    }

    .tableWrap.small {
      max-height: 420px;
      overflow: auto
    }

    /* Compact current-positions table */
    #posWrap {
      overflow-x: auto;
      overflow-y: visible;
      max-height: none
    }

    #posWrap table {
      width: 100%;
      table-layout: fixed;
    }

    #posWrap thead th {
      padding: 2px 6px !important;
      font-size: 11px !important;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #posWrap tbody td {
      padding: 2px 6px !important;
      line-height: 1.1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #posWrap .btn.mini {
      padding: 2px 6px;
      font-size: 11px;
      line-height: 1.0
    }

    details {
      border-top: 1px solid var(--line)
    }

    summary {
      padding: 10px 12px;
      cursor: pointer;
      color: #374151;
      font-weight: 700;
      font-size: 13px
    }

    .log {
      max-height: 240px;
      overflow: auto;
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      font-family: ui-monospace, monospace;
      font-size: 12px
    }

    .kpi {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 8px
    }

    .kpi .pill {
      background: #f8fafc
    }

    .warnbar {
      margin-top: 8px;
      padding: 8px 12px;
      border: 1px solid #ef4444;
      background: #fff1f2;
      color: #7f1d1d;
      border-radius: 10px;
      font-weight: 700;
      font-size: 12px
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="chip" title="ë¦¬ìŠ¤í¬ í‚¬ìŠ¤ìœ„ì¹˜ ìƒíƒœì…ë‹ˆë‹¤. ONì´ë©´ ì‹ ê·œ ì§„ì…ì´ ì œí•œë©ë‹ˆë‹¤."><b>KillSwitch</b><span id="ks" class="v off">OFF</span></div>
      <div class="chip" title="í˜„ì¬ í‰ê°€ìì‚°(Equity)ì…ë‹ˆë‹¤. ëª¨ë¸ ê¸°ì¤€ ë˜ëŠ” ë¼ì´ë¸Œ ê¸°ì¤€ì´ í‘œì‹œë©ë‹ˆë‹¤."><b>Equity</b><span id="eq" class="v">-</span></div>
      <div class="chip" title="í˜„ì¬ ì—°ê²°ëœ ëŒ€ì‹œë³´ë“œ WebSocket í´ë¼ì´ì–¸íŠ¸ ìˆ˜ì…ë‹ˆë‹¤."><b>WS</b><span id="ws" class="v">-</span></div>
      <div class="chip" title="ê±°ë˜ì†Œ ì‹œì„¸ í”¼ë“œ ìˆ˜ì‹  ìƒíƒœì…ë‹ˆë‹¤."><b>Feed</b><span id="feed" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ MC decide_batch ì²˜ë¦¬ ì‹œê°„ì…ë‹ˆë‹¤."><b>MC</b><span id="mcTime" class="v">-</span></div>
      <div class="chip" title="MC ì—°ì‚° ë°±ì—”ë“œ/ë””ë°”ì´ìŠ¤ ì •ë³´ì…ë‹ˆë‹¤."><b>MC Dev</b><span id="mcDev" class="v">-</span></div>
      <div class="chip" title="ì´ ë…¸ì¶œë„(ì‚¬ìš© ì¤‘ ë…¸ì…”ë„ / ë…¸ì¶œ í•œë„) ë¹„ìœ¨ì…ë‹ˆë‹¤."><b>Util</b><span id="util" class="v">-</span></div>
      <div class="chip" title="ì˜ˆì¸¡ í™•ë¥ ì˜ ë³´ì • í’ˆì§ˆ ì§€í‘œ(Brier Score)ì…ë‹ˆë‹¤. ë‚®ì„ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤."><b>Brier</b><span id="brier" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ êµ¬ê°„ ë°©í–¥ ì ì¤‘ë¥ ì…ë‹ˆë‹¤."><b>Hit%</b><span id="hit" class="v">-</span></div>
      <div class="chip" title="Alpha Hit ML ëª¨ë“ˆ í™œì„±í™” ìƒíƒœì…ë‹ˆë‹¤."><b>Î±ML</b><span id="alphaHit" class="v">-</span></div>
      <div class="chip" title="Signal Boost í™œì„±í™” ìƒíƒœì…ë‹ˆë‹¤. mu_alphaê°€ ì¶”ê°€ ì¦í­ë©ë‹ˆë‹¤."><b>Î±Boost</b><span id="alphaBst"
          class="v">-</span></div>
      <div class="chip" title="AlphaHit í•™ìŠµ ë²„í¼ ìƒ˜í”Œ ìˆ˜(í˜„ì¬/ìµœì†Œ)ì…ë‹ˆë‹¤."><b>Î±Buf</b><span id="alphaBuf"
          class="v">-</span></div>
      <div class="chip" title="AlphaHit í•™ìŠµ ì†ì‹¤ê°’ê³¼ EMAì…ë‹ˆë‹¤."><b>Î±Loss</b><span id="alphaLoss"
          class="v">-</span></div>
      <div class="chip" title="AlphaHit replay íŒŒì¼ ì €ì¥/ë¡œë“œ ìƒíƒœì…ë‹ˆë‹¤."><b>Î±Replay</b><span id="alphaReplay"
          class="v">-</span></div>
      <div class="chip toggle" title="ALPHA ì»¬ëŸ¼ ìƒì„¸ í‘œì‹œ í† ê¸€ì…ë‹ˆë‹¤. OFFì—¬ë„ ë§¤ë§¤ ë¡œì§ì—ëŠ” ì˜í–¥ì´ ì—†ìŠµë‹ˆë‹¤."><b>Î±Detail</b><span id="alphaDetail" class="v">-</span></div>
      <div class="chip" title="MLOFI/CAUSAL ê°€ì¤‘ì¹˜ ìˆ˜ì§‘/í•™ìŠµ íŒŒì´í”„ë¼ì¸ ìƒíƒœì…ë‹ˆë‹¤."><b>Î±Wgt</b><span id="alphaWgt" class="v">-</span></div>
      <div class="chip" title="MLOFI ê°€ì¤‘ì¹˜ íŒŒì¼ ìƒì„±/í•™ìŠµ ì§„í–‰ ìƒíƒœì…ë‹ˆë‹¤."><b>MLOFI</b><span id="alphaMlofi" class="v">-</span></div>
      <div class="chip" title="CAUSAL ê°€ì¤‘ì¹˜ íŒŒì¼ ìƒì„±/í•™ìŠµ ì§„í–‰ ìƒíƒœì…ë‹ˆë‹¤."><b>CAUSAL</b><span id="alphaCausal" class="v">-</span></div>
      <div class="chip" title="ëˆ„ì  ì‹ ê·œ ì²­ì‚° ê±´ìˆ˜ì…ë‹ˆë‹¤. NewExit anchor ê¸°ì¤€ìœ¼ë¡œ ë¦¬ì…‹ ì—†ì´ ê³„ì† ëˆ„ì ë©ë‹ˆë‹¤."><b>NewExitCum</b><span id="newClosedCum" class="v">-</span></div>
      <div class="chip" title="í˜„ì¬ ë°°ì¹˜ ì‹ ê·œ ì²­ì‚° ì§„í–‰ë¥ ì…ë‹ˆë‹¤. ì—”ì§„ì˜ REVAL_TARGET_MIN_NEW_CLOSED ê¸°ì¤€(ì˜ˆ: 21/120)ì´ë©°, ëª©í‘œ ë‹¬ì„± í›„ baseline ë¡¤ë§ìœ¼ë¡œ 0ë¶€í„° ë‹¤ì‹œ ì‹œì‘ë©ë‹ˆë‹¤."><b>NewExitBatch</b><span id="newClosedBatch" class="v">-</span></div>
      <div class="chip" title="ìë™ ì¬í‰ê°€ ë¦¬í¬íŠ¸ ì§„í–‰ë¥ ì…ë‹ˆë‹¤. auto_reval_db_report.json(target_new) ê¸°ì¤€ìœ¼ë¡œ 3ê°œ ë¦¬í¬íŠ¸(ê´€ì¸¡ì„±/ì§„ë‹¨/ì¹´ìš´í„°íŒ©ì¶”ì–¼) ì¤€ë¹„ ìƒíƒœë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤."><b>RevalRpt</b><span id="autoReval" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ ì™„ë£Œëœ ìë™ ì¬í‰ê°€ ë°°ì¹˜ì˜ ë°©í–¥ ì ì¤‘ë¥ ê³¼ ì§ì „ ë°°ì¹˜ ëŒ€ë¹„ ë³€í™”ì…ë‹ˆë‹¤."><b>DirHitÎ”</b><span id="kpiDirHit" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ ì™„ë£Œëœ ìë™ ì¬í‰ê°€ ë°°ì¹˜ì˜ ì§„ì… ì´ìŠˆ ë¹„ìœ¨ê³¼ ì§ì „ ë°°ì¹˜ ëŒ€ë¹„ ë³€í™”ì…ë‹ˆë‹¤. ë‚®ì„ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤."><b>EntryIssueÎ”</b><span id="kpiEntryIssue" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ ì™„ë£Œëœ ìë™ ì¬í‰ê°€ ë°°ì¹˜ì˜ í‰ê·  ì²­ì‚° í›„íšŒê°’ê³¼ ì§ì „ ë°°ì¹˜ ëŒ€ë¹„ ë³€í™”ì…ë‹ˆë‹¤. ë‚®ì„ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤."><b>ExitRegretÎ”</b><span id="kpiExitRegret" class="v">-</span></div>
      <div class="chip" title="ì²­ì‚° ê°œì„  ê³ ì • íŒì •ì…ë‹ˆë‹¤. PASS=ëª©í‘œ ì¶©ì¡±, IMP=ê°œì„  ì¤‘, FAIL=ì¬íŠœë‹ í•„ìš”."><b>ExitGate</b><span id="kpiExitGate" class="v">-</span></div>
      <div class="chip" title="ìµœê·¼ Nê±´(ìë™ ì¬í‰ê°€ ë°°ì¹˜ ê¸°ì¤€) ìŠ¬ë¦¬í”¼ì§€ ì˜ˆì¸¡ ì˜¤ì°¨(ì˜ˆì¸¡ vs ì‹¤ì²´ê²°)ì…ë‹ˆë‹¤. MAE/RMSE(bps)ë¥¼ í‘œì‹œí•˜ë©° ë‚®ì„ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤."><b id="kpiSlipErrLabel">SlipErrN</b><span id="kpiSlipErr200" class="v">-</span></div>
      <div class="chip" title="selected_exec_type ê¸°ì¤€ Maker/Taker A/B ì„±ëŠ¥ì…ë‹ˆë‹¤. ê° ê·¸ë£¹ì˜ í‰ê·  ì ˆëŒ€ ìŠ¬ë¦¬í”¼ì§€(bps)ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."><b>ExecAB</b><span id="kpiExecAB" class="v">-</span></div>
      <div class="chip" title="selected_exec_typeì™€ ì‹¤ì œ ì²´ê²° íƒ€ì…ì˜ ì •í•©ì„±ì…ë‹ˆë‹¤. Matchê°€ ë†’ê³  MakerFallbackì´ ë‚®ì„ìˆ˜ë¡ ì¢‹ìŠµë‹ˆë‹¤."><b>ExecMatch</b><span id="kpiExecMatch" class="v">-</span></div>
      <div class="chip" title="ì§„ì… ì „ìš© ì¹´ìš´í„°íŒ©ì¶”ì–¼ ì§€í‘œì…ë‹ˆë‹¤. ê°™ì€ ì§„ì…ì„ ìœ ì§€í–ˆì„ ë•Œ ìµœì  ë³´ìœ  h* ê¸°ì¤€ ìˆ˜ìµ ê°€ëŠ¥ í™•ë¥ (ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸)ì…ë‹ˆë‹¤."><b>EntryPF</b><span id="kpiEntryPf" class="v">-</span></div>
      <div class="chip" title="ì§„ì… ì „ìš© ì¹´ìš´í„°íŒ©ì¶”ì–¼ ì§€í‘œì…ë‹ˆë‹¤. ë°˜ëŒ€ ë°©í–¥ì´ ë” ì¢‹ì•˜ë˜ ë¹„ìœ¨(ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)ì…ë‹ˆë‹¤. ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸."><b>OppBetter</b><span id="kpiOppBetter" class="v">-</span></div>
      <div class="chip" title="ì§„ì… ì „ìš© ì¹´ìš´í„°íŒ©ì¶”ì–¼ ì§€í‘œì…ë‹ˆë‹¤. ë°©í–¥ í›„íšŒê°’(opp-best - chosen-best, ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)ì…ë‹ˆë‹¤. ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸."><b>DirRegret</b><span id="kpiDirRegret" class="v">-</span></div>
      <div class="chip" title="RevalRpt ê¸°ë°˜ ìë™ íŠœë‹ ìƒíƒœì…ë‹ˆë‹¤. ë°°ì¹˜ë³„ ì ìš© ì•¡ì…˜/ì¬í•™ìŠµ ì„±ê³µ ì—¬ë¶€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤."><b>AutoTune</b><span id="autoTune" class="v">-</span></div>
      <div class="chip" title="ì§„ì… precheck(event_exit_ok)ì™€ ì‹¤ì œ event_mc_exit ì²­ì‚°ì˜ ìµœê·¼ ì¼ì¹˜ìœ¨ì…ë‹ˆë‹¤. Strict Consistency ëª¨ë“œì—ì„œ ë†’ì„ìˆ˜ë¡ ì •í•©ì„±ì´ ë†’ìŠµë‹ˆë‹¤."><b>EvAlign</b><span id="eventAlign" class="v">-</span></div>
      <div class="chip" id="mcHealthChip" title="MC íŒŒì´í”„ë¼ì¸ ê±´ê°• ìƒíƒœ (mu_alpha/fee/sigma/EV/ë°©í–¥ ì¼ê´€ì„± ë“± ìë™ ì ê²€)"><b>MCHealth</b><span id="mcHealthVal" class="v">-</span></div>
      <div class="chip" title="í˜„ì¬ ë¡œë“œëœ í™˜ê²½íŒŒì¼/í”„ë¡œíŒŒì¼ì…ë‹ˆë‹¤."><b>ENV</b><span id="envSrc" class="v">-</span></div>
      <div class="chip" title="í˜„ì¬ ì„ íƒëœ ì‹¬ë³¼ì…ë‹ˆë‹¤."><b>Selected</b><span id="selSym" class="v">-</span></div>
      <div class="spacer"></div>
      <div class="controls">
        <input id="search" class="input" placeholder="ì‹¬ë³¼/ìƒíƒœ/ë ˆì§ ê²€ìƒ‰ (ì˜ˆ: BTC, LONG, chop)" />
        <button id="clearSafety" class="btn warn" title="ì•ˆì „ëª¨ë“œ í•´ì œ (ìˆ˜ë™ ì˜¤ë²„ë¼ì´ë“œ)">ì•ˆì „ëª¨ë“œ í•´ì œ</button>
        <button id="clearTrades" class="btn">íŠ¸ë ˆì´ë“œ í…Œì´í”„ ë¹„ìš°ê¸°</button>
        <button id="liquidateAll" class="btn danger" title="ì¦‰ì‹œ ì „ í¬ì§€ì…˜ ì²­ì‚° ìš”ì²­">ì „ì²´ í¬ì§€ì…˜ ì²­ì‚°</button>
        <button id="liquidateAllSafety" class="btn danger" title="ì „ í¬ì§€ì…˜ ì²­ì‚° + ì•ˆì „ëª¨ë“œ ì§„ì…">ì²­ì‚°+ì•ˆì „ëª¨ë“œ</button>
        <button id="restartLiveBtn" class="btn info" title="ì—”ì§„ì„ ë¼ì´ë¸Œ ëª¨ë“œë¡œ ì¬ì‹œì‘ (APIí‚¤ í¬í•¨)">ğŸ”„ ë¼ì´ë¸Œ ì¬ì‹œì‘</button>
      </div>
    </div>
    <div id="outsideWarn" class="warnbar" style="display:none"></div>

    <div class="panel tight">
      <h3>ì‹œì¥/ì‹ í˜¸ í…Œì´ë¸” <span class="sub">ì‹¤ì‹œê°„ ë­í‚¹ Â· Top-4ëŠ” ìë³¸ ë°°ë¶„ ëŒ€ìƒ</span></h3>
      <!-- Top-4 capital allocation summary -->
      <div id="top4Panel"
        style="padding:10px 12px; display:flex; gap:10px; flex-wrap:wrap; border-bottom:1px solid var(--line)"></div>
      <div class="tableWrap" id="mktWrap">
        <table id="mktTable">
          <thead>
            <tr>
              <th data-k="rank" title="TOP í•„í„° ê¸°ì¤€ ìˆœìœ„(ì—†ìœ¼ë©´ ì ìˆ˜ ìˆœìœ„)">RANK</th>
              <th data-k="symbol">SYM</th>
              <th data-k="price">PRICE</th>
              <th data-k="status">STATUS</th>
              <th data-k="filters">FILTER</th>
              <th data-k="hybrid_score">HYBRID</th>
              <th data-k="hybrid_score_hold">HYB_HOLD</th>
              <th data-k="hybrid_score_logw">LOGW</th>
              <th data-k="kelly">KELLY</th>
              <th data-k="pos_roe">ROE%</th>
              <th data-k="pos_leverage">LEV</th>
              <th data-k="rebalance">REBAL</th>
              <th data-k="direction_reason">REASON</th>
              <th data-k="ls_scores">HYB_LS</th>
              <th data-k="delta_ev">Î”H</th>
              <th data-k="exec_cost">COST</th>
              <th data-k="wgt">WGT</th>
              <th data-k="alpha">ALPHA</th>
            </tr>
          </thead>
          <tbody id="mktBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel">
      <h3>í¬íŠ¸í´ë¦¬ì˜¤ ê·¸ë˜í”„ <span class="sub">Equity (ë¯¸ì‹¤í˜„ í¬í•¨ ì‹¤ì‹œê°„)</span></h3>
      <div class="body">
        <canvas id="equityChart"></canvas>
        <div class="eq-controls">
          <span class="pill">ì‹œê°„ì°½</span>
          <select id="eqWindow" class="input">
            <option value="1h">1ì‹œê°„</option>
            <option value="6h" selected>6ì‹œê°„</option>
            <option value="12h">12ì‹œê°„</option>
            <option value="1d">1ì¼</option>
            <option value="3d">3ì¼</option>
            <option value="7d">7ì¼</option>
            <option value="30d">30ì¼</option>
            <option value="all">ì „ì²´</option>
          </select>
          <button id="eqPanLeft" class="btn">â—€</button>
          <input id="eqPan" type="range" min="0" max="1000" value="0" />
          <button id="eqPanRight" class="btn">â–¶</button>
          <button id="eqLatest" class="btn">ìµœì‹ </button>
          <span id="eqRangeLabel" class="mono muted">-</span>
        </div>
        <div class="kpi">
          <span class="pill" title="ê¸°ì¤€ ì”ê³ (í˜„ê¸ˆì„± ìì‚°)ì…ë‹ˆë‹¤.">Balance <span class="mono" id="balKpi">-</span></span>
          <span class="pill" title="ë¯¸ì‹¤í˜„ ì†ìµ í¬í•¨ í‰ê°€ìì‚°ì…ë‹ˆë‹¤.">Equity <span class="mono" id="eqKpi">-</span></span>
          <span class="pill" title="ìµœê·¼ ê³ ì  ëŒ€ë¹„ í˜„ì¬ ì†ì‹¤ë¥ (Drawdown)ì…ë‹ˆë‹¤.">DD <span class="mono" id="ddKpi">-</span></span>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>LIVE Equity Curve <span class="sub">ì‹¤ì œ ê³„ì¢Œ ì‹¤ì‹œê°„ ì”ê³ </span></h3>
      <div class="body">
        <canvas id="liveEquityChart"></canvas>
        <div class="kpi">
          <span class="pill" title="ê±°ë˜ì†Œ ì§€ê°‘ ì”ê³ ì…ë‹ˆë‹¤.">Wallet <span class="mono" id="liveWalletKpi">-</span></span>
          <span class="pill" title="ê±°ë˜ì†Œ ê¸°ì¤€ ì‹¤ì‹œê°„ í‰ê°€ìì‚°ì…ë‹ˆë‹¤.">Equity <span class="mono" id="liveEqKpi">-</span></span>
          <span class="pill" title="ì‚¬ìš© ê°€ëŠ¥í•œ ì—¬ìœ  ì¦ê±°ê¸ˆ/ì”ê³ ì…ë‹ˆë‹¤.">Free <span class="mono" id="liveFreeKpi">-</span></span>
          <span class="pill" title="ì´ˆê¸°/ìœ ì§€ ì¦ê±°ê¸ˆ(IM/MM)ì…ë‹ˆë‹¤.">IM/MM <span class="mono" id="liveMarginKpi">-</span></span>
          <span class="pill" title="ê±°ë˜ì†Œ ë¼ì´ë¸Œ ì”ê³  ë™ê¸°í™” ì§€ì—° ì‹œê°„ì…ë‹ˆë‹¤.">Sync <span class="mono" id="liveSyncKpi">-</span></span>
        </div>
      </div>
    </div>

    <div class="panel tight" style="margin-top:12px">
      <h3>í˜„ì¬ í¬ì§€ì…˜ <span class="sub">ì‹¤ì‹œê°„ ìˆ˜ìµë¥ /ë°©í–¥/ë ˆë²„ë¦¬ì§€/ì§„ì…ê°€/í˜„ì¬ê°€</span></h3>
      <div class="tableWrap small" id="posWrap">
        <table>
          <colgroup>
            <col style="width: 120px;">
            <col style="width: 64px;">
            <col style="width: 92px;">
            <col style="width: 92px;">
            <col style="width: 92px;">
            <col style="width: 78px;">
            <col style="width: 84px;">
            <col style="width: 56px;">
            <col style="width: 72px;">
            <col style="width: 86px;">
            <col style="width: 90px;">
            <col style="width: 132px;">
            <col style="width: 90px;">
            <col style="width: 86px;">
            <col style="width: 70px;">
          </colgroup>
          <thead>
            <tr>
              <th>SYM</th>
              <th>SIDE</th>
              <th>ENTRY</th>
              <th>CUR</th>
              <th>PNL</th>
              <th>ROE%</th>
              <th>ROE%Ã—L</th>
              <th>LEV</th>
              <th>CAP%</th>
              <th>AGE</th>
              <th>T'ENTRY</th>
              <th>T'NOW</th>
              <th>HOLD_EVAL</th>
              <th>H_PICK</th>
              <th>CLOSE</th>
            </tr>
          </thead>
          <tbody id="posBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel tight" style="margin-top:12px">
      <h3>ì•„ì¹´ì´ë¸Œëœ í¬ì§€ì…˜ <span class="sub">ìœ ë‹ˆë²„ìŠ¤ ë°– ìë™ ì •ë¦¬ ë‚´ì—­</span></h3>
      <div class="tableWrap small">
        <table>
          <thead>
            <tr>
              <th>TIME</th>
              <th>SYM</th>
              <th>SIDE</th>
              <th>QTY</th>
              <th>ENTRY</th>
              <th>NOTIONAL</th>
              <th>SOURCE</th>
            </tr>
          </thead>
          <tbody id="archBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel tight" style="margin-top:12px">
      <h3>íŠ¸ë ˆì´ë“œ í…Œì´í”„ <span class="sub">ENTER/EXIT ë‚´ì—­ (ì˜êµ¬ ì €ì¥ëœ íˆìŠ¤í† ë¦¬ í¬í•¨)</span></h3>
      <div class="tableWrap">
        <table>
          <thead>
            <tr>
              <th>TIME</th>
              <th>SYM</th>
              <th>TYPE</th>
              <th>SIDE</th>
              <th>PRICE</th>
              <th>PNL</th>
              <th>ROE%</th>
              <th>LEV</th>
              <th>EXIT</th>
              <th>NOTE</th>
            </tr>
          </thead>
          <tbody id="tradeBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>ìš´ì˜ ë¡œê·¸ <span class="sub">í•„ìš”í•  ë•Œë§Œ í¼ì³ì„œ ë³´ê¸°</span></h3>
      <details>
        <summary>Logs í¼ì¹˜ê¸°</summary>
        <div id="logs" class="log"></div>
      </details>
    </div>

    <div class="panel" id="mcHealthPanel" style="margin-top:12px; display:none;">
      <h3>MC íŒŒì´í”„ë¼ì¸ ê±´ê°• ëª¨ë‹ˆí„° <span class="sub" id="mcHealthTs">-</span></h3>
      <div id="mcHealthDetail" class="log" style="max-height:240px; overflow-y:auto;"></div>
    </div>

    <div class="panel" id="mc-sanity-panel" style="margin-top:12px; display:none; border-left: 3px solid #3498db;">
      <h3>MC ìˆ˜ì¹˜ ì •í•©ì„± ëª¨ë‹ˆí„° <span class="sub">ì‹¤ì‹œê°„ ì´ìƒ ê°ì§€ & ìë™ íŠœë‹</span></h3>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>ì´ìƒ ì§•í›„ ì•Œë¦¼ <span class="sub">ìë™ ê°ì§€ ì´ë²¤íŠ¸</span></h3>
      <div id="alerts" class="log"></div>
    </div>
  </div>

  <script>
    const wsUrl = `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/ws`;
    let ws = null;
    let wsReconnectTimer = null;
    let wsReconnectAttempt = 0;
    let wsLastMessageTs = 0;
    let wsManualClose = false;
    const WS_RECONNECT_MIN_MS = 500;
    const WS_RECONNECT_MAX_MS = 5000;
    const WS_STALE_MS = 15000;

    const $ = (id) => document.getElementById(id);
    const ksEl = $('ks'), eqEl = $('eq'), wsEl = $('ws'), feedEl = $('feed'), utilEl = $('util'), brierEl = $('brier'), hitEl = $('hit');
    const mcTimeEl = $('mcTime'), mcDevEl = $('mcDev');
    const alphaHitEl = $('alphaHit'), alphaBstEl = $('alphaBst');
    const alphaBufEl = $('alphaBuf'), alphaLossEl = $('alphaLoss'), alphaReplayEl = $('alphaReplay');
    const alphaDetailEl = $('alphaDetail');
    const alphaWgtEl = $('alphaWgt'), alphaMlofiEl = $('alphaMlofi'), alphaCausalEl = $('alphaCausal');
    const newClosedCumEl = $('newClosedCum');
    const newClosedBatchEl = $('newClosedBatch');
    const autoRevalEl = $('autoReval');
    const kpiDirHitEl = $('kpiDirHit');
    const kpiEntryIssueEl = $('kpiEntryIssue');
    const kpiExitRegretEl = $('kpiExitRegret');
    const kpiExitGateEl = $('kpiExitGate');
    const kpiSlipErrLabelEl = $('kpiSlipErrLabel');
    const kpiSlipErr200El = $('kpiSlipErr200');
    const kpiExecABEl = $('kpiExecAB');
    const kpiExecMatchEl = $('kpiExecMatch');
    const kpiEntryPfEl = $('kpiEntryPf');
    const kpiOppBetterEl = $('kpiOppBetter');
    const kpiDirRegretEl = $('kpiDirRegret');
    const autoTuneEl = $('autoTune');
    const eventAlignEl = $('eventAlign');
    const mcHealthValEl = $('mcHealthVal');
    const mcHealthChipEl = $('mcHealthChip');
    const mcHealthPanelEl = $('mcHealthPanel');
    const mcHealthDetailEl = $('mcHealthDetail');
    const mcHealthTsEl = $('mcHealthTs');
    const envSrcEl = $('envSrc');
    const selSymEl = $('selSym'), searchEl = $('search');
    const outsideWarnEl = $('outsideWarn');
    const mktBody = $('mktBody'), posBody = $('posBody'), posWrap = $('posWrap'), archBody = $('archBody'), tradeBody = $('tradeBody'), logsEl = $('logs'), alertsEl = $('alerts');
    const balKpi = $('balKpi'), eqKpi = $('eqKpi'), ddKpi = $('ddKpi');
    const liveWalletKpi = $('liveWalletKpi'), liveEqKpi = $('liveEqKpi'), liveFreeKpi = $('liveFreeKpi');
    const liveMarginKpi = $('liveMarginKpi'), liveSyncKpi = $('liveSyncKpi');
    const liquidateBtn = $('liquidateAll');
    const liquidateSafeBtn = $('liquidateAllSafety');
    const clearSafetyBtn = $('clearSafety');
    const eqWindowSel = $('eqWindow');
    const eqPan = $('eqPan');
    const eqPanLeft = $('eqPanLeft');
    const eqPanRight = $('eqPanRight');
    const eqLatestBtn = $('eqLatest');
    const eqRangeLabel = $('eqRangeLabel');
    let lastPositions = [];
    let lastPositionsTs = 0;

    $('clearTrades').onclick = () => {
      tradeTape.length = 0;
      seenTradeMsg.clear();
      renderTradeTape();
    };

    if (liquidateBtn) {
      liquidateBtn.onclick = async () => {
        if (!confirm('ëª¨ë“  í¬ì§€ì…˜ì„ ì¦‰ì‹œ ì²­ì‚°í•©ë‹ˆë‹¤. ê³„ì†í• ê¹Œìš”?')) return;
        const prevText = liquidateBtn.textContent;
        liquidateBtn.disabled = true;
        liquidateBtn.textContent = 'ì²­ì‚° ìš”ì²­ì¤‘...';
        try {
          const res = await fetch('/api/liquidate_all', { method: 'POST' });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) {
            const msg = data.error || `HTTP ${res.status}`;
            throw new Error(msg);
          }
          alert('ì²­ì‚° ìš”ì²­ ì™„ë£Œ');
        } catch (e) {
          alert(`ì²­ì‚° ìš”ì²­ ì‹¤íŒ¨: ${e.message || e}`);
        } finally {
          liquidateBtn.disabled = false;
          liquidateBtn.textContent = prevText;
        }
      };
    }
    if (liquidateSafeBtn) {
      liquidateSafeBtn.onclick = async () => {
        if (!confirm('ì „ í¬ì§€ì…˜ ì²­ì‚° í›„ ì•ˆì „ëª¨ë“œë¡œ ì „í™˜í•©ë‹ˆë‹¤. ê³„ì†í• ê¹Œìš”?')) return;
        const prevText = liquidateSafeBtn.textContent;
        liquidateSafeBtn.disabled = true;
        liquidateSafeBtn.textContent = 'ì²­ì‚°+ì•ˆì „ëª¨ë“œ...';
        try {
          const res = await fetch('/api/liquidate_all_safety', { method: 'POST' });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) {
            const msg = data.error || `HTTP ${res.status}`;
            throw new Error(msg);
          }
          alert('ì²­ì‚°+ì•ˆì „ëª¨ë“œ ìš”ì²­ ì™„ë£Œ');
        } catch (e) {
          alert(`ìš”ì²­ ì‹¤íŒ¨: ${e.message || e}`);
        } finally {
          liquidateSafeBtn.disabled = false;
          liquidateSafeBtn.textContent = prevText;
        }
      };
    }

    if (clearSafetyBtn) {
      clearSafetyBtn.onclick = async () => {
        const safetyOn = !!(latestPayload && (latestPayload.kill_switch || (latestPayload.engine && latestPayload.engine.safety_mode)));
        if (!safetyOn) {
          alert('ì•ˆì „ëª¨ë“œê°€ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.');
          return;
        }
        if (!confirm('ì•ˆì „ëª¨ë“œë¥¼ í•´ì œí•©ë‹ˆë‹¤. ê¸°ì¤€ìë³¸ì„ í˜„ì¬ë¡œ ë¦¬ì…‹í•˜ê³  DD ê¸°ì¤€ì„ ì¬ì„¤ì •í•©ë‹ˆë‹¤. ê³„ì†í• ê¹Œìš”?')) return;
        const prevText = clearSafetyBtn.textContent;
        safetyReqInFlight = true;
        clearSafetyBtn.disabled = true;
        clearSafetyBtn.textContent = 'í•´ì œ ìš”ì²­ì¤‘...';
        try {
          const res = await fetch('/api/safety_mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'clear', reset_equity: true })
          });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) {
            const msg = data.error || `HTTP ${res.status}`;
            throw new Error(msg);
          }
          alert('ì•ˆì „ëª¨ë“œ í•´ì œ ìš”ì²­ ì™„ë£Œ');
        } catch (e) {
          alert(`ì•ˆì „ëª¨ë“œ í•´ì œ ì‹¤íŒ¨: ${e.message || e}`);
        } finally {
          safetyReqInFlight = false;
          clearSafetyBtn.disabled = false;
          clearSafetyBtn.textContent = prevText;
        }
      };
    }

    // Restart Live Engine with proper API keys
    const restartLiveBtn = $('restartLiveBtn');
    if (restartLiveBtn) {
      restartLiveBtn.onclick = async () => {
        if (!confirm('ì—”ì§„ì„ ë¼ì´ë¸Œ ëª¨ë“œë¡œ ì¬ì‹œì‘í•©ë‹ˆë‹¤ (API í‚¤ í¬í•¨).\n\ní¬ì§€ì…˜ì´ ìˆìœ¼ë©´ ì•ˆì „ëª¨ë“œë¡œ ì „í™˜ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\nê³„ì†í• ê¹Œìš”?')) return;
        const prevText = restartLiveBtn.textContent;
        restartLiveBtn.disabled = true;
        restartLiveBtn.textContent = 'ì¬ì‹œì‘ ëª…ë ¹ ë¡œë”©ì¤‘...';
        try {
          const res = await fetch('/api/restart_live', { method: 'POST' });
          const data = await res.json().catch(() => ({}));
          if (!res.ok || !data.ok) {
            const msg = data.error || `HTTP ${res.status}`;
            throw new Error(msg);
          }
          const cmd = data.command || '';
          if (cmd) {
            // Copy to clipboard and show instructions
            await navigator.clipboard.writeText(cmd).catch(() => {});
            const msg = (
              `ì•„ë˜ ëª…ë ¹ì–´ë¥¼ í„°ë¯¸ë„ì— ë³µì‚¬í•´ì„œ ì‹¤í–‰í•˜ì„¸ìš”:\n\n` +
              `${cmd}\n\n` +
              `ëª…ë ¹ì–´ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
            );
            alert(msg);
          } else {
            alert('ì¬ì‹œì‘ ëª…ë ¹ì–´ë¥¼ ê°€ì ¸ì™”ìœ¼ë‚˜ ë‚´ìš©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
          }
        } catch (e) {
          alert(`ì¬ì‹œì‘ ëª…ë ¹ì–´ ì¡°íšŒ ì‹¤íŒ¨: ${e.message || e}`);
        } finally {
          restartLiveBtn.disabled = false;
          restartLiveBtn.textContent = prevText;
        }
      };
    }

    async function closeLimit(sym, px) {
      if (!sym) return;
      const defPx = isNum(px) ? Number(px).toFixed(4) : '';
      const val = prompt(`${sym} ì§€ì •ê°€ ì²­ì‚° ê°€ê²©`, defPx);
      if (val === null) return;
      const price = Number(val);
      if (!isNum(price) || price <= 0) {
        alert('ê°€ê²©ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return;
      }
      try {
        const res = await fetch('/api/close_limit', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ symbol: sym, price })
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data.ok) {
          const msg = data.error || `HTTP ${res.status}`;
          throw new Error(msg);
        }
        alert('ì§€ì •ê°€ ì²­ì‚° ì£¼ë¬¸ ìš”ì²­ ì™„ë£Œ');
      } catch (e) {
        alert(`ì§€ì •ê°€ ì²­ì‚° ì‹¤íŒ¨: ${e.message || e}`);
      }
    }

    // ---------- state ----------
    let selectedSym = null;
    // Default view: show symbols by rank (1 = best).
    let sortKey = 'rank';
    let sortAsc = true;
    let alphaDetailMode = (localStorage.getItem('alphaDetailMode') || 'off') === 'on';

    function setAlphaDetailMode(on) {
      alphaDetailMode = !!on;
      if (alphaDetailEl) {
        alphaDetailEl.textContent = alphaDetailMode ? 'ON' : 'OFF';
        alphaDetailEl.className = `v ${alphaDetailMode ? 'up' : 'muted'}`;
        alphaDetailEl.title = alphaDetailMode ? 'ALPHA ì»´í¬ë„ŒíŠ¸ ìƒì„¸ í‘œì‹œ (ë§¤ë§¤ ë¡œì§ ì˜í–¥ ì—†ìŒ)' : 'ALPHA ìš”ì•½ í‘œì‹œ (ë§¤ë§¤ ë¡œì§ ì˜í–¥ ì—†ìŒ)';
      }
      localStorage.setItem('alphaDetailMode', alphaDetailMode ? 'on' : 'off');
    }

    if (alphaDetailEl) {
      alphaDetailEl.onclick = () => {
        setAlphaDetailMode(!alphaDetailMode);
        if (latestPayload && latestPayload.market) {
          renderMarketTable(latestPayload.market);
        }
      };
      setAlphaDetailMode(alphaDetailMode);
    }

    // history for charts
    const maxPoints = 20000;
    const equityHist = []; // {t, equity}
    const liveEquityHist = []; // {t, equity}
    const sparkHist = new Map(); // sym -> [price...]
    const equityView = { windowKey: '6h', panPct: 0 };

    // trade tape
    const tradeTape = []; // {time,sym,type,side,price,pnl,roe,leverage,tag,reason,note}
    const seenTradeMsg = new Set();
    let equitySeeded = false;
    let liveEquitySeeded = false;

    // âœ… smoother rendering
    let latestPayload = null;
    let rafScheduled = false;
    let safetyReqInFlight = false;

    // âœ… market row cache for smooth update
    const rowCache = new Map(); // symbol -> {tr, cells[]}

    function refreshEquityView() {
      updateEquityChart();
      updateLiveEquityChart();
    }

    if (eqWindowSel) {
      eqWindowSel.value = equityView.windowKey;
      eqWindowSel.onchange = () => {
        equityView.windowKey = eqWindowSel.value || '6h';
        equityView.panPct = 0;
        if (eqPan) eqPan.value = 0;
        refreshEquityView();
      };
    }
    if (eqPan) {
      eqPan.oninput = () => {
        equityView.panPct = clamp(Number(eqPan.value || 0), 0, 1000);
        refreshEquityView();
      };
    }
    if (eqPanLeft) {
      eqPanLeft.onclick = () => {
        const step = 50;
        equityView.panPct = clamp((equityView.panPct || 0) + step, 0, 1000);
        if (eqPan) eqPan.value = equityView.panPct;
        refreshEquityView();
      };
    }
    if (eqPanRight) {
      eqPanRight.onclick = () => {
        const step = 50;
        equityView.panPct = clamp((equityView.panPct || 0) - step, 0, 1000);
        if (eqPan) eqPan.value = equityView.panPct;
        refreshEquityView();
      };
    }
    if (eqLatestBtn) {
      eqLatestBtn.onclick = () => {
        equityView.panPct = 0;
        if (eqPan) eqPan.value = 0;
        refreshEquityView();
      };
    }

    // ---------- helpers ----------
    const f2 = (x) => (x === null || x === undefined || isNaN(x)) ? '-' : Number(x).toFixed(2);
    const clamp = (a, lo, hi) => Math.max(lo, Math.min(hi, a));

    function isNum(x) { return x !== null && x !== undefined && !isNaN(Number(x)); }
    function coercePositions(positions) {
      if (!positions) return [];
      if (Array.isArray(positions)) return positions;
      if (typeof positions !== 'object') return [];
      const out = [];
      for (const [sym, pos] of Object.entries(positions)) {
        if (pos && typeof pos === 'object') {
          const rec = { ...pos };
          if (!rec.symbol) rec.symbol = sym;
          out.push(rec);
        } else {
          out.push({ symbol: sym });
        }
      }
      return out;
    }
    const escAttr = (s) => String(s)
      .replace(/&/g, '&amp;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    const fmtNum = (v, digits = 6) => (isNum(v) ? Number(v).toFixed(digits) : 'n/a');
    const fmtPct = (v, digits = 4) => (isNum(v) ? (Number(v) * 100).toFixed(digits) + '%' : 'n/a');
    const fmtUsd = (v) => (isNum(v) ? f2(v) : 'n/a');
    const fmtDeltaPp = (v, digits = 2) => {
      if (!isNum(v)) return '-';
      const n = Number(v) * 100;
      const sign = n > 0 ? '+' : '';
      return `${sign}${n.toFixed(digits)}%p`;
    };
    const fmtDeltaAbs = (v, digits = 4) => {
      if (!isNum(v)) return '-';
      const n = Number(v);
      const sign = n > 0 ? '+' : '';
      return `${sign}${n.toFixed(digits)}`;
    };
    function fmtHMSPrime(sec, maxSec = 3600) {
      if (!isNum(sec)) return '-';
      let s = Math.max(0, Math.round(Number(sec)));
      if (isNum(maxSec) && Number(maxSec) > 0) {
        s = Math.min(s, Math.round(Number(maxSec)));
      }
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      const mm = String(m).padStart(2, '0');
      const ss2 = String(ss).padStart(2, '0');
      return `${h}'${mm}'${ss2}`;
    }
    const shortTxt = (s, n = 80) => {
      const txt = (s === null || s === undefined) ? '' : String(s);
      if (!txt) return '';
      return txt.length > n ? `${txt.slice(0, n - 1)}â€¦` : txt;
    };

    // âœ… smooth number update (no design change)
    function smoothSetText(el, target, fmt = (v) => String(v), durMs = 260) {
      if (!isNum(target)) {
        el.textContent = fmt(target);
        el.dataset.v = '';
        return;
      }
      const to = Number(target);
      const from = isNum(el.dataset.v) ? Number(el.dataset.v) : to;
      if (from === to) {
        el.textContent = fmt(to);
        el.dataset.v = String(to);
        return;
      }
      const t0 = performance.now();
      const d = Math.max(80, durMs);
      const step = (t) => {
        const p = Math.min(1, (t - t0) / d);
        const e = 1 - Math.pow(1 - p, 3);
        const v = from + (to - from) * e;
        el.textContent = fmt(v);
        if (p < 1) requestAnimationFrame(step);
        else el.dataset.v = String(to);
      };
      requestAnimationFrame(step);
    }

    function normSym(s) { return (s || '').replace(':USDT', ''); }
    function statusClass(status) {
      if (status === 'LONG') return 'up';
      if (status === 'SHORT') return 'down';
      if (status === 'WAIT') return 'wait';
      return 'muted';
    }

    function exitKeyword(t) {
      const direct = (t.exit_tag || t.exit_kind || '').toString().toLowerCase();
      if (direct) return direct;
      const r = `${t.reason || ''} ${t.note || ''}`.toLowerCase();
      if (r.includes('event_mc')) return 'event_mc';
      if (r.includes('mc_exit') || r.includes('exit-policy')) return 'exit-policy';
      if (r.includes('ev_psl_ema')) return 'ema_psl';
      if (r.includes('ev_drop')) return 'ev_drop';
      if (r.includes('unrealized_dd') || r.includes('dd_stop')) return 'dd_stop';
      if (r.includes('score_flip') || r.includes('unified_flip')) return 'unified_flip';
      if (r.includes('unified_cash')) return 'unified_cash';
      if (r.includes('hold timeout') || r.includes('time_stop')) return 'time_stop';
      if (r.includes('rebalance')) return 'rebalance';
      if (r.includes('kill') || r.includes('emergency')) return 'kill';
      return '';
    }

    function exitBadge(tag) {
      if (!tag) return '<span class="pill muted">-</span>';
      const t = tag.toLowerCase();
      const cls = t.includes('kill') ? 'down' : (t.includes('event') ? 'wait' : '');
      return `<span class="pill ${cls}">${tag}</span>`;
    }

    // âœ… trade type badge (ENTER/EXIT/REBAL/SPREAD clearly visible)
    function tradeTypeBadge(type) {
      if (!type) return '<span class="pill muted">-</span>';
      const t = String(type).toUpperCase();
      if (t === 'ENTER') return '<span class="pill up">ENTER</span>';
      if (t === 'EXIT') return '<span class="pill down">EXIT</span>';
      if (t === 'REBAL') return '<span class="pill">REBAL</span>';
      if (t === 'REBALANCE') return '<span class="pill">REBAL</span>';
      if (t === 'SPREAD') return '<span class="pill wait">SPREAD</span>';
      if (t === 'PYRAMID') return '<span class="pill">PYRAMID</span>';
      if (t === 'KILL') return '<span class="pill down">KILL</span>';
      return `<span class="pill muted">${t}</span>`;
    }

    // Parse log lines like: "[BTC/USDT:USDT] ENTER LONG @ 42000.00"
    function parseTradeMsg(msg) {
      if (!msg) return null;
      const m = msg.match(/\\[(.+?)\\]\\s+(ENTER|EXIT|REBAL|REBALANCE|SPREAD|PYRAMID|KILL)\\s*(LONG|SHORT)?\\s*(?:@\\s*([0-9.]+))?/i);
      if (!m) return null;
      const sym = m[1];
      const type = (m[2] || '').toUpperCase();
      const side = (m[3] || '').toUpperCase();
      const price = m[4] ? Number(m[4]) : null;
      const pnlMatch = msg.match(/pnl=([-0-9.]+)/i);
      const roeMatch = msg.match(/roe=([-0-9.]+)/i);
      const pnl = pnlMatch ? Number(pnlMatch[1]) : null;
      const roe = roeMatch ? Number(roeMatch[1]) : null;
      return { sym, type, side, price, pnl, roe, note: msg };
    }

    // ---------- charts ----------
    const hasChart = (typeof Chart !== 'undefined');
    let equityChart = null;
    let liveEquityChart = null;
    if (hasChart) {
      equityChart = new Chart($('equityChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'Equity', data: [], pointRadius: 0, borderWidth: 2, tension: .25, borderColor: '#2563eb' },
          ]
        },
        options: {
          animation: false,
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: {
              display: true,
              ticks: { autoSkip: true, maxTicksLimit: 14 }
            },
            y: { ticks: { callback: (v) => v } }
          }
        }
      });

      liveEquityChart = new Chart($('liveEquityChart'), {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            { label: 'LIVE Equity', data: [], pointRadius: 0, borderWidth: 2, tension: .25, borderColor: '#10b981' },
          ]
        },
        options: {
          animation: false,
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: {
              display: true,
              ticks: { autoSkip: true, maxTicksLimit: 14 }
            },
            y: { ticks: { callback: (v) => v } }
          }
        }
      });
    } else {
      console.warn('Chart.js not loaded; charts disabled.');
    }

    function formatTimeLabel(ts, tfMin) {
      const d = new Date(ts);
      if (tfMin >= 1440) {
        return `${d.getMonth() + 1}/${d.getDate()}`;
      }
      if (tfMin >= 60) {
        return d.toLocaleString([], { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
      }
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function windowKeyToMs(key) {
      const k = String(key || '').toLowerCase();
      if (k === '1h') return 60 * 60 * 1000;
      if (k === '6h') return 6 * 60 * 60 * 1000;
      if (k === '12h') return 12 * 60 * 60 * 1000;
      if (k === '1d') return 24 * 60 * 60 * 1000;
      if (k === '3d') return 3 * 24 * 60 * 60 * 1000;
      if (k === '7d') return 7 * 24 * 60 * 60 * 1000;
      if (k === '30d') return 30 * 24 * 60 * 60 * 1000;
      if (k === 'all') return 0;
      return 6 * 60 * 60 * 1000;
    }

    function fmtDuration(ms) {
      if (!isNum(ms) || ms <= 0) return 'ì „ì²´';
      const sec = Math.floor(ms / 1000);
      const min = Math.floor(sec / 60);
      const hr = Math.floor(min / 60);
      const day = Math.floor(hr / 24);
      if (day >= 1) return `${day}ì¼`;
      if (hr >= 1) return `${hr}ì‹œê°„`;
      if (min >= 1) return `${min}ë¶„`;
      return `${sec}ì´ˆ`;
    }

    function fmtTs(ms) {
      if (!isNum(ms) || ms <= 0) return '-';
      return new Date(Number(ms)).toLocaleTimeString();
    }

    function normalizeHist(hist) {
      if (!Array.isArray(hist) || !hist.length) return;
      hist.sort((a, b) => (a.t || 0) - (b.t || 0));
      // dedupe same timestamp
      for (let i = hist.length - 2; i >= 0; i--) {
        if (hist[i].t === hist[i + 1].t) {
          hist[i] = hist[i + 1];
          hist.splice(i + 1, 1);
        }
      }
    }

    function computeViewWindow(hist, view) {
      if (!hist.length) return { startTs: 0, endTs: 0, windowMs: 0, maxOffset: 0, totalRange: 0 };
      const minTs = hist[0].t;
      const maxTs = hist[hist.length - 1].t;
      const totalRange = Math.max(0, maxTs - minTs);
      let windowMs = windowKeyToMs(view.windowKey);
      if (!windowMs || windowMs <= 0 || windowMs >= totalRange) {
        windowMs = totalRange;
      }
      const maxOffset = Math.max(0, totalRange - windowMs);
      const panPct = clamp(Number(view.panPct || 0), 0, 1000);
      const offsetMs = maxOffset * (panPct / 1000);
      const endTs = maxTs - offsetMs;
      const startTs = endTs - windowMs;
      return { startTs, endTs, windowMs, maxOffset, totalRange };
    }

    function buildEquitySeries(hist, view = equityView) {
      const tfMin = 1; // Fixed 1-minute timeframe
      const bucketMs = tfMin * 60 * 1000;
      if (!hist.length) return { labels: [], values: [] };
      normalizeHist(hist);
      const vw = computeViewWindow(hist, view);
      const startTs = vw.startTs;
      const endTs = vw.endTs;
      if (eqPan) {
        eqPan.disabled = (vw.maxOffset <= 0);
        if (vw.maxOffset <= 0) {
          equityView.panPct = 0;
          eqPan.value = 0;
        }
      }
      const buckets = new Map();
      hist.forEach(p => {
        if (p.t < startTs || p.t > endTs) return;
        const b = Math.floor(p.t / bucketMs);
        buckets.set(b, p);
      });
      const sorted = Array.from(buckets.entries()).sort((a, b) => a[0] - b[0]).map(e => e[1]);
      if (eqRangeLabel && hist.length) {
        const s = new Date(startTs);
        const e = new Date(endTs);
        const rangeTxt = `${s.toLocaleString()} ~ ${e.toLocaleString()} (${fmtDuration(vw.windowMs)})`;
        eqRangeLabel.textContent = rangeTxt;
        eqRangeLabel.title = `range=${fmtDuration(vw.windowMs)} | total=${fmtDuration(vw.totalRange)}`;
      }
      return {
        labels: sorted.map(p => formatTimeLabel(p.t, tfMin)),
        values: sorted.map(p => p.equity),
      };
    }

    function updateEquityChart(hist = equityHist) {
      if (!equityChart) return;
      const { labels, values } = buildEquitySeries(hist, equityView);
      equityChart.data.labels = labels;
      equityChart.data.datasets[0].data = values;
      equityChart.update('none');
    }

    function updateLiveEquityChart() {
      if (!liveEquityChart) return;
      const { labels, values } = buildEquitySeries(liveEquityHist, equityView);
      liveEquityChart.data.labels = labels;
      liveEquityChart.data.datasets[0].data = values;
      liveEquityChart.update('none');
    }

    function pushEquityPoint(t, equity) {
      if (!isNum(equity)) return;
      const last = equityHist[equityHist.length - 1];
      const bucket = Math.floor(t / 60000);
      const lastBucket = last ? Math.floor(last.t / 60000) : null;
      if (last && (last.t === t || lastBucket === bucket)) {
        last.t = t;
        last.equity = equity;
      } else {
        equityHist.push({ t, equity });
      }
      updateEquityChart();
    }

    function pushLiveEquityPoint(t, equity) {
      if (!isNum(equity)) return;
      const last = liveEquityHist[liveEquityHist.length - 1];
      const bucket = Math.floor(t / 60000);
      const lastBucket = last ? Math.floor(last.t / 60000) : null;
      if (last && (last.t === t || lastBucket === bucket)) {
        last.t = t;
        last.equity = equity;
      } else {
        liveEquityHist.push({ t, equity });
      }
      updateLiveEquityChart();
    }

    function pushSymPoint(sym, t, price) {
      if (!sparkHist.has(sym)) sparkHist.set(sym, []);
      const sp = sparkHist.get(sym);
      sp.push(price);
      if (sp.length > 60) sp.shift();
    }

    // ---------- rendering ----------
    function renderMarketTable(rows) {
      const q = (searchEl.value || '').trim().toLowerCase();

      const data = (rows || []).map(x => {
        const sym = normSym(x.symbol);
        const hybrid_score = (function () {
          if (x.hybrid_score !== undefined && x.hybrid_score !== null) return Number(x.hybrid_score);
          if (x.meta && x.meta.hybrid_score !== undefined && x.meta.hybrid_score !== null) return Number(x.meta.hybrid_score);
          if (Array.isArray(x.details)) {
            for (const d of x.details) {
              if (d && d.meta && d.meta.hybrid_score !== undefined) return Number(d.meta.hybrid_score);
            }
          }
          return 0;
        })();
        const scorep = hybrid_score * 100;
        const confp = (x.conf || 0) * 100;
        const mc_win = (x.mc_win_rate || 0) * 100;
        const pos_roe = (x.pos_roe || 0) * 100;
        const hybrid_score_hold = (x.hybrid_score_hold !== undefined && x.hybrid_score_hold !== null) ? Number(x.hybrid_score_hold) :
          (x.meta && x.meta.hybrid_score_hold !== undefined && x.meta.hybrid_score_hold !== null) ? Number(x.meta.hybrid_score_hold) : null;
        const hybrid_score_logw = (x.hybrid_score_logw !== undefined && x.hybrid_score_logw !== null) ? Number(x.hybrid_score_logw) :
          (x.meta && x.meta.hybrid_score_logw !== undefined && x.meta.hybrid_score_logw !== null) ? Number(x.meta.hybrid_score_logw) : null;

        const action_type =
          x.action_type ||
          (x.meta && (x.meta.action_type || x.meta.event || x.meta.trade_event)) ||
          '-';

        return {
          raw: x,
          symbol: sym,
          price: x.price ?? null,
          status: x.status || 'WAIT',
          regime: x.regime || '-',
          action_type: action_type || '-',
          filter_states: x.filter_states || (x.meta && x.meta.filter_states) || null,
          hybrid_score,
          hybrid_score_hold,
          hybrid_score_logw,
          scorep,
          confp,
          kelly: x.kelly ?? x.kelly_frac ?? null,
          pos_roe,
          pos_leverage: x.pos_leverage ?? null,
          decision_leverage: x.decision_leverage ?? (x.meta && x.meta.lev) ?? null,
          dyn_leverage: x.dyn_leverage ?? null,
          lev_source: x.lev_source ?? (x.meta && x.meta.lev_source) ?? null,
          top_n_active: (x.top_n_active ?? (x.meta && x.meta.top_n_active) ?? null),
          top_n_rank: (x.top_n_rank ?? (x.meta && x.meta.top_n_rank) ?? null),
          top_n_limit: (x.top_n_limit ?? (x.meta && x.meta.top_n_limit) ?? null),
        };
      }).filter(r => {
        if (!q) return true;
        const hay = `${r.symbol} ${r.status}`.toLowerCase();
        return hay.includes(q);
      });

      // compute score rank (fallback rank)
      data.forEach((d) => { d._score_for_rank = isNum(d.hybrid_score) ? d.hybrid_score : 0; });
      const byScore = data.slice().sort((a, b) => b._score_for_rank - a._score_for_rank);
      const scoreRankMap = new Map();
      byScore.forEach((d, i) => scoreRankMap.set(d.symbol, i + 1));
      data.forEach((d) => {
        const scoreRank = scoreRankMap.get(d.symbol) || null;
        d.score_rank = scoreRank;
        // Keep rank consistent with engine top_n gate when available.
        if (d.top_n_active === true && isNum(d.top_n_rank)) d.rank = Number(d.top_n_rank);
        else d.rank = scoreRank;
      });

      data.sort((a, b) => {
        const va = a[sortKey], vb = b[sortKey];
        const na = (va === null || va === undefined) ? -Infinity : va;
        const nb = (vb === null || vb === undefined) ? -Infinity : vb;
        if (na < nb) return sortAsc ? -1 : 1;
        if (na > nb) return sortAsc ? 1 : -1;
        return 0;
      });

      // âœ… smooth: reuse <tr> nodes, reorder with fragment
      const frag = document.createDocumentFragment();

      data.forEach(r => {
        let cached = rowCache.get(r.symbol);
        if (!cached) {
          const tr = document.createElement('tr');
          const cells = [];
          for (let i = 0; i < 18; i++) {  // í™•ì¥: 18ì—´ (ALPHA ì¶”ê°€)
            const td = document.createElement('td');
            cells.push(td);
            tr.appendChild(td);
          }
          tr.onclick = () => {
            selectedSym = r.symbol;
            selSymEl.textContent = selectedSym;
            renderMarketTable((latestPayload && latestPayload.market) ? latestPayload.market : rows);
          };
          cached = { tr, cells };
          rowCache.set(r.symbol, cached);
        }

        const tr = cached.tr;
        const c = cached.cells;

        if (selectedSym === r.symbol) tr.classList.add('sel');
        else tr.classList.remove('sel');

        const cls = statusClass(r.status);

        // Top-4 í‘œì‹œ: rank 1~4ëŠ” êµµê²Œ í‘œì‹œ
        const isTop4 = (r.rank !== null && r.rank !== undefined && r.rank <= 4);

        // column mapping: rank, symbol, price, status, filter, Ïˆ, Ïˆ_hold, t*, kelly, roe%, lev
        c[0].className = 'mono';
        c[0].innerHTML = isTop4 ? `<b style="color:var(--accent)">${r.rank}</b>` : (r.rank !== null && r.rank !== undefined ? String(r.rank) : '-');

        c[1].className = 'mono';
        c[1].innerHTML = `<b>${r.symbol}</b>`;

        c[2].className = 'mono';
        c[2].textContent = (r.price !== null ? f2(r.price) : '-');

        c[3].className = '';
        c[3].innerHTML = `<span class="pill ${cls}">${r.status}</span>`;

        // Minimal filter badges + tooltips
        c[4].className = '';
        const fs = r.filter_states || {};
        const m = r.raw || {};
        const badge = (label, ok, tip) => {
          const cls = (ok === undefined || ok === null) ? 'muted' : (ok ? 'up' : 'down');
          const title = tip ? ` title="${escAttr(tip)}"` : '';
          return `<span class="pill ${cls}"${title}>${label}</span>`;
        };
        const badges = [];
        const help = {
          HYB: 'HYB: hybrid score >= entry floor to allow entry',
          SPR: 'SPR: spread gap must be below cap',
          CV: 'CV: event CVaR risk must be below limit',
          EMC: 'EMC: event MC exit metrics within limits',
          NX: 'NX: net expectancy (EV-fee/slippage) must exceed dynamic floor',
          SQ: 'SQ: symbol quality (recent expectancy/hit/reject) must meet threshold',
          LIQ: 'LIQ: liquidity score must meet minimum',
          MIN: 'MIN: estimated notional must meet minimum',
          MEX: 'MEX: exposure notional must meet minimum',
          VOL: 'VOL: tick volatility must meet minimum',
          FEE: 'FEE: expected EV must cover roundtrip fee+slippage',
          TOP: 'TOP: only top-ranked symbols allowed',
          PMC: 'PMC: pre-MC portfolio gate (EV/CVaR/liq) must pass',
          CAP: 'CAP: safety/position/exposure cap must allow entry',
          SAFE: 'SAFE: safety mode off required',
          POS: 'POS: max positions not reached',
          EXP: 'EXP: total exposure below cap',
        };
        const hybFloor = (m.entry_floor_eff !== undefined && m.entry_floor_eff !== null) ? m.entry_floor_eff : m.unified_entry_floor;
        const hybTip = `${help.HYB} | score=${fmtNum(r.hybrid_score)} | floor=${fmtNum(hybFloor)} | min_entry_score=${fmtNum(m.min_entry_score)}`;
        const sprTip = `${help.SPR} | spread gap=${fmtPct(m.spread_pct)} | cap=${fmtPct(m.spread_cap)}`;
        const cvTip = (isNum(m.cvar_floor))
          ? `${help.CV} | event_cvar_r=${fmtNum(m.event_cvar_r, 4)} | floor=${fmtNum(m.cvar_floor, 4)}`
          : `${help.CV} | disabled`;
        const evtExitTip = (isNum(m.event_exit_score) || isNum(m.event_p_sl) || isNum(m.event_cvar_pct))
          ? `${help.EMC} | score=${fmtPct(m.event_exit_score, 4)} | EV%=${fmtPct(m.event_ev_pct, 4)} | CVaR%=${fmtPct(m.event_cvar_pct, 4)} | P_SL=${fmtPct(m.event_p_sl, 2)} | P_TP=${fmtPct(m.event_p_tp, 2)} | min_score=${fmtPct(m.event_exit_min_score, 4)} | max_cvar=${fmtPct(m.event_exit_max_cvar, 4)} | max_p_sl=${fmtPct(m.event_exit_max_p_sl, 2)} | min_p_tp=${fmtPct(m.event_exit_min_p_tp, 2)} | src=${(m.event_exit_eval_source ?? m.event_eval_source ?? 'n/a')} | pre_allow_now=${(m.event_precheck_allow_exit_now === undefined || m.event_precheck_allow_exit_now === null) ? 'n/a' : (m.event_precheck_allow_exit_now ? 'yes' : 'no')} | pre_guard=${(m.event_precheck_guard_reason ?? m.event_exit_guard ?? 'n/a')} | pre_confirm=${(m.event_precheck_confirm_mode ?? 'n/a')}:${(m.event_precheck_confirm_required ?? 'n/a')}/${(m.event_precheck_confirm_count ?? 'n/a')} | pre_t*= ${fmtNum(m.event_precheck_guard_remaining_sec ?? m.event_hold_remaining_sec, 1)}s`
          : `${help.EMC} | disabled`;
        const liqTip = (isNum(m.min_liq_score))
          ? `${help.LIQ} | liq_score=${fmtNum(m.liq_score, 2)} | min=${fmtNum(m.min_liq_score, 2)}`
          : `${help.LIQ} | disabled | score=${fmtNum(m.liq_score, 2)}`;
        const minTip = (isNum(m.min_entry_notional))
          ? `${help.MIN} | est_notional=${fmtUsd(m.est_notional)} | min=${fmtUsd(m.min_entry_notional)}`
          : `${help.MIN} | disabled | est_notional=${fmtUsd(m.est_notional)}`;
        const minExpTip = (isNum(m.min_entry_exposure_notional))
          ? `${help.MEX} | est_notional=${fmtUsd(m.est_notional)} | min=${fmtUsd(m.min_entry_exposure_notional)} | pct=${fmtPct(m.min_entry_exposure_pct, 3)}`
          : `${help.MEX} | disabled | est_notional=${fmtUsd(m.est_notional)}`;
        const volTip = (isNum(m.min_tick_vol))
          ? `${help.VOL} | tick_vol=${fmtNum(m.tick_vol, 6)} | min=${fmtNum(m.min_tick_vol, 6)}`
          : `${help.VOL} | disabled | tick_vol=${fmtNum(m.tick_vol, 6)}`;
        const feeTip = (isNum(m.fee_filter_cost) || isNum(m.fee_filter_ev))
          ? `${help.FEE} | ev=${fmtPct(m.fee_filter_ev, 4)} | ev_eff=${fmtPct(m.fee_filter_ev_eff, 4)} | lev=${fmtNum(m.fee_filter_lev, 2)} | cost=${fmtPct(m.fee_filter_cost, 4)} | base=${fmtPct(m.fee_filter_base, 4)} | mult=${fmtNum(m.fee_filter_mult, 2)}`
          : `${help.FEE} | disabled`;
        const netTip = (isNum(m.net_expectancy_effective) || isNum(m.net_expectancy_min))
          ? `${help.NX} | net=${fmtPct(m.net_expectancy_effective, 4)} | floor=${fmtPct(m.net_expectancy_min, 4)} | raw=${fmtPct(m.net_expectancy_raw, 4)} | fee=${fmtPct(m.net_expectancy_fee_cost, 4)} | vpin=${fmtNum(m.net_expectancy_vpin, 3)} | dir_conf=${fmtNum(m.net_expectancy_dir_conf, 3)}`
          : `${help.NX} | disabled`;
        const sqTip = (isNum(m.symbol_quality_score) || isNum(m.symbol_quality_min_score))
          ? `${help.SQ} | score=${fmtNum(m.symbol_quality_score, 3)} | min=${fmtNum(m.symbol_quality_min_score, 3)} | n=${(m.symbol_quality_sample_n ?? 'n/a')} | exp=${fmtPct(m.symbol_quality_expectancy, 4)} | hit=${fmtPct(m.symbol_quality_hit_rate, 2)} | reject=${fmtPct(m.symbol_quality_reject_ratio, 2)} | min_n=${(m.symbol_quality_min_exits ?? 'n/a')}`
          : `${help.SQ} | warming up`;
        const posTxt = (m.max_positions === null || m.max_positions === undefined)
          ? `${(m.positions_count ?? 'n/a')}/âˆ`
          : `${(m.positions_count ?? 'n/a')}/${m.max_positions}`;
        const expTxt = isNum(m.exposure_cap_limit)
          ? `${fmtUsd(m.total_open_notional)} / ${fmtUsd(m.exposure_cap_limit)}`
          : `cap off | open=${fmtUsd(m.total_open_notional)}`;
        const capTip = `${help.CAP} | safety=${m.safety_mode ? 'on' : 'off'} | positions=${posTxt} | exposure=${expTxt}`;
        const topTip = (!m.top_n_active)
          ? `${help.TOP} | inactive | score_rank=${(r.score_rank ?? 'n/a')}`
          : `${help.TOP} | rank=${(m.top_n_rank ?? 'n/a')} | limit=${(m.top_n_limit ?? 'n/a')} | score_rank=${(r.score_rank ?? 'n/a')}`;
        let pmcTip = '';
        if (!m.pre_mc_active) {
          pmcTip = `${help.PMC} | disabled`;
        } else {
          const expTxt = fmtPct(m.pre_mc_expected_pnl, 3);
          const cvarTxt = fmtPct(m.pre_mc_cvar, 3);
          const liqTxt = fmtPct(m.pre_mc_prob_liq, 3);
          const expSrc = m.pre_mc_expected_pnl_source ? `(${m.pre_mc_expected_pnl_source})` : '';
          const liqSrc = m.pre_mc_prob_liq_source ? `(${m.pre_mc_prob_liq_source})` : '';
          pmcTip = `${help.PMC} | exp_pnl=${expTxt}${expSrc} | cvar=${cvarTxt} | liq_prob=${liqTxt}${liqSrc} | min_exp=${fmtPct(m.pre_mc_min_expected_pnl, 3)} | min_cvar=${fmtPct(m.pre_mc_min_cvar, 3)} | max_liq=${fmtPct(m.pre_mc_max_liq_prob, 3)}`;
          if (m.pre_mc_reason) pmcTip += ` | reason=${m.pre_mc_reason}`;
          if (m.pre_mc_scaled) pmcTip += ` | size_scaled x${fmtNum(m.pre_mc_scale, 2)}`;
          if (m.pre_mc_block_on_fail) pmcTip += ' | block_on_fail=on';
        }

        // WAIT reason summary (blocked filters)
        const blocked = [];
        const blockedTips = [];
        const addBlocked = (label, tip) => {
          blocked.push(label);
          if (tip) blockedTips.push(`${label}: ${tip}`);
        };
        const entryBlocks = Array.isArray(m.entry_blocked_filters) ? m.entry_blocked_filters : null;
        const entryEval = (m.entry_filter_eval === true);
        const blockLabel = {
          unified: ['HYB', hybTip],
          spread: ['SPR', sprTip],
          event_cvar: ['CV', cvTip],
          event_mc_exit: ['EMC', evtExitTip],
          net_expectancy: ['NX', netTip],
          symbol_quality: ['SQ', sqTip],
          liquidity: ['LIQ', liqTip],
          min_notional: ['MIN', minTip],
          min_exposure: ['MEX', minExpTip],
          tick_vol: ['VOL', volTip],
          fee: ['FEE', feeTip],
          top_n: ['TOP', topTip],
          pre_mc: ['PMC', pmcTip],
          cap: ['CAP', capTip],
        };
        if (entryBlocks && entryBlocks.length) {
          entryBlocks.forEach(k => {
            const rec = blockLabel[k];
            if (rec) addBlocked(rec[0], rec[1]);
            else addBlocked(String(k).toUpperCase(), '');
          });
        } else if (entryEval) {
          if (fs.unified === false) addBlocked('HYB', hybTip);
          if (fs.spread === false) addBlocked('SPR', sprTip);
          if (fs.event_cvar === false) addBlocked('CV', cvTip);
          if (fs.event_exit === false) addBlocked('EMC', evtExitTip);
          if (fs.net_expectancy === false) addBlocked('NX', netTip);
          if (fs.symbol_quality === false) addBlocked('SQ', sqTip);
          if (fs.liq === false) addBlocked('LIQ', liqTip);
          if (fs.min_notional === false) addBlocked('MIN', minTip);
          if (fs.min_exposure === false) addBlocked('MEX', minExpTip);
          if (fs.tick_vol === false) addBlocked('VOL', volTip);
          if (fs.fee === false) addBlocked('FEE', feeTip);
          if (fs.top_n === false) addBlocked('TOP', topTip);
          if (fs.pre_mc === false) addBlocked('PMC', pmcTip);
          if (fs.cap === false) addBlocked('CAP', capTip);
          if (fs.cap_safety === false) addBlocked('SAFE', `${help.SAFE} | safety_mode=${m.safety_mode ? 'on' : 'off'}`);
          if (fs.cap_positions === false) addBlocked('POS', `${help.POS} | positions=${posTxt}`);
          if (fs.cap_exposure === false) addBlocked('EXP', `${help.EXP} | exposure=${expTxt}`);
        }

        let waitReasonHtml = '';
        if (r.status === 'WAIT') {
          if (blocked.length) {
            const blockedRaw = (entryBlocks && entryBlocks.length) ? entryBlocks.join(', ') : blocked.join(', ');
            const tip = escAttr(`${blockedTips.join(' | ')}${blockedTips.length ? ' | ' : ''}raw=${blockedRaw}`);
            const txt = escAttr(`filter_block: ${blockedRaw}`);
            waitReasonHtml = `<div class="wait-reason" title="${tip}">${txt}</div>`;
          } else {
            const altReason = r.raw.direction_reason || r.raw.mc || r.raw.reason;
            if (altReason && String(altReason).trim() && altReason !== '-') {
              const tip = escAttr(String(altReason));
              const txt = escAttr(`WAIT: ${String(altReason)}`);
              waitReasonHtml = `<div class="wait-reason muted" title="${tip}">${txt}</div>`;
            }
          }
        }
        if ('unified' in fs) badges.push(badge('HYB', fs.unified, hybTip));
        if ('spread' in fs) badges.push(badge('SPR', fs.spread, sprTip));
        if ('event_cvar' in fs) badges.push(badge('CV', fs.event_cvar, cvTip));
        if ('event_exit' in fs) badges.push(badge('EMC', fs.event_exit, evtExitTip));
        if ('net_expectancy' in fs) badges.push(badge('NX', fs.net_expectancy, netTip));
        if ('symbol_quality' in fs) badges.push(badge('SQ', fs.symbol_quality, sqTip));
        if ('liq' in fs) badges.push(badge('LIQ', fs.liq, liqTip));
        if ('min_notional' in fs) badges.push(badge('MIN', fs.min_notional, minTip));
        if ('min_exposure' in fs) badges.push(badge('MEX', fs.min_exposure, minExpTip));
        if ('tick_vol' in fs) badges.push(badge('VOL', fs.tick_vol, volTip));
        if ('fee' in fs) badges.push(badge('FEE', fs.fee, feeTip));
        if ('top_n' in fs) badges.push(badge('TOP', fs.top_n, topTip));
        if ('pre_mc' in fs) badges.push(badge('PMC', fs.pre_mc, pmcTip));
        if ('cap' in fs) badges.push(badge('CAP', fs.cap, capTip));
        if ('cap_safety' in fs) badges.push(badge('SAFE', fs.cap_safety, `${help.SAFE} | safety_mode=${m.safety_mode ? 'on' : 'off'}`));
        if ('cap_positions' in fs) badges.push(badge('POS', fs.cap_positions, `${help.POS} | positions=${posTxt}`));
        if ('cap_exposure' in fs) badges.push(badge('EXP', fs.cap_exposure, `${help.EXP} | exposure=${expTxt}`));
        const badgeHtml = badges.length ? badges.join(' ') : '<span class="pill muted">-</span>';
        c[4].innerHTML = waitReasonHtml + badgeHtml;

        c[5].className = 'mono';
        c[5].textContent = (isNum(r.hybrid_score) ? (Number(r.hybrid_score) * 100).toFixed(4) : '-');

        c[6].className = 'mono';
        c[6].textContent = (isNum(r.hybrid_score_hold) ? (Number(r.hybrid_score_hold) * 100).toFixed(4) : '-');

        c[7].className = 'mono';
        c[7].textContent = (isNum(r.hybrid_score_logw) ? Number(r.hybrid_score_logw).toFixed(4) : '-');

        c[8].className = 'mono';
        c[8].textContent = (r.kelly === null ? '-' : (isNum(r.kelly) ? f2(r.kelly) : r.kelly));

        c[9].className = `mono ${(r.pos_roe >= 0) ? 'up' : 'down'}`;
        c[9].textContent = (r.pos_roe === null || r.pos_roe === undefined) ? '-' : (isNum(r.pos_roe) ? r.pos_roe.toFixed(2) : r.pos_roe);

        c[10].className = 'mono';
        const optLev = isNum(r.raw.opt_leverage) ? r.raw.opt_leverage : (r.raw.meta && isNum(r.raw.meta.optimal_leverage) ? r.raw.meta.optimal_leverage : null);
        const levVal = (r.pos_leverage === null || r.pos_leverage === undefined) ? null : r.pos_leverage;
        const decLev = isNum(r.decision_leverage) ? r.decision_leverage : null;
        const dynLev = isNum(r.dyn_leverage) ? r.dyn_leverage : null;
        const levTxt = (levVal !== null)
          ? (isNum(levVal) ? levVal.toFixed(2) : levVal)
          : (decLev !== null)
            ? decLev.toFixed(2)
            : (dynLev !== null)
              ? dynLev.toFixed(2)
              : (optLev === null ? '-' : (isNum(optLev) ? optLev.toFixed(2) : optLev));
        c[10].textContent = levTxt;
        const liqPL = isNum(r.raw.liq_prob_long) ? r.raw.liq_prob_long : (r.raw.meta && isNum(r.raw.meta.liq_prob_long) ? r.raw.meta.liq_prob_long : null);
        const liqPS = isNum(r.raw.liq_prob_short) ? r.raw.liq_prob_short : (r.raw.meta && isNum(r.raw.meta.liq_prob_short) ? r.raw.meta.liq_prob_short : null);
        const liqPriceL = isNum(r.raw.liq_price_long) ? r.raw.liq_price_long : (r.raw.meta && isNum(r.raw.meta.liq_price_long) ? r.raw.meta.liq_price_long : null);
        const liqPriceS = isNum(r.raw.liq_price_short) ? r.raw.liq_price_short : (r.raw.meta && isNum(r.raw.meta.liq_price_short) ? r.raw.meta.liq_price_short : null);
        const levTips = [];
        if (decLev !== null) levTips.push(`dec=${decLev.toFixed(2)}x`);
        if (dynLev !== null) levTips.push(`dyn=${dynLev.toFixed(2)}x`);
        if (optLev !== null) levTips.push(`opt=${isNum(optLev) ? optLev.toFixed(2) : optLev}`);
        if (r.lev_source) levTips.push(`src=${r.lev_source}`);
        if (liqPL !== null || liqPS !== null) {
          levTips.push(`liqP(L/S)=${liqPL === null ? 'n/a' : fmtPct(liqPL, 2)}/${liqPS === null ? 'n/a' : fmtPct(liqPS, 2)}`);
        }
        if (liqPriceL !== null || liqPriceS !== null) {
          levTips.push(`liqPx(L/S)=${liqPriceL === null ? 'n/a' : f2(liqPriceL)}/${liqPriceS === null ? 'n/a' : f2(liqPriceS)}`);
        }
        if (levTips.length) c[10].title = levTips.join(' | ');

        // Rebalance decision badge
        c[11].className = '';
        const reb = r.rebalance_decision || null;
        if (reb === null) { c[11].innerHTML = '<span class="pill muted">-</span>'; }
        else if (reb === 'HOLD') { c[11].innerHTML = '<span class="pill wait">HOLD</span>'; }
        else if (reb === 'SWITCH') { c[11].innerHTML = '<span class="pill">SWITCH</span>'; }
        else { c[11].innerHTML = `<span class="pill muted">${reb}</span>`; }

        // REASON (Direction Policy Reason)
        c[12].className = 'muted';
        c[12].style.maxWidth = '440px';
        c[12].style.whiteSpace = 'normal';
        c[12].style.overflow = 'visible';
        c[12].style.textOverflow = 'clip';
        c[12].style.lineHeight = '1.25';
        const reason = (r.raw.reason && String(r.raw.reason).trim() && r.raw.reason !== '-')
          ? r.raw.reason
          : (r.raw.direction_reason || '-');
        c[12].title = reason; // Tooltip for full reason
        c[12].textContent = reason;

        // LS_SCORE (Long / Short / Threshold)
        c[13].className = 'mono';
        const sL = (r.raw.hybrid_score_long !== undefined && r.raw.hybrid_score_long !== null) ? r.raw.hybrid_score_long : r.raw.score_long;
        const sS = (r.raw.hybrid_score_short !== undefined && r.raw.hybrid_score_short !== null) ? r.raw.hybrid_score_short : r.raw.score_short;
        const sT = (r.raw.hybrid_entry_floor !== undefined && r.raw.hybrid_entry_floor !== null)
          ? r.raw.hybrid_entry_floor
          : (r.raw.meta && r.raw.meta.hybrid_entry_floor !== undefined ? r.raw.meta.hybrid_entry_floor : r.raw.score_threshold);
        if (isNum(sL) && isNum(sS) && isNum(sT)) {
          c[13].innerHTML = `<span class="${sL > sT ? 'up' : ''}" title="Hybrid Long Score">${(sL * 100).toFixed(4)}</span> / ` +
            `<span class="${sS > sT ? 'down' : ''}" title="Hybrid Short Score">${(sS * 100).toFixed(4)}</span> ` +
            `<small class="muted" title="Threshold">(>${(sT * 100).toFixed(4)})</small>`;
        } else {
          c[13].textContent = '-';
        }

        // Î”H (show as percentage if number)
        c[14].className = 'mono';
        c[14].textContent = (r.rebalance_delta_ev === null || r.rebalance_delta_ev === undefined) ? '-' : (isNum(r.rebalance_delta_ev) ? (Number(r.rebalance_delta_ev) * 100).toFixed(2) : r.rebalance_delta_ev);

        // Exec cost (bps) display
        c[15].className = 'mono';
        c[15].textContent = (r.rebalance_exec_cost === null || r.rebalance_exec_cost === undefined) ? '-' : (isNum(r.rebalance_exec_cost) ? f2(r.rebalance_exec_cost * 100) : r.rebalance_exec_cost);

        // Joint weight (fraction of leverage allocated)
        c[16].className = 'mono';
        c[16].textContent = (r.rebalance_weight === null || r.rebalance_weight === undefined) ? '-' : (isNum(r.rebalance_weight) ? (Number(r.rebalance_weight)).toFixed(4) : r.rebalance_weight);

        // Alpha components (mu_alpha + key signals)
        const muA = isNum(r.mu_alpha) ? Number(r.mu_alpha) : null;
        c[17].className = `mono ${muA === null ? 'muted' : (muA >= 0 ? 'up' : 'down')}`;
        const alphaText = (muA === null ? '-' : muA.toFixed(3));
        if (alphaDetailMode && muA !== null) {
          const kf = fmtNum(r.alpha_mu_kf, 3);
          const mlf = fmtNum(r.alpha_mlofi, 3);
          const ml = fmtNum(r.alpha_mu_ml, 3);
          const vp = fmtNum(r.alpha_vpin, 3);
          c[17].innerHTML = `<div>${alphaText}</div><div class="alpha-sub">KF ${kf} Â· MLF ${mlf} Â· ML ${ml} Â· VP ${vp}</div>`;
        } else {
          c[17].textContent = alphaText;
        }
        c[17].title = `mu_alpha=${fmtNum(r.mu_alpha, 4)} | raw=${fmtNum(r.mu_alpha_raw, 4)} | mlofi=${fmtNum(r.alpha_mlofi, 4)} | vpin=${fmtNum(r.alpha_vpin, 4)} | kf=${fmtNum(r.alpha_mu_kf, 4)} | hurst=${fmtNum(r.alpha_hurst, 3)} | ml=${fmtNum(r.alpha_mu_ml, 4)} | bayes=${fmtNum(r.alpha_mu_bayes, 4)} | ar=${fmtNum(r.alpha_mu_ar, 4)} | pf=${fmtNum(r.alpha_mu_pf, 4)} | ou=${fmtNum(r.alpha_mu_ou, 4)} | hawkes=${fmtNum(r.alpha_hawkes_boost, 4)} | sigma_garch=${fmtNum(r.alpha_sigma_garch, 4)}`;

        frag.appendChild(tr);
      });

      mktBody.replaceChildren(frag);

      if (!selectedSym && data.length) {
        selectedSym = data[0].symbol;
        selSymEl.textContent = selectedSym;
      }
    }

    function renderPositions(positions, marketRows, portfolio) {
      const bySym = new Map((marketRows || []).map(r => [normSym(r.symbol), r]));
      const balance = (portfolio && portfolio.balance !== undefined) ? Number(portfolio.balance) : null;
      const exposureCap = (portfolio && portfolio.utilization_cap !== undefined) ? Number(portfolio.utilization_cap) : null;
      const timePlaceholder = '--:--:--';
      const holdPairPlaceholder = `${timePlaceholder} / ${timePlaceholder}`;

      posBody.innerHTML = '';
      (positions || []).forEach(p => {
        const sym = normSym(p.symbol);
        const m = bySym.get(sym) || {};
        const side = p.side || m.status || '-';
        const entry = p.entry_price ?? p.entry ?? null;
        const cur = p.current ?? p.price ?? null;
        const pnl = p.pnl ?? null;

        const lev = p.leverage ?? (m.pos_leverage ?? 1.0);
        const notional = (p.notional !== undefined && p.notional !== null) ? Number(p.notional) : null;
        const baseNotional = (notional !== null && lev) ? (notional / (Number(lev) || 1.0)) : null;
        const pnlPctRaw = (entry && cur) ? ((side === 'LONG' ? (cur - entry) : (entry - cur)) / entry) : null;
        const roeUnlev = pnlPctRaw === null ? null : pnlPctRaw;
        let roeLev = (p.roe !== undefined && p.roe !== null) ? Number(p.roe) : null;
        if (roeLev === null) {
          roeLev = pnlPctRaw === null ? null : (pnlPctRaw * (lev ?? 1.0));
        }
        const pnlPct = (roeLev === null) ? null : (roeLev * 100);
        const pnlPctUnlev = (roeUnlev === null) ? null : (roeUnlev * 100);
        const cap = p.cap_frac !== undefined && p.cap_frac !== null ? Number(p.cap_frac) * 100 : null;
        const normalizeTsMs = (v) => {
          if (!isNum(v)) return null;
          let t = Number(v);
          if (!isFinite(t) || t <= 0) return null;
          if (t < 1e12) t = t * 1000;          // sec -> ms
          else if (t > 1e14) t = Math.floor(t / 1000); // us -> ms
          return t;
        };
        let age = isNum(p.age_sec) ? Number(p.age_sec) : null;
        if (age !== null && (!isFinite(age) || age < 0 || age > 86400 * 365 * 3)) {
          age = null;
        }
        if (age === null) {
          const entryMs = normalizeTsMs(p.entry_time ?? p.time ?? null);
          if (entryMs !== null) {
            age = Math.max(0, (Date.now() - entryMs) / 1000);
          }
        }
        const tEntry = (p.opt_hold_entry_sec !== undefined && p.opt_hold_entry_sec !== null)
          ? Number(p.opt_hold_entry_sec)
          : ((p.opt_hold_sec !== undefined && p.opt_hold_sec !== null) ? Number(p.opt_hold_sec) : null);
        const tNowAbs = (p.opt_hold_curr_sec !== undefined && p.opt_hold_curr_sec !== null)
          ? Number(p.opt_hold_curr_sec)
          : ((p.opt_hold_sec !== undefined && p.opt_hold_sec !== null) ? Number(p.opt_hold_sec) : tEntry);
        let tNowRem = (p.opt_hold_curr_remaining_sec !== undefined && p.opt_hold_curr_remaining_sec !== null)
          ? Number(p.opt_hold_curr_remaining_sec)
          : null;
        if ((tNowRem === null || isNaN(tNowRem)) && tNowAbs !== null && age !== null) {
          tNowRem = Math.max(0, Number(tNowAbs) - Number(age));
        }
        const clampH = (v, maxSec = 3600) => {
          if (v === null || v === undefined || isNaN(v)) return v;
          const n = Number(v);
          return Math.max(0, Math.min(n, maxSec));
        };
        const tNowAbsClamped = clampH(tNowAbs, 3600);
        const tNowRemClamped = clampH(tNowRem, 3600);
        const tEntryDisp = (tEntry === null || tEntry === undefined || isNaN(Number(tEntry)))
          ? timePlaceholder
          : fmtHMSPrime(clampH(tEntry, 3600), 3600);
        const tNowDispAbs = fmtHMSPrime(tNowAbsClamped, 3600);
        const tNowDispRem = fmtHMSPrime(tNowRemClamped, 3600);
        const tNowDisp = (tNowAbsClamped !== null && tNowAbsClamped !== undefined)
          ? `${tNowDispAbs} / ${tNowDispRem}`
          : holdPairPlaceholder;
        const tNowTitle = `t*=${fmtHMSPrime(tNowAbsClamped, 3600)} | remaining=${fmtHMSPrime(tNowRemClamped, 3600)} | raw=${isNum(tNowAbs) ? Number(tNowAbs).toFixed(0) : 'n/a'}s`;
        const holdEvalTs = (p.hold_eval_ts !== undefined && p.hold_eval_ts !== null) ? Number(p.hold_eval_ts) : null;
        const holdEvalAge = holdEvalTs ? Math.max(0, (Date.now() - holdEvalTs) / 1000) : null;
        const holdEvalDisp = holdEvalTs
          ? new Date(holdEvalTs).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false })
          : timePlaceholder;
        const holdEvalTip = holdEvalTs ? `ts=${holdEvalTs} | age=${holdEvalAge === null ? 'n/a' : Number(holdEvalAge).toFixed(0)}s` : '';
        const hPick = (p.hold_eval_h_pick !== undefined && p.hold_eval_h_pick !== null) ? Number(p.hold_eval_h_pick) : null;
        const hPickDisp = (hPick === null || isNaN(hPick)) ? timePlaceholder : fmtHMSPrime(hPick, 3600);

        const cls = (side === 'LONG') ? 'up' : (side === 'SHORT') ? 'down' : 'muted';
        const pnlCls = (pnl !== null && pnl < 0) ? 'down' : 'up';

        const tr = document.createElement('tr');
        const roeTip = `roe=${pnlPct === null ? 'n/a' : pnlPct.toFixed(2)}% | base=${baseNotional === null ? 'n/a' : f2(baseNotional)} | notional=${notional === null ? 'n/a' : f2(notional)} | lev=${lev === null ? 'n/a' : lev}`;
        let capTip = `cap=${cap === null ? 'n/a' : cap.toFixed(1)}%`;
        if (notional !== null && balance !== null) {
          capTip += ` | notional=${f2(notional)} | balance=${f2(balance)}`;
        }
        if (exposureCap !== null && balance !== null) {
          capTip += ` | exposure_cap=${f2(balance * exposureCap)}`;
        }
        const closePx = isNum(cur) ? Number(cur) : (isNum(entry) ? Number(entry) : null);
        const closeBtn = `<button class="btn warn mini" onclick="event.stopPropagation(); closeLimit(${JSON.stringify(sym)}, ${closePx === null ? 'null' : closePx});">LMT</button>`;
        tr.innerHTML = `
        <td class="mono"><b>${sym}</b></td>
        <td><span class="pill ${cls}">${side}</span></td>
        <td class="mono">${entry === null ? '-' : f2(entry)}</td>
        <td class="mono">${cur === null ? '-' : f2(cur)}</td>
        <td class="mono ${pnlCls}">${pnl === null ? '-' : f2(pnl)}</td>
        <td class="mono ${pnlPctUnlev !== null && pnlPctUnlev < 0 ? 'down' : 'up'}" title="${escAttr(roeTip)}">${pnlPctUnlev === null ? '-' : (pnlPctUnlev.toFixed(2) + '%')}</td>
        <td class="mono ${pnlPct !== null && pnlPct < 0 ? 'down' : 'up'}" title="${escAttr(roeTip)}">${pnlPct === null ? '-' : (pnlPct.toFixed(2) + '%')}</td>
        <td class="mono">${lev === null ? '-' : lev}</td>
        <td class="mono" title="${escAttr(capTip)}">${cap === null ? '-' : (cap.toFixed(2) + '%')}</td>
        <td class="mono">${age === null ? '-' : fmtHMSPrime(age, 0)}</td>
        <td class="mono">${tEntryDisp}</td>
        <td class="mono" title="${escAttr(tNowTitle)}">${tNowDisp}</td>
        <td class="mono" title="${escAttr(holdEvalTip)}">${holdEvalDisp}</td>
        <td class="mono">${hPickDisp}</td>
        <td class="mono">${closeBtn}</td>
      `;
        posBody.appendChild(tr);
      });

      if (!(positions || []).length) {
        posBody.innerHTML = `<tr><td class="muted" colspan="15">ì—´ë ¤ìˆëŠ” í¬ì§€ì…˜ ì—†ìŒ</td></tr>`;
      }

      if (posWrap) {
        const rowCount = Math.max(1, posBody.children.length || 1);
        let headH = 18;
        let rowH = 12;
        try {
          const headEl = posWrap.querySelector('thead');
          if (headEl) {
            const h = headEl.getBoundingClientRect().height;
            if (h && h > 0) headH = h;
          }
          const firstRow = posBody.querySelector('tr');
          if (firstRow) {
            const r = firstRow.getBoundingClientRect().height;
            if (r && r > 0) rowH = r;
          }
        } catch (e) { }
        const pad = 4;
        const totalH = Math.ceil(headH + (rowCount * rowH) + pad);
        posWrap.style.maxHeight = `${totalH}px`;
        posWrap.style.height = `${totalH}px`;
        posWrap.style.minHeight = `${totalH}px`;
        posWrap.style.overflow = 'visible';
      }
    }

    function renderArchivedPositions(outs) {
      if (!archBody) return;
      const list = Array.isArray(outs) ? outs.slice() : [];
      archBody.innerHTML = '';
      if (!list.length) {
        archBody.innerHTML = `<tr><td class="muted" colspan="7">ì•„ì¹´ì´ë¸Œëœ í¬ì§€ì…˜ ì—†ìŒ</td></tr>`;
        return;
      }
      list.sort((a, b) => (Number(b.archive_ts || 0) - Number(a.archive_ts || 0)));
      const frag = document.createDocumentFragment();
      list.forEach(o => {
        const tr = document.createElement('tr');
        const t = o.archive_ts ? new Date(Number(o.archive_ts)).toLocaleTimeString() : '-';
        const sym = o.symbol || '-';
        const side = o.side || '-';
        const qty = (o.quantity != null) ? fmtNum(o.quantity, 4) : '-';
        const entry = (o.entry_price != null) ? f2(o.entry_price) : '-';
        const notional = (o.notional != null) ? f2(o.notional) : '-';
        const src = o.archive_source || '-';
        tr.innerHTML = `
        <td class="mono">${t}</td>
        <td>${sym}</td>
        <td class="${side === 'LONG' ? 'up' : (side === 'SHORT' ? 'down' : 'muted')}">${side}</td>
        <td class="mono">${qty}</td>
        <td class="mono">${entry}</td>
        <td class="mono">${notional}</td>
        <td class="mono">${src}</td>
      `;
        frag.appendChild(tr);
      });
      archBody.replaceChildren(frag);
    }

    function renderTradeTape() {
      tradeBody.innerHTML = '';
      tradeTape.slice(-200).reverse().forEach(t => {
        const sym = t.sym || t.symbol;

        // âœ… TYPE í™•ì • ë¡œì§: payload ìš°ì„  â†’ ì—†ìœ¼ë©´ ë¬¸ìì—´ íŒŒì‹± fallback
        const findType = (txt) => { const m = (txt || '').match(/\\b(ENTER|EXIT|REBAL|REBALANCE|SPREAD|PYRAMID|KILL)\\b/i); return m ? m[1].toUpperCase() : null; };
        let ttype = (t.action_type || t.ttype || t.type || t.event || '').toString().toUpperCase();
        if (ttype === 'REBALANCE') ttype = 'REBAL';
        if (!ttype || ttype === '-') {
          ttype = findType(t.reason) || findType(t.note) || "-";
        }

        const side = (t.side || '').toUpperCase();
        const cls = (side === 'LONG') ? 'up' : (side === 'SHORT') ? 'down' : 'muted';

        const findPnl = (txt) => { const pm = (txt || '').match(/pnl=([-0-9.]+)/i); return pm ? Number(pm[1]) : null; };
        const findRoe = (txt) => { const rm = (txt || '').match(/roe=([-0-9.]+)/i); return rm ? Number(rm[1]) : null; };

        let pnl = (t.pnl !== undefined) ? t.pnl : null;
        let roe = (t.roe !== undefined) ? t.roe : null;

        if ((pnl === null || pnl === undefined)) pnl = findPnl(t.note) ?? findPnl(t.reason);
        if ((roe === null || roe === undefined)) roe = findRoe(t.note) ?? findRoe(t.reason);

        if ((pnl === null || pnl === undefined) && t.realized_r !== undefined && t.notional) {
          try { pnl = Number(t.realized_r) * Number(t.notional); } catch (e) { }
        }
        if ((roe === null || roe === undefined) && t.realized_r !== undefined) {
          try { roe = Number(t.realized_r); } catch (e) { }
        }

        const tr = document.createElement('tr');
        const exitTag = (ttype === 'EXIT') ? exitKeyword(t) : '';
        tr.innerHTML = `
        <td class="mono">${t.time || '-'}</td>
        <td class="mono"><b>${normSym(sym)}</b></td>
        <td>${tradeTypeBadge(ttype)}</td>
        <td><span class="pill ${cls}">${side || '-'}</span></td>
        <td class="mono">${t.price === null || t.price === undefined ? '-' : f2(t.price)}</td>
        <td class="mono ${(pnl !== null && pnl < 0) ? 'down' : 'up'}">${pnl === null || pnl === undefined ? '-' : f2(pnl)}</td>
        <td class="mono">${roe === null || roe === undefined ? '-' : (roe * 100).toFixed(2)}</td>
        <td class="mono">${t.leverage === null || t.leverage === undefined ? '-' : t.leverage}</td>
        <td>${exitBadge(exitTag)}</td>
        <td class="muted">${t.tag || ''} ${t.reason || t.note || ''}</td>
      `;
        tradeBody.appendChild(tr);
      });

      if (!tradeTape.length) {
        tradeBody.innerHTML = `<tr><td class="muted" colspan="10">ì•„ì§ íŠ¸ë ˆì´ë“œ ì´ë²¤íŠ¸ ì—†ìŒ (logsì—ì„œ ENTER/EXITê°€ ì°íˆë©´ ìë™ìœ¼ë¡œ ë“¤ì–´ì˜´)</td></tr>`;
      }
    }

    function updateTradeTapeFromLogs(logs) {
      (logs || []).forEach(l => {
        const key = `${l.time}|${l.msg}`;
        if (seenTradeMsg.has(key)) return;
        const p = parseTradeMsg(l.msg);
        if (!p) return;
        seenTradeMsg.add(key);
        tradeTape.push({ time: l.time, ...p });
        if (tradeTape.length > 1000) tradeTape.shift();
      });
      renderTradeTape();
    }

    function renderLogs(logs) {
      logsEl.innerHTML = '';
      (logs || []).slice(-250).forEach(l => {
        const lvl = (l.level || 'INFO').toUpperCase();
        logsEl.innerHTML += `<div>[${l.time}] <span class="muted">${lvl}</span> ${l.msg}</div>`;
      });
    }

    function renderMcHealth(h) {
      if (!h || !h.checks) {
        mcHealthValEl.textContent = '-';
        mcHealthValEl.className = 'v muted';
        if (mcHealthPanelEl) mcHealthPanelEl.style.display = 'none';
        return;
      }
      const allOk = h.all_ok;
      const checks = h.checks || [];
      const fixes = h.fixes_applied || [];
      const nCrit = checks.filter(c => c.status === 'CRITICAL').length;
      const nWarn = checks.filter(c => c.status === 'WARN').length;

      // chip
      if (allOk) {
        mcHealthValEl.textContent = 'âœ… OK';
        mcHealthValEl.className = 'v up';
        mcHealthChipEl.style.borderColor = '';
      } else if (nCrit > 0) {
        mcHealthValEl.textContent = `âŒ ${nCrit}C ${nWarn}W`;
        mcHealthValEl.className = 'v down';
        mcHealthChipEl.style.borderColor = '#e74c3c';
      } else {
        mcHealthValEl.textContent = `âš ï¸ ${nWarn}W`;
        mcHealthValEl.className = 'v wait';
        mcHealthChipEl.style.borderColor = '#f39c12';
      }

      // panel visibility
      if (mcHealthPanelEl) mcHealthPanelEl.style.display = '';

      // timestamp
      if (mcHealthTsEl && h.timestamp_ms) {
        mcHealthTsEl.textContent = new Date(h.timestamp_ms).toLocaleTimeString() + ` (${h.n_symbols || '?'} syms)`;
      }

      // detail
      let html = '';
      if (fixes.length) {
        html += `<div style="margin-bottom:6px;"><span class="pill up">AUTO-FIX</span> `;
        html += fixes.map(f => `<span class="mono">${f}</span>`).join(', ') + '</div>';
      }
      checks.forEach(c => {
        const st = c.status || 'OK';
        const cls = st === 'CRITICAL' ? 'down' : (st === 'WARN' ? 'wait' : (st === 'OK' ? 'up' : 'muted'));
        const icon = st === 'OK' ? 'âœ…' : (st === 'CRITICAL' ? 'âŒ' : (st === 'WARN' ? 'âš ï¸' : 'â„¹ï¸'));
        html += `<div>${icon} <span class="pill ${cls}">${st}</span> <b>${c.name}</b> ${c.msg || ''}</div>`;
      });
      if (mcHealthDetailEl) mcHealthDetailEl.innerHTML = html;
    }

    function renderMcSanity(s) {
      const el = document.getElementById('mc-sanity-panel');
      if (!el) return;
      if (!s || !s.alerts) {
        el.style.display = 'none';
        return;
      }
      el.style.display = '';
      const nCrit = s.critical_count || 0;
      const nWarn = s.warn_count || 0;
      const fixes = s.fixes_applied || [];
      const sum = s.summary || {};
      const alerts = s.alerts || [];
      const trendIcon = sum.trend_ev === 'deteriorating' ? 'ğŸ“‰' : (sum.trend_ev === 'recovering' ? 'ğŸ“ˆ' : 'â–');

      let html = `<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:6px;">`;
      // Status chip
      if (nCrit > 0) {
        html += `<span class="pill down">ğŸš¨ ${nCrit} CRITICAL</span>`;
      }
      if (nWarn > 0) {
        html += `<span class="pill wait">âš ï¸ ${nWarn} WARN</span>`;
      }
      if (nCrit === 0 && nWarn === 0) {
        html += `<span class="pill up">âœ… OK</span>`;
      }
      // Summary stats
      html += `<span class="chip"><span class="l">EV</span><span class="v ${sum.ev_mean >= 0 ? 'up' : 'down'}">${(sum.ev_mean * 100).toFixed(3)}%</span></span>`;
      html += `<span class="chip"><span class="l">EV+</span><span class="v">${(sum.ev_pos_ratio * 100).toFixed(0)}%</span></span>`;
      html += `<span class="chip"><span class="l">|Î¼|</span><span class="v">${sum.mu_abs_mean?.toFixed(3) || '-'}</span></span>`;
      html += `<span class="chip"><span class="l">Ïƒ</span><span class="v">${sum.sigma_mean?.toFixed(3) || '-'}</span></span>`;
      html += `<span class="chip"><span class="l">Cost</span><span class="v">${((sum.cost_mean || 0) * 10000).toFixed(1)}bp</span></span>`;
      html += `<span class="chip"><span class="l">Gap</span><span class="v ${(sum.edge_gap_mean || 0) >= 0 ? 'up' : 'down'}">${((sum.edge_gap_mean || 0) * 10000).toFixed(1)}bp</span></span>`;
      html += `<span class="chip"><span class="l">Trend</span><span class="v">${trendIcon}</span></span>`;
      html += `</div>`;

      if (fixes.length) {
        html += `<div style="margin-bottom:4px;"><span class="pill up">AUTO-TUNE</span> `;
        html += fixes.map(f => `<span class="mono" style="font-size:11px;">${f}</span>`).join(', ') + '</div>';
      }

      // Alert details
      if (alerts.length) {
        html += `<div style="max-height:120px;overflow-y:auto;">`;
        alerts.forEach(a => {
          const cls = a.severity === 'CRITICAL' ? 'down' : (a.severity === 'WARN' ? 'wait' : 'muted');
          const icon = a.severity === 'CRITICAL' ? 'ğŸš¨' : 'âš ï¸';
          html += `<div style="font-size:11px;">${icon} <span class="pill ${cls}" style="font-size:10px;">${a.severity}</span> <b>${a.metric}</b> `;
          if (a.symbol && a.symbol !== 'ALL') html += `<span class="mono">${a.symbol}</span> `;
          html += `${a.message}</div>`;
        });
        html += `</div>`;
      }

      el.innerHTML = html;
    }

    function renderAlerts(alerts) {
      alertsEl.innerHTML = '';
      (alerts || []).slice(-200).reverse().forEach(a => {
        const sev = (a.severity || 'info').toUpperCase();
        const ts = a.ts ? new Date(a.ts).toLocaleTimeString() : '-';
        const msg = a.message || '';
        const kind = a.kind || '-';
        const cls = sev === 'CRITICAL' ? 'down' : (sev === 'WARN' ? 'wait' : 'muted');
        alertsEl.innerHTML += `<div>[${ts}] <span class="pill ${cls}">${sev}</span> <span class="mono">${kind}</span> ${msg}</div>`;
      });
      if (!(alerts || []).length) {
        alertsEl.innerHTML = `<div class="muted">ì•Œë¦¼ ì—†ìŒ</div>`;
      }
    }

    // Sorting
    document.querySelectorAll('#mktTable thead th').forEach(th => {
      th.addEventListener('click', () => {
        const k = th.dataset.k;
        if (!k) return;
        if (sortKey === k) sortAsc = !sortAsc;
        else { sortKey = k; sortAsc = true; }
        if (latestPayload && latestPayload.market) renderMarketTable(latestPayload.market);
      });
    });

    searchEl.addEventListener('input', () => {
      if (latestPayload && latestPayload.market) renderMarketTable(latestPayload.market);
    });

    function applyUpdate(d) {
      if (d.type !== 'full_update') return;
      const eng = d.engine || {};

      // topbar
      const ksOn = !!(d.kill_switch || (d.engine && d.engine.safety_mode));
      ksEl.textContent = ksOn ? 'ON' : 'OFF';
      ksEl.className = `v ${ksOn ? 'on' : 'off'}`;
      if (clearSafetyBtn) {
        if (!safetyReqInFlight) {
          clearSafetyBtn.disabled = !ksOn;
          clearSafetyBtn.textContent = ksOn ? 'ì•ˆì „ëª¨ë“œ í•´ì œ' : 'ì•ˆì „ëª¨ë“œ OFF';
          clearSafetyBtn.title = ksOn ? 'ì•ˆì „ëª¨ë“œ í•´ì œ (ê¸°ì¤€ìë³¸ ë¦¬ì…‹)' : 'ì•ˆì „ëª¨ë“œ ë¹„í™œì„± ìƒíƒœ';
        } else {
          clearSafetyBtn.disabled = true;
        }
      }

      const equity = Number((d.portfolio && d.portfolio.equity) || 0);
      const liveEquityRaw = d.portfolio ? d.portfolio.live_equity : null;
      const liveEquityVal = isNum(liveEquityRaw) ? Number(liveEquityRaw) : null;
      const recordMode = (eng && eng.record_mode) ? String(eng.record_mode).toLowerCase() : '';
      const useLiveEq = (recordMode === 'live') && (liveEquityVal !== null);
      const equityDisplay = useLiveEq ? liveEquityVal : equity;
      smoothSetText(eqEl, equityDisplay, (v) => Number(v).toFixed(2), 260);
      if (eqEl) {
        if (useLiveEq) {
          eqEl.title = `LIVE equity=${equityDisplay.toFixed(2)}`;
        } else if (liveEquityVal !== null) {
          const delta = equity - liveEquityVal;
          eqEl.title = `model=${equity.toFixed(2)} | live=${liveEquityVal.toFixed(2)} | Î”=${delta.toFixed(2)}`;
        } else {
          eqEl.title = '';
        }
      }

      wsEl.textContent = (eng && eng.ws_clients !== undefined) ? eng.ws_clients : '-';
      feedEl.textContent = (d.feed && d.feed.connected) ? 'OK' : 'STALE';

      if (mcTimeEl) {
        const mcMs = eng.mc_last_ms;
        if (mcMs === null || mcMs === undefined || isNaN(Number(mcMs))) {
          mcTimeEl.textContent = '-';
          mcTimeEl.className = 'v muted';
        } else {
          const msNum = Number(mcMs);
          mcTimeEl.textContent = msNum >= 1000 ? `${(msNum / 1000).toFixed(2)}s` : `${Math.round(msNum)}ms`;
          const st = eng.mc_status || 'ok';
          mcTimeEl.className = `v ${st === 'ok' ? 'up' : (st === 'timeout' ? 'down' : 'wait')}`;
        }
        const ctxs = eng.mc_last_ctxs;
        const status = eng.mc_status || 'n/a';
        const ts = eng.mc_last_ts;
        const tsText = ts ? new Date(ts).toLocaleTimeString() : '-';
        mcTimeEl.title = `status=${status}` + (ctxs != null ? ` | ctxs=${ctxs}` : '') + ` | ts=${tsText}`;
      }
      if (mcDevEl) {
        const backend = eng.mc_backend;
        const dev = eng.mc_device;
        if (!backend && !dev) {
          mcDevEl.textContent = '-';
          mcDevEl.className = 'v muted';
        } else {
          mcDevEl.textContent = backend ? `${backend}:${dev || '-'}` : (dev || '-');
          const devLower = String(dev || '').toLowerCase();
          const isGpu = devLower.includes('cuda') || devLower.includes('mps');
          mcDevEl.className = `v ${isGpu ? 'up' : (devLower ? 'wait' : 'muted')}`;
        }
      }

      const utilVal = (d.portfolio && d.portfolio.utilization !== undefined) ? d.portfolio.utilization : null;
      const utilCap = d.portfolio ? d.portfolio.utilization_cap : null;
      utilEl.textContent = utilVal === null ? '-' : (utilVal * 100).toFixed(1) + '%' + (utilCap ? `/${(utilCap * 100).toFixed(0)}%` : '');

      const evalm = d.eval_metrics || {};
      brierEl.textContent = evalm.brier === null || evalm.brier === undefined ? '-' : evalm.brier.toFixed(4);
      hitEl.textContent = evalm.hit_rate === null || evalm.hit_rate === undefined ? '-' : (evalm.hit_rate * 100).toFixed(1) + '%';

      // Alpha Hit ML ìƒíƒœ í‘œì‹œ
      const ah = d.alpha_hit || {};
      if (alphaHitEl) {
        const ahOn = ah.enabled === true;
        alphaHitEl.textContent = ahOn ? `ON (Î²=${(ah.beta || 1).toFixed(2)})` : 'OFF';
        alphaHitEl.className = `v ${ahOn ? 'up' : 'muted'}`;
        const reason = ah.disable_reason ? ` | reason=${ah.disable_reason}` : '';
        alphaHitEl.title = ahOn ? `min_buffer=${ah.min_buffer || '-'}` : `Alpha Hit ML ë¹„í™œì„±í™”${reason}`;
      }
      if (alphaBstEl) {
        const bstOn = ah.signal_boost === true;
        alphaBstEl.textContent = bstOn ? `ON (cap=${(ah.mu_alpha_cap || 5).toFixed(0)})` : 'OFF';
        alphaBstEl.className = `v ${bstOn ? 'up' : 'muted'}`;
        alphaBstEl.title = bstOn ? `alpha_scaling=${(ah.alpha_scaling_factor || 1).toFixed(1)}x` : 'Signal Boost ë¹„í™œì„±í™”';
      }
      if (alphaBufEl) {
        if (ah.enabled) {
          let buf = Number(ah.buffer_size ?? 0);
          if (Number.isNaN(buf)) buf = 0;
          const minBuf = Number(ah.min_buffer ?? 0);
          const warmupDone = ah.warmup_done === true || (minBuf > 0 && buf >= minBuf);
          const totalSamples = Number(ah.total_samples ?? buf);
          const display = minBuf > 0 ? `${buf}/${minBuf}` : `${buf}`;
          alphaBufEl.textContent = display;
          alphaBufEl.title = `buffer=${buf} samples | total=${totalSamples} | warmup=${warmupDone ? 'ready' : 'pending'}`;
          const state = warmupDone ? 'up' : buf > 0 ? 'wait' : 'muted';
          alphaBufEl.className = `v ${state}`;
        } else {
          alphaBufEl.textContent = '-';
          alphaBufEl.title = 'Alpha Hit ML ë¹„í™œì„±í™”';
          alphaBufEl.className = 'v muted';
        }
      }
      if (alphaLossEl) {
        if (ah.enabled && ah.last_loss != null) {
          const loss = Number(ah.last_loss);
          const ema = ah.ema_loss != null ? Number(ah.ema_loss) : null;
          const lossText = `L=${loss.toFixed(4)}`;
          const emaText = ema != null ? ` EMA=${ema.toFixed(4)}` : '';
          alphaLossEl.textContent = `${lossText}${emaText}`;
          alphaLossEl.title = `train_steps=${ah.total_train_steps || 0}`;
          alphaLossEl.className = `v ${loss < 0.15 ? 'up' : 'wait'}`;
        } else if (ah.enabled) {
          alphaLossEl.textContent = 'pending';
          alphaLossEl.title = 'í›ˆë ¨ ëŒ€ê¸° ì¤‘';
          alphaLossEl.className = 'v wait';
        } else {
          alphaLossEl.textContent = '-';
          alphaLossEl.title = 'Alpha Hit ML ë¹„í™œì„±í™”';
          alphaLossEl.className = 'v muted';
        }
      }
      if (alphaReplayEl) {
        if (ah.replay_path) {
          const exists = ah.replay_exists === true;
          const sizeKb = ah.replay_size_bytes != null ? `${(Number(ah.replay_size_bytes) / 1024).toFixed(1)}KB` : '??';
          alphaReplayEl.textContent = exists ? `ok ${sizeKb}` : 'missing';
          alphaReplayEl.title = `${exists ? 'replay loaded' : 'replay missing'} | ${ah.replay_path} | save_every=${ah.replay_save_every || '-'}`;
          alphaReplayEl.className = `v ${exists ? 'up' : 'muted'}`;
        } else {
          alphaReplayEl.textContent = '-';
          alphaReplayEl.title = 'Replay path ì„¤ì • í•„ìš”';
          alphaReplayEl.className = 'v muted';
        }
      }

      // Alpha weight training status (MLOFI/CAUSAL)
      const aw = d.alpha_weights || {};
      if (alphaWgtEl) {
        const collectOn = aw.collect_enabled === true;
        const trainOn = aw.train_enabled === true;
        const trig = Number(aw.trigger_new_exits ?? NaN);
        const prog = Number(aw.new_exits_since_last_train ?? NaN);
        const readyForce = aw.force_train_ready === true;
        const progTxt = (isNum(prog) && isNum(trig) && trig > 0) ? `${Math.round(prog)}/${Math.round(trig)}` : '-';
        alphaWgtEl.textContent = (collectOn || trainOn) ? `${collectOn ? 'C' : '-'}${trainOn ? 'T' : '-'} ${progTxt}` : 'OFF';
        alphaWgtEl.className = `v ${(collectOn || trainOn) ? (readyForce ? 'wait' : 'up') : 'muted'}`;
        alphaWgtEl.title = `collect=${collectOn} train=${trainOn} | min_samples=${aw.min_samples || '-'} | ridge=${aw.ridge_lambda || '-'} | save=${fmtTs(aw.last_save_ms)} | train=${fmtTs(aw.last_train_ms)} | exit_trigger=${progTxt} | force_ready=${readyForce} | last_reason=${aw.last_train_reason || '-'}`;
      }
      if (alphaMlofiEl) {
        const minS = Number(aw.min_samples ?? 0);
        const samples = Number(aw.mlofi_samples ?? 0);
        const exists = aw.mlofi_weight_exists === true;
        const display = minS > 0 ? `${samples}/${minS}` : `${samples}`;
        alphaMlofiEl.textContent = exists ? `ok ${display}` : display;
        const state = exists ? 'up' : (minS > 0 && samples >= minS ? 'wait' : 'muted');
        alphaMlofiEl.className = `v ${state}`;
        alphaMlofiEl.title = `weights=${exists ? 'ok' : 'missing'} | last_train=${fmtTs(aw.last_train_ms)} | path=${aw.mlofi_weight_path || '-'}`;
      }
      if (alphaCausalEl) {
        const minS = Number(aw.min_samples ?? 0);
        const samples = Number(aw.causal_samples ?? 0);
        const exists = aw.causal_weight_exists === true;
        const display = minS > 0 ? `${samples}/${minS}` : `${samples}`;
        alphaCausalEl.textContent = exists ? `ok ${display}` : display;
        const state = exists ? 'up' : (minS > 0 && samples >= minS ? 'wait' : 'muted');
        alphaCausalEl.className = `v ${state}`;
        alphaCausalEl.title = `weights=${exists ? 'ok' : 'missing'} | last_train=${fmtTs(aw.last_train_ms)} | path=${aw.causal_weight_path || '-'}`;
      }
      if (newClosedCumEl || newClosedBatchEl) {
        const rv = d.reval || {};
        const newClosedBatch = Number(rv.new_closed_total_batch ?? rv.new_closed_total ?? NaN);
        const newClosedCum = Number(rv.new_closed_total_cum ?? NaN);
        const targetMin = Number(rv.target_min ?? NaN);
        const targetMax = Number(rv.target_max ?? NaN);
        const baseline = Number(rv.baseline_closed ?? NaN);
        const anchor = Number(rv.anchor_closed ?? NaN);
        const closedTotal = Number(rv.closed_total ?? NaN);
        const remaining = Number(rv.remaining_to_min ?? NaN);
        const ready = rv.ready === true;
        const hasCum = isNum(newClosedCum);
        const hasBatch = isNum(newClosedBatch) && isNum(targetMin) && targetMin > 0;
        const targetTxt = isNum(targetMax) ? `${Math.round(targetMin)}~${Math.round(targetMax)}` : `${Math.round(targetMin)}`;
        const remTxt = isNum(remaining) ? Math.max(0, Math.round(remaining)) : '-';
        const baseTxt = isNum(baseline) ? Math.round(baseline) : '-';
        const ancTxt = isNum(anchor) ? Math.round(anchor) : '-';
        const curTxt = isNum(closedTotal) ? Math.round(closedTotal) : '-';

        if (newClosedCumEl) {
          if (hasCum) {
            const cumTxt = `${Math.round(newClosedCum)}`;
            newClosedCumEl.textContent = cumTxt;
            if (Math.round(newClosedCum) > 0) newClosedCumEl.className = 'v wait';
            else newClosedCumEl.className = 'v muted';
            newClosedCumEl.title = `ëˆ„ì  ì‹ ê·œ ì²­ì‚° ê±´ìˆ˜(ë¦¬ì…‹ ì—†ìŒ)\ní˜„ì¬ ëˆ„ì =${cumTxt}\nanchor=${ancTxt}, baseline=${baseTxt}, current=${curTxt}`;
          } else {
            newClosedCumEl.textContent = '-';
            newClosedCumEl.className = 'v muted';
            newClosedCumEl.title = 'ëˆ„ì  ì‹ ê·œ ì²­ì‚° ì¹´ìš´íŠ¸ ì •ë³´ ì—†ìŒ';
          }
        }
        if (newClosedBatchEl) {
          if (hasBatch) {
            const batchTxt = `${Math.round(newClosedBatch)}`;
            newClosedBatchEl.textContent = `${batchTxt}/${Math.round(targetMin)}`;
            if (ready) newClosedBatchEl.className = 'v up';
            else if (Math.round(newClosedBatch) > 0) newClosedBatchEl.className = 'v wait';
            else newClosedBatchEl.className = 'v muted';
            newClosedBatchEl.title = `í˜„ì¬ ë°°ì¹˜ ì‹ ê·œ ì²­ì‚° ì§„í–‰ë¥ (REVAL_TARGET_MIN_NEW_CLOSED ê¸°ì¤€)\nì§„í–‰=${batchTxt}/${Math.round(targetMin)}\nëª©í‘œë²”ìœ„=${targetTxt}, ë‚¨ì€ìˆ˜=${remTxt}`;
          } else {
            newClosedBatchEl.textContent = '-';
            newClosedBatchEl.className = 'v muted';
            newClosedBatchEl.title = 'ë°°ì¹˜ ì‹ ê·œ ì²­ì‚° ì§„í–‰ë¥  ì •ë³´ ì—†ìŒ';
          }
        }
      }
      if (autoRevalEl) {
        const ar = d.auto_reval || {};
        const rptReady = Number(ar.reports_ready ?? NaN);
        const rptTotal = Number(ar.reports_total ?? NaN);
        const ready = ar.ready === true;
        const exists = ar.exists === true;
        const newClosed = Number(ar.new_closed_total ?? NaN);
        const newClosedCum = Number(ar.new_closed_total_cum ?? NaN);
        const targetNew = Number(ar.target_new ?? NaN);
        const remain = Number(ar.remaining_to_target ?? NaN);
        const doneBatch = Number(ar.completed_batches ?? NaN);
        const doneReports = Number(ar.completed_reports_total ?? NaN);
        const lrAvail = ar.last_ready_available === true;
        const lrNewClosed = Number(ar.last_ready_new_closed_total ?? NaN);
        const lrClosedTotal = Number(ar.last_ready_closed_total ?? NaN);
        const lrReportsOk = Number(ar.last_ready_reports_ok ?? NaN);
        const lrTs = Number(ar.last_ready_timestamp ?? NaN);
        const staleSec = Number(ar.stale_sec ?? NaN);
        if (isNum(rptReady) && isNum(rptTotal) && rptTotal > 0) {
          const batchTxt = isNum(doneBatch) ? ` B${Math.max(0, Math.round(doneBatch))}` : '';
          autoRevalEl.textContent = `${Math.round(rptReady)}/${Math.round(rptTotal)}${batchTxt}`;
          if (ready && rptReady >= rptTotal) autoRevalEl.className = 'v up';
          else if (exists) autoRevalEl.className = 'v wait';
          else autoRevalEl.className = 'v muted';
          const freshTxt = isNum(staleSec) ? `${staleSec.toFixed(0)}ì´ˆ ì „` : '-';
          const newTxt = isNum(newClosed) ? `${Math.round(newClosed)}` : '-';
          const newCumTxt = isNum(newClosedCum) ? `${Math.round(newClosedCum)}` : '-';
          const tgtTxt = isNum(targetNew) ? `${Math.round(targetNew)}` : '-';
          const remTxt = isNum(remain) ? `${Math.max(0, Math.round(remain))}` : '-';
          const doneRptTxt = isNum(doneReports) ? `${Math.max(0, Math.round(doneReports))}` : '-';
          const doneBatchTxt = isNum(doneBatch) ? `${Math.max(0, Math.round(doneBatch))}` : '-';
          const lrTxt = lrAvail
            ? `\nì§ì „ ì™„ë£Œ ë°°ì¹˜: new_closed=${isNum(lrNewClosed) ? Math.round(lrNewClosed) : '-'} | closed_total=${isNum(lrClosedTotal) ? Math.round(lrClosedTotal) : '-'} | reports_ok=${isNum(lrReportsOk) ? Math.round(lrReportsOk) : '-'} | ts=${isNum(lrTs) ? fmtTs(lrTs) : '-'}`
            : '';
          autoRevalEl.title = `ìë™ ì¬í‰ê°€ íŒŒì¼ ì§„í–‰ë¥ : ${Math.round(rptReady)}/${Math.round(rptTotal)}\ní˜„ì¬ ë°°ì¹˜ ì‹ ê·œì²­ì‚°=${newTxt}/${tgtTxt}, ë‚¨ì€ìˆ˜=${remTxt}\nëˆ„ì  ì‹ ê·œì²­ì‚°(ë¦¬ì…‹ì—†ìŒ)=${newCumTxt}\nì™„ë£Œ ë°°ì¹˜ìˆ˜=${doneBatchTxt}, ëˆ„ì  ë¦¬í¬íŠ¸ ì‹¤í–‰ìˆ˜=${doneRptTxt}${lrTxt}\nì°¸ê³ : ë°°ì¹˜ ëª©í‘œ ë‹¬ì„± ì‹œ baseline ë¡¤ë§ìœ¼ë¡œ í˜„ì¬ ë°°ì¹˜ ì¹´ìš´íŠ¸ëŠ” 0ë¶€í„° ì¬ì‹œì‘í•©ë‹ˆë‹¤.\nê°±ì‹ ì‹œê°=${freshTxt}`;
        } else {
          const batchTxt = isNum(doneBatch) ? ` B${Math.max(0, Math.round(doneBatch))}` : '';
          autoRevalEl.textContent = exists ? (lrAvail ? `LR${batchTxt}` : `0/3${batchTxt}`) : '-';
          autoRevalEl.className = exists ? 'v wait' : 'v muted';
          autoRevalEl.title = exists
            ? (lrAvail
              ? `ìë™ ì¬í‰ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. í˜„ì¬ ë°°ì¹˜ ë¦¬í¬íŠ¸ê°€ ë¹„ì–´ ìˆì–´ë„ ì§ì „ ì™„ë£Œ ë°°ì¹˜ KPIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.\nì§ì „ ì™„ë£Œ ë°°ì¹˜: new_closed=${isNum(lrNewClosed) ? Math.round(lrNewClosed) : '-'} | closed_total=${isNum(lrClosedTotal) ? Math.round(lrClosedTotal) : '-'} | reports_ok=${isNum(lrReportsOk) ? Math.round(lrReportsOk) : '-'} | ts=${isNum(lrTs) ? fmtTs(lrTs) : '-'}`
              : 'ìë™ ì¬í‰ê°€ ëŒ€ê¸° ì¤‘: ëª©í‘œ ì‹ ê·œì²­ì‚° ë„ë‹¬ í›„ ë¦¬í¬íŠ¸ê°€ ì±„ì›Œì§‘ë‹ˆë‹¤. ë°°ì¹˜ ì¹´ìš´íŠ¸ëŠ” ëª©í‘œ ë‹¬ì„± ì‹œ 0ë¶€í„° ì¬ì‹œì‘ë˜ëŠ” ê²ƒì´ ì •ìƒì…ë‹ˆë‹¤.')
            : 'auto_reval_db_report.json íŒŒì¼ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.';
        }
      }
      if (kpiDirHitEl || kpiEntryIssueEl || kpiExitRegretEl || kpiExitGateEl) {
        const ar = d.auto_reval || {};
        const at = d.auto_tune || {};
        const dirHit = Number(ar.direction_hit ?? ar.last_ready_direction_hit ?? at.direction_hit ?? NaN);
        const entryIssue = Number(ar.entry_issue_ratio ?? ar.last_ready_entry_issue_ratio ?? at.entry_issue_ratio ?? at.entry_issue_rate ?? NaN);
        const exitRegret = Number(ar.avg_exit_regret ?? ar.last_ready_avg_exit_regret ?? at.avg_exit_regret ?? NaN);
        const kpiSource = (ar.kpi_source || (ar.last_ready_available === true ? 'last_ready' : '') || (at.ready === true ? 'auto_tune' : '')).toString();
        const exitGateGrade = (ar.exit_kpi_grade || '').toString().toUpperCase();
        const exitGateMsg = (ar.exit_kpi_message || '').toString();
        const exitGatePass = ar.exit_kpi_pass === true;
        const exitGateImproving = ar.exit_kpi_improving === true;
        const arReady = ar.ready === true;
        const atReady = at.ready === true;
        const canUseDelta = arReady || atReady;
        const cachedDirRaw = localStorage.getItem('kpi_delta_direction_hit');
        const cachedEntryRaw = localStorage.getItem('kpi_delta_entry_issue_ratio');
        const cachedRegretRaw = localStorage.getItem('kpi_delta_avg_exit_regret');
        const cachedDir = cachedDirRaw === null ? NaN : Number(cachedDirRaw);
        const cachedEntry = cachedEntryRaw === null ? NaN : Number(cachedEntryRaw);
        const cachedRegret = cachedRegretRaw === null ? NaN : Number(cachedRegretRaw);
        let dirHitDelta = Number(ar.direction_hit_delta ?? at.direction_hit_delta ?? NaN);
        let entryIssueDelta = Number(ar.entry_issue_ratio_delta ?? at.entry_issue_ratio_delta ?? NaN);
        let exitRegretDelta = Number(ar.avg_exit_regret_delta ?? at.avg_exit_regret_delta ?? NaN);
        if (!canUseDelta) {
          dirHitDelta = NaN;
          entryIssueDelta = NaN;
          exitRegretDelta = NaN;
        } else {
          if (!isNum(dirHitDelta) && isNum(cachedDir)) dirHitDelta = cachedDir;
          if (!isNum(entryIssueDelta) && isNum(cachedEntry)) entryIssueDelta = cachedEntry;
          if (!isNum(exitRegretDelta) && isNum(cachedRegret)) exitRegretDelta = cachedRegret;
          if (isNum(dirHitDelta)) localStorage.setItem('kpi_delta_direction_hit', String(dirHitDelta));
          if (isNum(entryIssueDelta)) localStorage.setItem('kpi_delta_entry_issue_ratio', String(entryIssueDelta));
          if (isNum(exitRegretDelta)) localStorage.setItem('kpi_delta_avg_exit_regret', String(exitRegretDelta));
        }
        const stale = Number(ar.stale_sec ?? at.stale_sec ?? NaN);
        const staleTxt = isNum(stale) ? `${stale.toFixed(0)}ì´ˆ ì „` : '-';
        const sourceTxt = kpiSource ? `\nì†ŒìŠ¤=${kpiSource}` : '';

        if (kpiDirHitEl) {
          if (isNum(dirHit)) {
            const baseTxt = `${(dirHit * 100).toFixed(1)}%`;
            const deltaTxt = isNum(dirHitDelta) ? ` ${fmtDeltaPp(dirHitDelta, 2)}` : '';
            kpiDirHitEl.textContent = `${baseTxt}${deltaTxt}`;
            if (isNum(dirHitDelta) && dirHitDelta > 0) kpiDirHitEl.className = 'v up';
            else if (isNum(dirHitDelta) && dirHitDelta < 0) kpiDirHitEl.className = 'v dn';
            else kpiDirHitEl.className = 'v wait';
            kpiDirHitEl.title = `ë°©í–¥ ì ì¤‘ë¥ (direction_hit)\ní˜„ì¬=${baseTxt}\nì§ì „ë°°ì¹˜ ëŒ€ë¹„=${fmtDeltaPp(dirHitDelta, 2)}\nê°±ì‹ ì‹œê°=${staleTxt}${sourceTxt}`;
          } else {
            kpiDirHitEl.textContent = '-';
            kpiDirHitEl.className = 'v muted';
            kpiDirHitEl.title = 'direction_hit ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }
        if (kpiEntryIssueEl) {
          if (isNum(entryIssue)) {
            const baseTxt = `${(entryIssue * 100).toFixed(1)}%`;
            const deltaTxt = isNum(entryIssueDelta) ? ` ${fmtDeltaPp(entryIssueDelta, 2)}` : '';
            kpiEntryIssueEl.textContent = `${baseTxt}${deltaTxt}`;
            if (isNum(entryIssueDelta) && entryIssueDelta < 0) kpiEntryIssueEl.className = 'v up';
            else if (isNum(entryIssueDelta) && entryIssueDelta > 0) kpiEntryIssueEl.className = 'v dn';
            else kpiEntryIssueEl.className = 'v wait';
            kpiEntryIssueEl.title = `ì§„ì… ì´ìŠˆ ë¹„ìœ¨(entry_issue_ratio, ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)\ní˜„ì¬=${baseTxt}\nì§ì „ë°°ì¹˜ ëŒ€ë¹„=${fmtDeltaPp(entryIssueDelta, 2)}\nê°±ì‹ ì‹œê°=${staleTxt}${sourceTxt}`;
          } else {
            kpiEntryIssueEl.textContent = '-';
            kpiEntryIssueEl.className = 'v muted';
            kpiEntryIssueEl.title = 'entry_issue_ratio ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }
        if (kpiExitRegretEl) {
          if (isNum(exitRegret)) {
            const baseTxt = exitRegret.toFixed(4);
            const deltaTxt = isNum(exitRegretDelta) ? ` ${fmtDeltaAbs(exitRegretDelta, 4)}` : '';
            kpiExitRegretEl.textContent = `${baseTxt}${deltaTxt}`;
            if (isNum(exitRegretDelta) && exitRegretDelta < 0) kpiExitRegretEl.className = 'v up';
            else if (isNum(exitRegretDelta) && exitRegretDelta > 0) kpiExitRegretEl.className = 'v dn';
            else kpiExitRegretEl.className = 'v wait';
            kpiExitRegretEl.title = `í‰ê·  ì²­ì‚° í›„íšŒ(avg_exit_regret, ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)\ní˜„ì¬=${baseTxt}\nì§ì „ë°°ì¹˜ ëŒ€ë¹„=${fmtDeltaAbs(exitRegretDelta, 4)}\nê°±ì‹ ì‹œê°=${staleTxt}${sourceTxt}`;
          } else {
            kpiExitRegretEl.textContent = '-';
            kpiExitRegretEl.className = 'v muted';
            kpiExitRegretEl.title = 'avg_exit_regret ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }
        if (kpiExitGateEl) {
          if (exitGateGrade === 'PASS') {
            kpiExitGateEl.textContent = 'PASS';
            kpiExitGateEl.className = 'v up';
          } else if (exitGateGrade === 'IMPROVING') {
            kpiExitGateEl.textContent = 'IMP';
            kpiExitGateEl.className = 'v wait';
          } else if (exitGateGrade === 'FAIL') {
            kpiExitGateEl.textContent = 'FAIL';
            kpiExitGateEl.className = 'v dn';
          } else {
            kpiExitGateEl.textContent = '-';
            kpiExitGateEl.className = 'v muted';
          }
          const gradeTxt = exitGateGrade || '-';
          const passTxt = exitGatePass ? 'Y' : 'N';
          const impTxt = exitGateImproving ? 'Y' : 'N';
          kpiExitGateEl.title = `ì²­ì‚° ê°œì„  ê³ ì • íŒì •\ngrade=${gradeTxt}, pass=${passTxt}, improving=${impTxt}\në©”ì‹œì§€=${exitGateMsg || '-'}\nê°±ì‹ ì‹œê°=${staleTxt}`;
        }
      }
      if (kpiSlipErr200El || kpiExecABEl || kpiExecMatchEl) {
        const ar = d.auto_reval || {};
        const stale = Number(ar.stale_sec ?? NaN);
        const staleTxt = isNum(stale) ? `${stale.toFixed(0)}ì´ˆ ì „` : '-';
        const slipLimit = Number(ar.slip_exit_limit ?? ar.target_new ?? NaN);
        const slipN = (isNum(slipLimit) && slipLimit > 0) ? Math.round(slipLimit) : null;
        const slipSource = (ar.slip_exit_source || '').toString();
        if (kpiSlipErrLabelEl) {
          kpiSlipErrLabelEl.textContent = slipN ? `SlipErr${slipN}` : 'SlipErrN';
        }
        const mae = Number(ar.slip_exit_200_estimation_mae_bps ?? NaN);
        const rmse = Number(ar.slip_exit_200_estimation_rmse_bps ?? NaN);
        const sampleN = Number(ar.slip_exit_200_sample_n ?? NaN);
        const matchRate = Number(ar.slip_exit_200_match_rate ?? NaN);
        const makerAbs = Number(ar.exec_ab_maker_abs_slip_bps ?? NaN);
        const takerAbs = Number(ar.exec_ab_taker_abs_slip_bps ?? NaN);
        const deltaAbs = Number(ar.exec_ab_delta_abs_slip_bps ?? NaN);
        const execMatch = Number(ar.exec_ab_match_rate ?? NaN);
        const makerFallback = Number(ar.exec_ab_maker_fallback_rate ?? NaN);

        if (kpiSlipErr200El) {
          if (isNum(mae) || isNum(rmse)) {
            const maeTxt = isNum(mae) ? mae.toFixed(2) : '-';
            const rmseTxt = isNum(rmse) ? rmse.toFixed(2) : '-';
            kpiSlipErr200El.textContent = `${maeTxt}/${rmseTxt}`;
            if (isNum(mae) && mae <= 2.0) kpiSlipErr200El.className = 'v up';
            else if (isNum(mae) && mae >= 6.0) kpiSlipErr200El.className = 'v dn';
            else kpiSlipErr200El.className = 'v wait';
            kpiSlipErr200El.title = `ìµœê·¼ ${slipN || 'N'}ê±´ ìŠ¬ë¦¬í”¼ì§€ ì˜ˆì¸¡ì˜¤ì°¨(MAE/RMSE, bps)\nMAE=${maeTxt}, RMSE=${rmseTxt}\në§¤ì¹­ìƒ˜í”Œ=${isNum(sampleN) ? Math.round(sampleN) : '-'}, ë§¤ì¹­ë¥ =${isNum(matchRate) ? (matchRate * 100).toFixed(1) + '%' : '-'}\nì†ŒìŠ¤=${slipSource || '-'}\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiSlipErr200El.textContent = '-';
            kpiSlipErr200El.className = 'v muted';
            kpiSlipErr200El.title = `ìµœê·¼ ${slipN || 'N'}ê±´ ìŠ¬ë¦¬í”¼ì§€ ì˜ˆì¸¡ì˜¤ì°¨ ë°ì´í„° ëŒ€ê¸° ì¤‘`;
          }
        }

        if (kpiExecABEl) {
          if (isNum(makerAbs) || isNum(takerAbs)) {
            const mTxt = isNum(makerAbs) ? makerAbs.toFixed(2) : '-';
            const tTxt = isNum(takerAbs) ? takerAbs.toFixed(2) : '-';
            kpiExecABEl.textContent = `M${mTxt}/T${tTxt}`;
            if (isNum(deltaAbs) && deltaAbs > 0) kpiExecABEl.className = 'v up';
            else if (isNum(deltaAbs) && deltaAbs < 0) kpiExecABEl.className = 'v dn';
            else kpiExecABEl.className = 'v wait';
            kpiExecABEl.title = `selected_exec_type A/B ì„±ëŠ¥(í‰ê·  ì ˆëŒ€ ìŠ¬ë¦¬í”¼ì§€ bps)\nMaker=${mTxt}, Taker=${tTxt}\nÎ”(Taker-Maker)=${isNum(deltaAbs) ? deltaAbs.toFixed(2) : '-'}\nê¸°ì¤€í‘œë³¸=${slipN || 'N'}\nì†ŒìŠ¤=${slipSource || '-'}\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiExecABEl.textContent = '-';
            kpiExecABEl.className = 'v muted';
            kpiExecABEl.title = 'selected_exec_type A/B ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }

        if (kpiExecMatchEl) {
          if (isNum(execMatch) || isNum(makerFallback)) {
            const matchTxt = isNum(execMatch) ? `${(execMatch * 100).toFixed(1)}%` : '-';
            const fbTxt = isNum(makerFallback) ? `${(makerFallback * 100).toFixed(1)}%` : '-';
            kpiExecMatchEl.textContent = `${matchTxt}/${fbTxt}`;
            if (isNum(execMatch) && execMatch >= 0.70 && (!isNum(makerFallback) || makerFallback <= 0.40)) kpiExecMatchEl.className = 'v up';
            else if (isNum(execMatch) && execMatch < 0.50) kpiExecMatchEl.className = 'v dn';
            else kpiExecMatchEl.className = 'v wait';
            kpiExecMatchEl.title = `ì‹¤í–‰ ì •í•©ì„±(Match/MakerFallback)\nselected vs actual match=${matchTxt}\nselected maker ëŒ€ë¹„ fallback ë¹„ìœ¨=${fbTxt}\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiExecMatchEl.textContent = '-';
            kpiExecMatchEl.className = 'v muted';
            kpiExecMatchEl.title = 'ì‹¤í–‰ ì •í•©ì„± ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }
      }
      if (kpiEntryPfEl || kpiOppBetterEl || kpiDirRegretEl) {
        const ar = d.auto_reval || {};
        const stale = Number(ar.stale_sec ?? NaN);
        const staleTxt = isNum(stale) ? `${stale.toFixed(0)}ì´ˆ ì „` : '-';
        const entryPf = Number(ar.entry_side_profitable_rate_best_h ?? NaN);
        const oppBetter = Number(ar.entry_opp_side_better_rate ?? NaN);
        const dirRegret = Number(ar.entry_avg_direction_regret ?? NaN);
        const p50Regret = Number(ar.entry_p50_direction_regret ?? NaN);
        const p90Regret = Number(ar.entry_p90_direction_regret ?? NaN);

        if (kpiEntryPfEl) {
          if (isNum(entryPf)) {
            const txt = `${(entryPf * 100).toFixed(1)}%`;
            kpiEntryPfEl.textContent = txt;
            if (entryPf >= 0.60) kpiEntryPfEl.className = 'v up';
            else if (entryPf < 0.50) kpiEntryPfEl.className = 'v dn';
            else kpiEntryPfEl.className = 'v wait';
            kpiEntryPfEl.title = `ì§„ì… ì „ìš© ì¹´ìš´í„°íŒ©ì¶”ì–¼ ìˆ˜ìµ ê°€ëŠ¥ë¥ (side_profitable_rate_best_h)\ní˜„ì¬=${txt}\nì •ì˜=ê°™ì€ ì§„ì… ë°©í–¥ìœ¼ë¡œ h* ìµœì  ë³´ìœ  ì‹œ í”ŒëŸ¬ìŠ¤ ìˆ˜ìµ ë¹„ìœ¨\nì£¼ì˜=ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiEntryPfEl.textContent = '-';
            kpiEntryPfEl.className = 'v muted';
            kpiEntryPfEl.title = 'entry_counterfactual(side_profitable_rate_best_h) ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }

        if (kpiOppBetterEl) {
          if (isNum(oppBetter)) {
            const txt = `${(oppBetter * 100).toFixed(1)}%`;
            kpiOppBetterEl.textContent = txt;
            if (oppBetter <= 0.40) kpiOppBetterEl.className = 'v up';
            else if (oppBetter >= 0.50) kpiOppBetterEl.className = 'v dn';
            else kpiOppBetterEl.className = 'v wait';
            kpiOppBetterEl.title = `ì§„ì… ì „ìš© ë°˜ëŒ€ë°©í–¥ ìš°ìœ„ ë¹„ìœ¨(opp_side_better_rate, ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)\ní˜„ì¬=${txt}\nì •ì˜=ê°™ì€ ì‹œì  ì§„ì…ì—ì„œ ë°˜ëŒ€ë°©í–¥ best-h ìˆ˜ìµì´ ë” ì»¸ë˜ ë¹„ìœ¨\nì£¼ì˜=ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiOppBetterEl.textContent = '-';
            kpiOppBetterEl.className = 'v muted';
            kpiOppBetterEl.title = 'entry_counterfactual(opp_side_better_rate) ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }

        if (kpiDirRegretEl) {
          if (isNum(dirRegret)) {
            const txt = dirRegret.toFixed(4);
            kpiDirRegretEl.textContent = txt;
            if (dirRegret <= 0) kpiDirRegretEl.className = 'v up';
            else if (dirRegret > 0.005) kpiDirRegretEl.className = 'v dn';
            else kpiDirRegretEl.className = 'v wait';
            kpiDirRegretEl.title = `ì§„ì… ì „ìš© ë°©í–¥ í›„íšŒê°’(avg_direction_regret, ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)\ní˜„ì¬=${txt}\np50=${isNum(p50Regret) ? p50Regret.toFixed(4) : '-'}, p90=${isNum(p90Regret) ? p90Regret.toFixed(4) : '-'}\nì •ì˜=(ë°˜ëŒ€ë°©í–¥ best-h ìˆ˜ìµ - ì„ íƒë°©í–¥ best-h ìˆ˜ìµ) í‰ê· \nì£¼ì˜=ì²­ì‚° ê·œì¹™ ì˜í–¥ ì œì™¸\nê°±ì‹ ì‹œê°=${staleTxt}`;
          } else {
            kpiDirRegretEl.textContent = '-';
            kpiDirRegretEl.className = 'v muted';
            kpiDirRegretEl.title = 'entry_counterfactual(avg_direction_regret) ë°ì´í„° ëŒ€ê¸° ì¤‘';
          }
        }
      }
      if (autoTuneEl) {
        const at = d.auto_tune || {};
        const aw2 = d.alpha_weights || {};
        const enabled = at.enabled !== false;
        const exists = at.exists === true;
        const batch = Number(at.last_batch_id ?? NaN);
        const overrideCount = Number(at.override_count ?? NaN);
        const retrainRan = at.retrain_ran === true;
        const retrainRc = Number(at.retrain_rc ?? NaN);
        const directionHit = Number(at.direction_hit ?? NaN);
        const entryIssue = Number(at.entry_issue_ratio ?? at.entry_issue_rate ?? NaN);
        const exitRegret = Number(at.avg_exit_regret ?? NaN);
        const trig = Number(aw2.trigger_new_exits ?? NaN);
        const prog = Number(aw2.new_exits_since_last_train ?? NaN);
        const progTxt = (isNum(prog) && isNum(trig) && trig > 0) ? `${Math.round(prog)}/${Math.round(trig)}` : '-';
        const batchTxt = isNum(batch) ? `B${Math.max(0, Math.round(batch))}` : 'B-';
        const ovTxt = isNum(overrideCount) ? `O${Math.max(0, Math.round(overrideCount))}` : 'O-';
        let rtTxt = 'R-';
        if (retrainRan) rtTxt = (!isNaN(retrainRc) && retrainRc === 0) ? 'Rok' : `R${retrainRc}`;
        autoTuneEl.textContent = enabled ? `${batchTxt} ${ovTxt} ${rtTxt}` : 'OFF';
        if (!enabled) autoTuneEl.className = 'v muted';
        else if (retrainRan && !isNaN(retrainRc) && retrainRc !== 0) autoTuneEl.className = 'v dn';
        else if (exists) autoTuneEl.className = 'v up';
        else autoTuneEl.className = 'v wait';
        const stale = Number(at.stale_sec ?? NaN);
        const staleTxt = isNum(stale) ? `${stale.toFixed(0)}ì´ˆ ì „` : '-';
        const actions = Array.isArray(at.actions) ? at.actions.join(', ') : '-';
        const directionHitTxt = isNum(directionHit) ? `${(directionHit * 100).toFixed(2)}%` : '-';
        const entryIssueTxt = isNum(entryIssue) ? entryIssue.toFixed(3) : '-';
        const exitRegretTxt = isNum(exitRegret) ? exitRegret.toFixed(4) : '-';
        autoTuneEl.title = `RevalRpt ì¡°ê±´ ê¸°ë°˜ ìë™ íŠœë‹ ìƒíƒœ\nbatch=${batchTxt}, overrides=${ovTxt}, retrain=${rtTxt}\ndirection_hit=${directionHitTxt}, entry_issue_ratio=${entryIssueTxt}, avg_exit_regret=${exitRegretTxt}\nalpha retrain trigger progress=${progTxt}\nactions=${actions}\nê°±ì‹ ì‹œê°=${staleTxt}`;
      }
      if (eventAlignEl) {
        const ea = d.event_alignment || {};
        const eaNew = (ea && typeof ea.since_anchor === 'object') ? ea.since_anchor : {};
        const enabled = ea.enabled === true;
        const nAll = Number(ea.samples ?? NaN);
        const nKnown = Number(ea.known_samples ?? NaN);
        const nAligned = Number(ea.aligned ?? NaN);
        const align = Number(ea.alignment_rate ?? NaN);
        const blocked = Number(ea.blocked_samples ?? NaN);
        const blockedRate = Number(ea.blocked_to_event_exit_rate ?? NaN);
        const safe = Number(ea.safe_samples ?? NaN);
        const safeRate = Number(ea.safe_to_non_event_exit_rate ?? NaN);
        const win = Number(ea.window ?? NaN);
        const strictN = Number(ea.strict_mode_samples ?? NaN);
        const nKnownNew = Number(eaNew.known_samples ?? NaN);
        const nAlignedNew = Number(eaNew.aligned ?? NaN);
        const alignNew = Number(eaNew.alignment_rate ?? NaN);
        const blockedNew = Number(eaNew.blocked_samples ?? NaN);
        const blockedRateNew = Number(eaNew.blocked_to_event_exit_rate ?? NaN);
        const safeNew = Number(eaNew.safe_samples ?? NaN);
        const safeRateNew = Number(eaNew.safe_to_non_event_exit_rate ?? NaN);
        const anchorTs = Number(ea.anchor_ts_ms ?? NaN);
        const anchorId = Number(ea.anchor_trade_id ?? NaN);
        if (enabled && isNum(align) && isNum(nKnown) && nKnown > 0) {
          let txt = `${(align * 100).toFixed(1)}% ${Math.round(nAligned)}/${Math.round(nKnown)}`;
          if (isNum(alignNew) && isNum(nKnownNew) && nKnownNew > 0) {
            txt += ` | NEW ${(alignNew * 100).toFixed(1)}%`;
          }
          eventAlignEl.textContent = txt;
          if (align >= 0.70) eventAlignEl.className = 'v up';
          else if (align >= 0.50) eventAlignEl.className = 'v wait';
          else eventAlignEl.className = 'v dn';
          const bTxt = (isNum(blockedRate) && isNum(blocked)) ? `${(blockedRate * 100).toFixed(1)}% (${Math.round(blocked)})` : '-';
          const sTxt = (isNum(safeRate) && isNum(safe)) ? `${(safeRate * 100).toFixed(1)}% (${Math.round(safe)})` : '-';
          const bTxtNew = (isNum(blockedRateNew) && isNum(blockedNew)) ? `${(blockedRateNew * 100).toFixed(1)}% (${Math.round(blockedNew)})` : '-';
          const sTxtNew = (isNum(safeRateNew) && isNum(safeNew)) ? `${(safeRateNew * 100).toFixed(1)}% (${Math.round(safeNew)})` : '-';
          const winTxt = isNum(win) ? `${Math.round(win)}` : '-';
          const nAllTxt = isNum(nAll) ? `${Math.round(nAll)}` : '-';
          const strictTxt = isNum(strictN) ? `${Math.round(strictN)}` : '-';
          const newTxt = (isNum(alignNew) && isNum(nKnownNew) && nKnownNew > 0)
            ? `ì‹ ê·œ(íŒ¨ì¹˜ ì´í›„) ì¼ì¹˜ìœ¨=${(alignNew * 100).toFixed(2)}% (${Math.round(nAlignedNew)}/${Math.round(nKnownNew)})\nì‹ ê·œ blockedâ†’event_exit=${bTxtNew}\nì‹ ê·œ safeâ†’non_event_exit=${sTxtNew}`
            : `ì‹ ê·œ(íŒ¨ì¹˜ ì´í›„) ìƒ˜í”Œ ëŒ€ê¸° ì¤‘`;
          const anchorTxt = (isNum(anchorTs) || isNum(anchorId))
            ? `anchor_ts=${isNum(anchorTs) ? fmtTs(anchorTs) : '-'}, anchor_trade_id=${isNum(anchorId) ? Math.round(anchorId) : '-'}`
            : '';
          eventAlignEl.title = `Event precheckâ†”ì‹¤ì²­ì‚° ì •í•©ì„±\nì¼ì¹˜ìœ¨=${(align * 100).toFixed(2)}% (${Math.round(nAligned)}/${Math.round(nKnown)})\nblockedâ†’event_exit=${bTxt}\nsafeâ†’non_event_exit=${sTxt}\nwindow=${winTxt}, samples=${nAllTxt}, strict_samples=${strictTxt}\n${newTxt}${anchorTxt ? `\n${anchorTxt}` : ''}`;
        } else if (!enabled) {
          eventAlignEl.textContent = 'OFF';
          eventAlignEl.className = 'v muted';
          eventAlignEl.title = 'Strict Consistency ëª¨ë“œê°€ êº¼ì ¸ ìˆìŠµë‹ˆë‹¤ (EVENT_EXIT_STRICT_CONSISTENCY_MODE=0).';
        } else {
          if (isNum(alignNew) && isNum(nKnownNew) && nKnownNew > 0) {
            eventAlignEl.textContent = `NEW ${(alignNew * 100).toFixed(1)}% ${Math.round(nAlignedNew)}/${Math.round(nKnownNew)}`;
            eventAlignEl.className = alignNew >= 0.70 ? 'v up' : (alignNew >= 0.50 ? 'v wait' : 'v dn');
            eventAlignEl.title = `ì‹ ê·œ(íŒ¨ì¹˜ ì´í›„) ì •í•©ì„±\nì¼ì¹˜ìœ¨=${(alignNew * 100).toFixed(2)}% (${Math.round(nAlignedNew)}/${Math.round(nKnownNew)})`;
          } else {
            eventAlignEl.textContent = '-';
            eventAlignEl.className = 'v muted';
            eventAlignEl.title = 'ì •í•©ì„± ìƒ˜í”Œ ëŒ€ê¸° ì¤‘';
          }
        }
      }

      if (envSrcEl) {
        const active = eng.env_active;
        const profile = eng.env_profile;
        const file = eng.env_file;
        let text = '-';
        if (active) {
          const parts = String(active).split('/');
          text = parts[parts.length - 1] || active;
        } else if (profile) {
          text = `.env.${profile}`;
        } else if (file) {
          const parts = String(file).split('/');
          text = parts[parts.length - 1] || file;
        }
        envSrcEl.textContent = text;
        const srcs = Array.isArray(eng.env_sources) ? eng.env_sources : [];
        const details = srcs.map(s => `${s.mode}:${s.loaded ? 'OK' : 'MISS'}:${s.path}`).join(' | ');
        envSrcEl.title = details || 'ENV ì •ë³´ ì—†ìŒ';
      }

      selSymEl.textContent = selectedSym || '-';

      if (outsideWarnEl) {
        const outs = (d.engine && d.engine.outside_universe_positions) ? d.engine.outside_universe_positions : (d.outside_universe_positions || []);
        const rawCnt = Number((d.engine && d.engine.exchange_positions_raw_count) ?? (d.portfolio && d.portfolio.positions_raw_count) ?? NaN);
        const viewCnt = Number((d.engine && d.engine.exchange_positions_view_count) ?? (d.portfolio && d.portfolio.positions_view_count) ?? NaN);
        const filtOn = !!(d.engine && d.engine.exchange_positions_filter_universe);
        if (Array.isArray(outs) && outs.length > 0) {
          const names = outs.map(o => o.symbol).filter(Boolean);
          const shortList = names.slice(0, 6);
          outsideWarnEl.style.display = 'block';
          outsideWarnEl.textContent = `ìœ ë‹ˆë²„ìŠ¤ ë°– í¬ì§€ì…˜ ê°ì§€: ${outs.length}ê°œ (${shortList.join(', ')}${names.length > 6 ? ' ...' : ''})`;
          const tip = outs.map(o => {
            const qty = (o.quantity != null) ? String(o.quantity) : '-';
            const side = o.side || '-';
            const ep = (o.entry_price != null) ? Number(o.entry_price).toFixed(4) : '-';
            return `${o.symbol} ${side} qty=${qty} entry=${ep}`;
          }).join(' | ');
          outsideWarnEl.title = tip || 'ìœ ë‹ˆë²„ìŠ¤ ë°– í¬ì§€ì…˜';
        } else if (Number.isFinite(rawCnt) && Number.isFinite(viewCnt) && rawCnt > viewCnt) {
          outsideWarnEl.style.display = 'block';
          outsideWarnEl.textContent = `ê±°ë˜ì†Œ í¬ì§€ì…˜ í‘œì‹œ í•„í„°ë§: í‘œì‹œ ${viewCnt} / ê±°ë˜ì†Œ ${rawCnt}`;
          outsideWarnEl.title = filtOn
            ? 'DASHBOARD_EXCHANGE_VIEW_FILTER_UNIVERSE=1 ìƒíƒœì—ì„œ ìœ ë‹ˆë²„ìŠ¤ ì™¸ í¬ì§€ì…˜ì´ ìˆ¨ê²¨ì§‘ë‹ˆë‹¤.'
            : 'í¬ì§€ì…˜ ë™ê¸° ì§€ì—° ë˜ëŠ” API ì‘ë‹µ í¸ì°¨ê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
        } else {
          outsideWarnEl.style.display = 'none';
          outsideWarnEl.textContent = '';
          outsideWarnEl.title = '';
        }
      }

      // KPIs
      const bal = Number((d.portfolio && d.portfolio.balance) || 0);
      smoothSetText(balKpi, bal, (v) => Number(v).toFixed(2), 260);
      smoothSetText(eqKpi, equityDisplay, (v) => Number(v).toFixed(2), 260);

      // dd
      const histForDd = useLiveEq ? liveEquityHist : equityHist;
      const peak = histForDd.reduce((m, p) => Math.max(m, p.equity), equityDisplay);
      const dd = peak > 0 ? ((equityDisplay - peak) / peak) * 100 : 0;
      ddKpi.textContent = `${dd.toFixed(2)}%`;

      // live KPIs
      const liveWalletRaw = d.portfolio ? d.portfolio.live_wallet_balance : null;
      const liveFreeRaw = d.portfolio ? d.portfolio.live_free_balance : null;
      const liveImRaw = d.portfolio ? d.portfolio.live_total_initial_margin : null;
      const liveMmRaw = d.portfolio ? d.portfolio.live_total_maintenance_margin : null;
      const liveWalletVal = isNum(liveWalletRaw) ? Number(liveWalletRaw) : null;
      const liveFreeVal = isNum(liveFreeRaw) ? Number(liveFreeRaw) : null;
      const liveImVal = isNum(liveImRaw) ? Number(liveImRaw) : null;
      const liveMmVal = isNum(liveMmRaw) ? Number(liveMmRaw) : null;

      if (liveWalletKpi) {
        if (liveWalletVal === null) liveWalletKpi.textContent = '-';
        else smoothSetText(liveWalletKpi, liveWalletVal, (v) => Number(v).toFixed(2), 260);
      }
      if (liveEqKpi) {
        if (liveEquityVal === null) liveEqKpi.textContent = '-';
        else smoothSetText(liveEqKpi, liveEquityVal, (v) => Number(v).toFixed(2), 260);
      }
      if (liveFreeKpi) {
        if (liveFreeVal === null) liveFreeKpi.textContent = '-';
        else smoothSetText(liveFreeKpi, liveFreeVal, (v) => Number(v).toFixed(2), 260);
      }
      if (liveMarginKpi) {
        if (liveImVal !== null || liveMmVal !== null) {
          liveMarginKpi.textContent = `${f2(liveImVal)}/${f2(liveMmVal)}`;
        } else {
          liveMarginKpi.textContent = '-';
        }
      }
      if (liveSyncKpi) {
        const syncErr = d.portfolio ? d.portfolio.live_last_sync_err : null;
        const syncMs = d.portfolio ? d.portfolio.live_last_sync_ms : null;
        if (syncErr) {
          liveSyncKpi.textContent = 'ERR';
          liveSyncKpi.title = String(syncErr);
        } else if (syncMs) {
          const age = Math.max(0, (Date.now() - Number(syncMs)) / 1000);
          liveSyncKpi.textContent = `${age.toFixed(1)}s`;
          liveSyncKpi.title = new Date(Number(syncMs)).toLocaleTimeString();
        } else {
          liveSyncKpi.textContent = '-';
          liveSyncKpi.title = 'live sync ì—†ìŒ';
        }
      }

      // seed history
      if (!equitySeeded && d.portfolio && Array.isArray(d.portfolio.history) && d.portfolio.history.length) {
        equityHist.length = 0;
        d.portfolio.history.forEach(p => {
          equityHist.push({ t: p.time || p.ts || Date.now(), equity: p.equity });
        });
        normalizeHist(equityHist);
        equitySeeded = true;
        updateEquityChart(equityHist);
      }

      if (!liveEquitySeeded && d.portfolio && Array.isArray(d.portfolio.live_history) && d.portfolio.live_history.length) {
        liveEquityHist.length = 0;
        d.portfolio.live_history.forEach(p => {
          liveEquityHist.push({ t: p.time || p.ts || Date.now(), equity: p.equity });
        });
        normalizeHist(liveEquityHist);
        liveEquitySeeded = true;
        updateLiveEquityChart();
      }

      const t = d.server_time || Date.now();
      // Always update model equity curve; update live curve when available.
      pushEquityPoint(t, equity);
      if (liveEquityVal !== null && !isNaN(liveEquityVal)) {
        pushLiveEquityPoint(t, liveEquityVal);
      }

      // market
      const rows = d.market || [];
      rows.forEach(x => {
        const sym = normSym(x.symbol);
        const price = Number(x.price || 0);
        pushSymPoint(sym, t, price);
      });
      // render top-4 summary and full market table
      renderTop4(rows);
      renderMarketTable(rows);

      // positions
      const positionsRaw = coercePositions(d.portfolio ? d.portfolio.positions : null);
      const posCount = (d.portfolio && d.portfolio.positions_count !== undefined && d.portfolio.positions_count !== null)
        ? Number(d.portfolio.positions_count)
        : null;
      let positions = positionsRaw;
      const nowMs = Date.now();
      if (positionsRaw && positionsRaw.length) {
        lastPositions = positionsRaw;
        lastPositionsTs = nowMs;
      } else {
        const keepMs = 5000;
        if (lastPositions.length && (nowMs - lastPositionsTs) < keepMs) {
          positions = lastPositions;
        } else if (posCount && posCount > 0 && lastPositions.length) {
          positions = lastPositions;
        }
      }
      renderPositions(positions, rows, d.portfolio || {});
      const outs = (d.engine && d.engine.outside_universe_positions) ? d.engine.outside_universe_positions : (d.outside_universe_positions || []);
      renderArchivedPositions(outs);

      // trade tape: payload ìš°ì„  â†’ logs fallback
      if (Array.isArray(d.trade_tape) && d.trade_tape.length) {
        tradeTape.length = 0;
        d.trade_tape.slice(-500).forEach(t => tradeTape.push(t));
        renderTradeTape();
      } else {
        updateTradeTapeFromLogs(d.logs || []);
      }

      renderLogs(d.logs || []);
      renderMcHealth(d.mc_health || null);
      renderMcSanity(d.mc_sanity || null);
      renderAlerts(d.alerts || []);
    }

    let lastUiErrorMsg = '';
    let lastUiErrorTs = 0;
    function safeApplyUpdate(d) {
      try {
        applyUpdate(d);
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        const now = Date.now();
        if (msg !== lastUiErrorMsg || (now - lastUiErrorTs) > 5000) {
          lastUiErrorMsg = msg;
          lastUiErrorTs = now;
          console.error('[dashboard] applyUpdate failed:', err);
          if (feedEl) {
            feedEl.textContent = 'ERR';
            feedEl.title = msg;
          }
          if (logsEl) {
            const div = document.createElement('div');
            div.className = 'muted';
            div.textContent = `[UI_ERR] ${new Date(now).toLocaleTimeString()} ${msg}`;
            logsEl.prepend(div);
          }
        }
      }
    }

    function scheduleWsReconnect(reason) {
      if (wsManualClose) return;
      if (wsReconnectTimer) return;
      const backoff = Math.min(WS_RECONNECT_MAX_MS, WS_RECONNECT_MIN_MS * (2 ** wsReconnectAttempt));
      wsReconnectAttempt += 1;
      wsReconnectTimer = setTimeout(() => {
        wsReconnectTimer = null;
        connectWs();
      }, backoff);
      if (feedEl) {
        feedEl.textContent = 'RETRY';
        feedEl.title = `WS reconnect in ${backoff}ms (${reason || 'unknown'})`;
      }
    }

    function handleWsMessage(e) {
      wsLastMessageTs = Date.now();
      try {
        latestPayload = JSON.parse(e.data);
      } catch (err) {
        console.error('[dashboard] ws parse error:', err);
        if (feedEl) {
          feedEl.textContent = 'PARSE_ERR';
          feedEl.title = String(err);
        }
        return;
      }
      if (!rafScheduled) {
        rafScheduled = true;
        requestAnimationFrame(() => {
          rafScheduled = false;
          safeApplyUpdate(latestPayload);
        });
      }
    }

    function connectWs() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
      try {
        ws = new WebSocket(wsUrl);
      } catch (err) {
        scheduleWsReconnect(`ctor:${err && err.message ? err.message : err}`);
        return;
      }
      if (feedEl) {
        feedEl.textContent = 'CONNECTING';
        feedEl.title = 'WS connecting';
      }
      ws.onopen = () => {
        wsReconnectAttempt = 0;
        wsLastMessageTs = Date.now();
        if (feedEl) {
          feedEl.textContent = 'OK';
          feedEl.title = 'WS connected';
        }
      };
      ws.onmessage = handleWsMessage;
      ws.onerror = (err) => {
        if (feedEl) {
          feedEl.textContent = 'WS_ERR';
          feedEl.title = String(err && err.message ? err.message : 'websocket error');
        }
      };
      ws.onclose = (ev) => {
        ws = null;
        if (wsManualClose) return;
        if (feedEl) {
          feedEl.textContent = 'DISCONNECTED';
          feedEl.title = `WS closed code=${ev && ev.code !== undefined ? ev.code : '-'}`;
        }
        scheduleWsReconnect(`close:${ev && ev.code !== undefined ? ev.code : 'na'}`);
      };
    }

    setInterval(() => {
      if (!feedEl) return;
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      if (!wsLastMessageTs) return;
      const staleMs = Date.now() - wsLastMessageTs;
      if (staleMs > WS_STALE_MS) {
        feedEl.textContent = 'STALE';
        feedEl.title = `No WS payload for ${Math.round(staleMs / 1000)}s`;
      }
    }, 2000);

    window.addEventListener('beforeunload', () => {
      wsManualClose = true;
      if (wsReconnectTimer) {
        clearTimeout(wsReconnectTimer);
        wsReconnectTimer = null;
      }
      if (ws) {
        try { ws.close(); } catch (_) {}
      }
    });

    connectWs();

    // ---------- Top-4 rendering ----------
    function renderTop4(rows) {
      const out = $('top4Panel');
      if (!out) return;

      const data = (rows || []).map(x => {
        const sym = normSym(x.symbol);
        const hybrid = (x.hybrid_score !== undefined && x.hybrid_score !== null) ? Number(x.hybrid_score) :
          (x.meta && x.meta.hybrid_score !== undefined && x.meta.hybrid_score !== null) ? Number(x.meta.hybrid_score) : 0;
        const scorep = hybrid * 100;
        return {
          raw: x,
          symbol: sym,
          hybrid_score: hybrid,
          scorep: scorep,
          price: x.price ?? null,
          status: x.status || 'WAIT',
          regime: x.regime || '-',
        };
      });

      // Hybrid score ê¸°ì¤€ ì •ë ¬
      const byScore = data.slice().sort((a, b) => (b.hybrid_score || 0) - (a.hybrid_score || 0));
      const top = byScore.slice(0, 4);

      out.innerHTML = '';
      if (top.length === 0) {
        out.innerHTML = '<div class="muted" style="padding:8px">Top-4: ë°ì´í„° ì—†ìŒ</div>';
        return;
      }

      top.forEach((t, i) => {
        const pct = 25; // ê° 25%
        const card = document.createElement('div');
        card.style.cssText = 'padding:10px 14px;border:2px solid var(--accent);border-radius:12px;background:linear-gradient(135deg, #fff 0%, #f8fafc 100%);min-width:180px;flex:1';

        const statusCls = (t.status === 'LONG') ? 'up' : (t.status === 'SHORT') ? 'down' : 'muted';

        card.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <div style="font-size:20px;font-weight:900;color:var(--accent)">#${i + 1}</div>
          <div style="font-size:16px;font-weight:700">${t.symbol}</div>
        </div>
        <div style="font-size:11px;color:var(--muted);margin-bottom:4px">ìë³¸ ë°°ë¶„: <b style="color:var(--accent)">${pct}%</b></div>
        <div style="display:flex;gap:12px;font-size:12px">
          <div><span style="color:var(--muted)">Hybrid Score:</span> <b class="${(t.scorep >= 0) ? 'up' : 'down'}">${t.scorep.toFixed(4)}%</b></div>
          <div><span style="color:var(--muted)">Status:</span> <span class="pill ${statusCls}" style="font-size:10px;padding:2px 6px">${t.status}</span></div>
        </div>
        <div style="margin-top:4px;font-size:11px;color:var(--muted)">Regime: ${t.regime}</div>
      `;
        out.appendChild(card);
      });
    }
  </script>
</body>

</html>
