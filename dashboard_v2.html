<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Trading Dashboard v4 (Light, Table, Charts)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#f6f8fb;
      --panel:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --shadow:0 6px 18px rgba(17,24,39,.06);
      --radius:14px;

      --good:#16a34a;
      --bad:#dc2626;
      --warn:#d97706;
      --accent:#2563eb;
      --accent2:#0ea5e9;
      --chip:#f3f4f6;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
    .wrap{max-width:1400px;margin:0 auto;padding:14px}
    .topbar{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);
      padding:10px 12px;box-shadow:var(--shadow);
      position:sticky;top:0;z-index:10;
    }
    .chip{display:flex;gap:8px;align-items:baseline;padding:7px 10px;border-radius:999px;background:var(--chip);border:1px solid var(--line);font-size:13px}
    .chip b{font-size:12px;color:var(--muted);font-weight:600}
    .chip .v{font-weight:700}
    .chip .on{color:var(--bad)}
    .chip .off{color:var(--good)}
    .spacer{flex:1}
    .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .input{
      border:1px solid var(--line);border-radius:10px;padding:8px 10px;background:#fff;
      font-size:13px;min-width:220px;
    }
    .btn{
      border:1px solid var(--line);border-radius:10px;padding:8px 10px;background:#fff;
      font-size:13px;cursor:pointer;
    }
    .btn:hover{border-color:#cbd5e1}
    .grid{
      display:grid;grid-template-columns: 1.55fr .95fr;
      gap:12px;margin-top:12px;
    }
    .panel{
      background:var(--panel);border:1px solid var(--line);border-radius:var(--radius);
      box-shadow:var(--shadow);overflow:hidden;
    }
    .panel h3{
      margin:0;padding:10px 12px;border-bottom:1px solid var(--line);
      font-size:14px;display:flex;gap:10px;align-items:center;
    }
    .panel h3 .sub{color:var(--muted);font-weight:600;font-size:12px}
    .panel .body{padding:10px 12px}
    .tight{padding:0}
    .tableWrap{overflow:visible;max-height:none}
    table{width:100%;border-collapse:separate;border-spacing:0;font-size:12.5px}
    thead th{
      position:sticky;top:0;z-index:3;
      background:linear-gradient(#fff,#fbfbfd);
      border-bottom:1px solid var(--line);
      padding:9px 10px;text-align:left;white-space:nowrap;
      font-size:12px;color:#374151;font-weight:700;
      cursor:pointer;
    }
    tbody td{
      border-bottom:1px solid var(--line);
      padding:8px 10px;white-space:nowrap;
      vertical-align:middle;
    }
    tbody tr:hover{background:#f8fafc}
    tbody tr.sel{outline:2px solid rgba(37,99,235,.25);background:#eff6ff}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .pill{
      display:inline-flex;align-items:center;gap:6px;
      padding:3px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;
      font-size:11px;font-weight:700;
    }
    .up{color:var(--good)}
    .down{color:var(--bad)}
    .wait{color:var(--warn)}
    .muted{color:var(--muted)}
    /* ✅ 필터 신호등 스타일 - 필터에 걸리면 빨간불 */
    .filter-lights{
      display:flex;gap:2px;align-items:center;
    }
    .filter-light{
      width:16px;height:16px;border-radius:3px;
      font-size:7px;font-weight:700;
      display:flex;align-items:center;justify-content:center;
      color:#fff;cursor:help;
      transition:background 0.2s;
    }
    .filter-light.ok{background:#d1d5db;color:#6b7280}  /* 통과: 회색 (꺼진 상태) */
    .filter-light.blocked{background:var(--bad);box-shadow:0 0 6px rgba(220,38,38,0.5)}  /* 차단: 빨간불 */
    .filter-light.na{background:#e5e7eb;color:#9ca3af}
    /* 테이블 열 간격 줄이기 */
    thead th{padding:7px 6px !important;font-size:11px !important}
    tbody td{padding:6px !important}
    .right{display:flex;flex-direction:column;gap:12px}
    .charts{display:grid;grid-template-columns:1fr;gap:12px}
    canvas{width:100% !important;height:240px !important}
    #equityChart{height:360px !important}
    .mini{height:170px !important}
    .sectionRow{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
    .tableWrap.small{max-height:280px}
    details{border-top:1px solid var(--line)}
    summary{padding:10px 12px;cursor:pointer;color:#374151;font-weight:700;font-size:13px}
    .log{max-height:240px;overflow:auto;padding:10px 12px;border-top:1px solid var(--line);font-family:ui-monospace, monospace;font-size:12px}
    .kpi{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
    .kpi .pill{background:#f8fafc}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="chip"><b>KillSwitch</b><span id="ks" class="v off">OFF</span></div>
      <div class="chip"><b>Equity</b><span id="eq" class="v">-</span></div>
      <div class="chip"><b>WS</b><span id="ws" class="v">-</span></div>
      <div class="chip"><b>Feed</b><span id="feed" class="v">-</span></div>
      <div class="chip"><b>Util</b><span id="util" class="v">-</span></div>
      <div class="chip"><b>Brier</b><span id="brier" class="v">-</span></div>
      <div class="chip"><b>Hit%</b><span id="hit" class="v">-</span></div>
      <div class="chip"><b>Selected</b><span id="selSym" class="v">-</span></div>
      <div class="spacer"></div>
      <div class="controls">
        <input id="search" class="input" placeholder="심볼/상태/레짐 검색 (예: BTC, LONG, chop)" />
        <button id="clearTrades" class="btn">트레이드 테이프 비우기</button>
      </div>
    </div>

    <div class="panel tight">
      <h3>시장/신호 테이블 <span class="sub">실시간 랭킹 · Top-4는 자본 배분 대상</span></h3>
      <!-- Top-4 capital allocation summary -->
      <div id="top4Panel" style="padding:10px 12px; display:flex; gap:10px; flex-wrap:wrap; border-bottom:1px solid var(--line)"></div>
      <div class="tableWrap" id="mktWrap">
        <table id="mktTable">
          <thead>
            <tr>
              <th data-k="rank">RANK</th>
              <th data-k="symbol">SYM</th>
              <th data-k="price">PRICE</th>
              <th data-k="status">STATUS</th>
              <th data-k="filters">FILTERS</th>
              <th data-k="unified_score">UNIFIED</th>
              <th data-k="scorep">SCORE%</th>
              <th data-k="kelly">KELLY</th>
              <th data-k="pos_roe">ROE%</th>
              <th data-k="pos_leverage">LEV</th>
              <th data-k="rebalance">REBAL</th>
              <th data-k="delta_ev">ΔEV</th>
              <th data-k="exec_cost">COST</th>
              <th data-k="wgt">WGT</th>
            </tr>
          </thead>
          <tbody id="mktBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel">
      <h3>포트폴리오 그래프 <span class="sub">Equity (미실현 포함 실시간)</span></h3>
      <div class="body">
        <canvas id="equityChart"></canvas>
        <div class="kpi">
          <span class="pill">Balance <span class="mono" id="balKpi">-</span></span>
          <span class="pill">Equity <span class="mono" id="eqKpi">-</span></span>
          <span class="pill">DD <span class="mono" id="ddKpi">-</span></span>
        </div>
      </div>
    </div>

    <div class="panel tight" style="margin-top:12px">
      <h3>현재 포지션 <span class="sub">실시간 수익률/방향/레버리지/진입가/현재가</span></h3>
      <div class="tableWrap small">
        <table>
          <thead>
            <tr>
              <th>SYM</th><th>SIDE</th><th>ENTRY</th><th>CUR</th><th>PNL</th><th>PNL%</th><th>LEV</th><th>CAP%</th><th>AGE(s)</th>
            </tr>
          </thead>
          <tbody id="posBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel tight" style="margin-top:12px">
      <h3>트레이드 테이프 <span class="sub">ENTER/EXIT 내역 (영구 저장된 히스토리 포함)</span></h3>
      <div class="tableWrap">
        <table>
          <thead>
            <tr>
              <th>TIME</th><th>SYM</th><th>TYPE</th><th>SIDE</th><th>PRICE</th><th>PNL</th><th>ROE%</th><th>LEV</th><th>NOTE</th>
            </tr>
          </thead>
          <tbody id="tradeBody"></tbody>
        </table>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>운영 로그 <span class="sub">필요할 때만 펼쳐서 보기</span></h3>
      <details>
        <summary>Logs 펼치기</summary>
        <div id="logs" class="log"></div>
      </details>
    </div>

    <div class="panel" style="margin-top:12px">
      <h3>이상 징후 알림 <span class="sub">자동 감지 이벤트</span></h3>
      <div id="alerts" class="log"></div>
    </div>
  </div>

<script>
  const wsUrl = `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/ws`;
  const ws = new WebSocket(wsUrl);

  const $ = (id)=>document.getElementById(id);
  const ksEl=$('ks'), eqEl=$('eq'), wsEl=$('ws'), feedEl=$('feed'), utilEl=$('util'), brierEl=$('brier'), hitEl=$('hit');
  const selSymEl=$('selSym'), searchEl=$('search');
  const mktBody=$('mktBody'), posBody=$('posBody'), tradeBody=$('tradeBody'), logsEl=$('logs'), alertsEl=$('alerts');
  const balKpi=$('balKpi'), eqKpi=$('eqKpi'), ddKpi=$('ddKpi');

  $('clearTrades').onclick=()=>{
    tradeTape.length = 0;
    seenTradeMsg.clear();
    renderTradeTape();
  };

  // ---------- state ----------
  let selectedSym = null;
  let sortKey = 'symbol';
  let sortAsc = true;

  // history for charts
  const maxPoints = 20000;
  const equityHist = []; // {t, equity}
  const sparkHist = new Map(); // sym -> [price...]

  // trade tape
  const tradeTape = []; // {time,sym,type,side,price,pnl,roe,leverage,tag,reason,note}
  const seenTradeMsg = new Set();
  let equitySeeded = false;

  // ✅ smoother rendering
  let latestPayload = null;
  let rafScheduled = false;

  // ✅ market row cache for smooth update
  const rowCache = new Map(); // symbol -> {tr, cells[]}

  // ---------- helpers ----------
  const f2 = (x)=> (x===null || x===undefined || isNaN(x)) ? '-' : Number(x).toFixed(2);
  const clamp = (a, lo, hi)=>Math.max(lo, Math.min(hi, a));

  function isNum(x){ return x !== null && x !== undefined && !isNaN(Number(x)); }

  // ✅ smooth number update (no design change)
  function smoothSetText(el, target, fmt=(v)=>String(v), durMs=260){
    if(!isNum(target)){
      el.textContent = fmt(target);
      el.dataset.v = '';
      return;
    }
    const to = Number(target);
    const from = isNum(el.dataset.v) ? Number(el.dataset.v) : to;
    if(from === to){
      el.textContent = fmt(to);
      el.dataset.v = String(to);
      return;
    }
    const t0 = performance.now();
    const d = Math.max(80, durMs);
    const step = (t)=>{
      const p = Math.min(1, (t - t0)/d);
      const e = 1 - Math.pow(1-p, 3);
      const v = from + (to - from)*e;
      el.textContent = fmt(v);
      if(p < 1) requestAnimationFrame(step);
      else el.dataset.v = String(to);
    };
    requestAnimationFrame(step);
  }

  function normSym(s){ return (s||'').replace(':USDT',''); }
  function statusClass(status){
    if(status==='LONG') return 'up';
    if(status==='SHORT') return 'down';
    if(status==='WAIT') return 'wait';
    return 'muted';
  }

  // ✅ 필터 신호등 렌더링 함수
  // 필터에 "걸리면" (false) 빨간불, 통과하면 (true) 회색 (꺼진 상태)
  // 라벨: N=NAPV, E=EV, W=Win%, C=CVaR, X=EvtCVaR, D=Direction
  function renderFilterLights(filterStates){
    const filters = [
      { key: 'napv', label: 'N', title: 'NAPV (순현재가치)' },
      { key: 'ev', label: 'E', title: 'EV (기대값 > 0)' },
      { key: 'winrate', label: 'W', title: 'Win% (승률)' },
      { key: 'cvar', label: 'C', title: 'CVaR (위험)' },
      { key: 'event_cvar', label: 'X', title: 'Event CVaR' },
      { key: 'direction', label: 'D', title: 'Direction (방향)' },
    ];
    let html = '<div class="filter-lights">';
    for(const f of filters){
      // filterStates가 없으면 기본값은 true (모두 통과)
      const val = filterStates ? filterStates[f.key] : true;
      // val === true: 통과 → 회색 (ok), val === false: 차단 → 빨간불 (blocked)
      const cls = (val === false) ? 'blocked' : (val === true) ? 'ok' : 'na';
      const statusText = (val === false) ? '❌ 차단' : (val === true) ? '✓ 통과' : '?';
      html += `<span class="filter-light ${cls}" title="${f.title}: ${statusText}">${f.label}</span>`;
    }
    html += '</div>';
    return html;
  }

  // ✅ trade type badge (ENTER/EXIT/REBAL/SPREAD clearly visible)
  function tradeTypeBadge(type){
    if(!type) return '<span class="pill muted">-</span>';
    const t = String(type).toUpperCase();
    if(t === 'ENTER') return '<span class="pill up">ENTER</span>';
    if(t === 'EXIT') return '<span class="pill down">EXIT</span>';
    if(t === 'REBAL') return '<span class="pill">REBAL</span>';
    if(t === 'REBALANCE') return '<span class="pill">REBAL</span>';
    if(t === 'SPREAD') return '<span class="pill wait">SPREAD</span>';
    if(t === 'PYRAMID') return '<span class="pill">PYRAMID</span>';
    if(t === 'KILL') return '<span class="pill down">KILL</span>';
    return `<span class="pill muted">${t}</span>`;
  }

  // Parse log lines like: "[BTC/USDT:USDT] ENTER LONG @ 42000.00"
  function parseTradeMsg(msg){
    if(!msg) return null;
    const m = msg.match(/\\[(.+?)\\]\\s+(ENTER|EXIT|REBAL|REBALANCE|SPREAD|PYRAMID|KILL)\\s*(LONG|SHORT)?\\s*(?:@\\s*([0-9.]+))?/i);
    if(!m) return null;
    const sym = m[1];
    const type = (m[2]||'').toUpperCase();
    const side = (m[3]||'').toUpperCase();
    const price = m[4] ? Number(m[4]) : null;
    const pnlMatch = msg.match(/pnl=([-0-9.]+)/i);
    const roeMatch = msg.match(/roe=([-0-9.]+)/i);
    const pnl = pnlMatch ? Number(pnlMatch[1]) : null;
    const roe = roeMatch ? Number(roeMatch[1]) : null;
    return {sym, type, side, price, pnl, roe, note: msg};
  }

  // ---------- charts ----------
  const equityChart = new Chart($('equityChart'), {
    type:'line',
    data:{
      labels:[],
      datasets:[
        { label:'Equity', data:[], pointRadius:0, borderWidth:2, tension:.25, borderColor:'#2563eb' },
      ]
    },
    options:{
      animation:false,
      responsive:true,
      plugins:{ legend:{display:true} },
      scales:{
        x:{
          display:true,
          ticks:{ autoSkip:true, maxTicksLimit:14 }
        },
        y:{ ticks:{ callback:(v)=>v } }
      }
    }
  });

  function formatTimeLabel(ts, tfMin){
    const d = new Date(ts);
    if(tfMin >= 1440){
      return `${d.getMonth()+1}/${d.getDate()}`;
    }
    if(tfMin >= 60){
      return d.toLocaleString([], {month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});
    }
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
  }

  function buildEquitySeries(){
    const tfMin = 1; // Fixed 1-minute timeframe
    const bucketMs = tfMin * 60 * 1000;
    if(!equityHist.length) return {labels:[], values:[]};
    const buckets = new Map();
    equityHist.forEach(p=>{
      const b = Math.floor(p.t / bucketMs);
      buckets.set(b, p);
    });
    const sorted = Array.from(buckets.entries()).sort((a,b)=>a[0]-b[0]).map(e=>e[1]);
    return {
      labels: sorted.map(p=>formatTimeLabel(p.t, tfMin)),
      values: sorted.map(p=>p.equity),
    };
  }

  function updateEquityChart(){
    const {labels, values} = buildEquitySeries();
    equityChart.data.labels = labels;
    equityChart.data.datasets[0].data = values;
    equityChart.update('none');
  }

  function pushEquityPoint(t, equity){
    equityHist.push({t, equity});
    if(equityHist.length>maxPoints) equityHist.shift();
    updateEquityChart();
  }

  function pushSymPoint(sym, t, price){
    if(!sparkHist.has(sym)) sparkHist.set(sym, []);
    const sp = sparkHist.get(sym);
    sp.push(price);
    if(sp.length>60) sp.shift();
  }

  // ---------- rendering ----------
  function renderMarketTable(rows){
    const q = (searchEl.value||'').trim().toLowerCase();

    const data = (rows||[]).map(x=>{
      const sym = normSym(x.symbol);
      const unified_score = (function(){
        if(x.unified_score!==undefined && x.unified_score!==null) return Number(x.unified_score);
        if(x.meta && x.meta.unified_score!==undefined && x.meta.unified_score!==null) return Number(x.meta.unified_score);
        if(Array.isArray(x.details)){
          for(const d of x.details){
            if(d && d.meta && d.meta.unified_score!==undefined) return Number(d.meta.unified_score);
          }
        }
        if(x.ev!==undefined && x.ev!==null) return Number(x.ev);
        return 0;
      })();
      const scorep = unified_score * 100;
      const confp = (x.conf||0)*100;
      const mc_win = (x.mc_win_rate||0)*100;
      const pos_roe = (x.pos_roe||0)*100;

      const action_type =
        x.action_type ||
        (x.meta && (x.meta.action_type || x.meta.event || x.meta.trade_event)) ||
        '-';

      // ✅ 필터 상태 추출
      let filter_states = x.filter_states || null;
      if(!filter_states && x.meta){
        filter_states = x.meta.filter_states || null;
      }
      if(!filter_states && x.details && Array.isArray(x.details)){
        for(const d of x.details){
          if(d && d.filter_states){
            filter_states = d.filter_states;
            break;
          }
          if(d && d.meta && d.meta.filter_states){
            filter_states = d.meta.filter_states;
            break;
          }
        }
      }
      
      return {
        raw:x,
        symbol:sym,
        price: x.price ?? null,
        status: x.status || 'WAIT',
        regime: x.regime || '-',
        action_type: action_type || '-',
        filter_states: filter_states,  // ✅ 필터 상태 추가
        unified_score,
        scorep,
        confp,
        kelly: x.kelly ?? x.kelly_frac ?? null,
        pos_roe,
        pos_leverage: x.pos_leverage ?? null,
      };
    }).filter(r=>{
      if(!q) return true;
      const hay = `${r.symbol} ${r.status}`.toLowerCase();
      return hay.includes(q);
    });

    // compute ranking by unified score
    data.forEach((d)=>{ d._score_for_rank = isNum(d.unified_score) ? d.unified_score : 0; });

    data.sort((a,b)=>{
      const va = a[sortKey], vb = b[sortKey];
      const na = (va===null||va===undefined) ? -Infinity : va;
      const nb = (vb===null||vb===undefined) ? -Infinity : vb;
      if(na<nb) return sortAsc ? -1 : 1;
      if(na>nb) return sortAsc ? 1 : -1;
      return 0;
    });

    // If user is sorting by default (symbol), inject a computed rank by score
    if(sortKey === 'symbol'){
      const byScore = data.slice().sort((a,b)=> b._score_for_rank - a._score_for_rank);
      const rankMap = new Map();
      byScore.forEach((d,i)=> rankMap.set(d.symbol, i+1));
      data.forEach(d=> d.rank = rankMap.get(d.symbol) || null);
    }

    // ✅ smooth: reuse <tr> nodes, reorder with fragment
    const frag = document.createDocumentFragment();

    data.forEach(r=>{
      let cached = rowCache.get(r.symbol);
      if(!cached){
        const tr = document.createElement('tr');
        const cells = [];
        for(let i=0;i<14;i++){  // 확장: 14열 (rebalance 컬럼 포함)
          const td = document.createElement('td');
          cells.push(td);
          tr.appendChild(td);
        }
        tr.onclick=()=>{
          selectedSym = r.symbol;
          selSymEl.textContent = selectedSym;
          renderMarketTable(rows);
        };
        cached = {tr, cells};
        rowCache.set(r.symbol, cached);
      }

      const tr = cached.tr;
      const c = cached.cells;

      if(selectedSym===r.symbol) tr.classList.add('sel');
      else tr.classList.remove('sel');

      const cls = statusClass(r.status);
      
      // Top-4 표시: rank 1~4는 굵게 표시
      const isTop4 = (r.rank!==null && r.rank!==undefined && r.rank <= 4);

      // column mapping: rank, symbol, price, status, filters, unified, score%, kelly, roe%, lev
      c[0].className = 'mono'; 
      c[0].innerHTML = isTop4 ? `<b style="color:var(--accent)">${r.rank}</b>` : (r.rank!==null && r.rank!==undefined ? String(r.rank) : '-');
      
      c[1].className = 'mono'; 
      c[1].innerHTML = `<b>${r.symbol}</b>`;
      
      c[2].className = 'mono'; 
      c[2].textContent = (r.price!==null?f2(r.price):'-');
      
      c[3].className = ''; 
      c[3].innerHTML = `<span class="pill ${cls}">${r.status}</span>`;
      
      // ✅ 필터 신호등 (FILTERS 열)
      c[4].className = ''; 
      c[4].innerHTML = renderFilterLights(r.filter_states);
      
      c[5].className = 'mono'; 
      c[5].textContent = (isNum(r.unified_score) ? (Number(r.unified_score)*100).toFixed(2) : '-');
      
      c[6].className = `mono ${(r.scorep>=0)?'up':'down'}`; 
      c[6].textContent = (r.scorep===null||r.scorep===undefined)?'-':(isNum(r.scorep)?r.scorep.toFixed(2):r.scorep);
      
      c[7].className = 'mono'; 
      c[7].textContent = (r.kelly===null?'-':(isNum(r.kelly)?f2(r.kelly):r.kelly));
      
      c[8].className = `mono ${(r.pos_roe>=0)?'up':'down'}`; 
      c[8].textContent = (r.pos_roe===null||r.pos_roe===undefined)?'-':(isNum(r.pos_roe)?r.pos_roe.toFixed(2):r.pos_roe);
      
      c[9].className='mono'; 
      c[9].textContent = (r.pos_leverage===null?'-':(isNum(r.pos_leverage)?r.pos_leverage:r.pos_leverage));

      // Rebalance decision badge
      c[10].className = '';
      const reb = r.rebalance_decision || null;
      if(reb===null){ c[10].innerHTML = '<span class="pill muted">-</span>'; }
      else if(reb==='HOLD'){ c[10].innerHTML = '<span class="pill wait">HOLD</span>'; }
      else if(reb==='SWITCH'){ c[10].innerHTML = '<span class="pill">SWITCH</span>'; }
      else { c[10].innerHTML = `<span class="pill muted">${reb}</span>`; }

      // ΔEV (show as percentage if number)
      c[11].className = 'mono';
      c[11].textContent = (r.rebalance_delta_ev===null||r.rebalance_delta_ev===undefined)?'-':(isNum(r.rebalance_delta_ev)?(Number(r.rebalance_delta_ev)*100).toFixed(2):r.rebalance_delta_ev);

      // Exec cost (bps) display
      c[12].className = 'mono';
      c[12].textContent = (r.rebalance_exec_cost===null||r.rebalance_exec_cost===undefined)?'-':(isNum(r.rebalance_exec_cost)?f2(r.rebalance_exec_cost*100):r.rebalance_exec_cost);

      // Joint weight (fraction of leverage allocated)
      c[13].className = 'mono';
      c[13].textContent = (r.rebalance_weight===null||r.rebalance_weight===undefined)?'-':(isNum(r.rebalance_weight)?(Number(r.rebalance_weight)).toFixed(4):r.rebalance_weight);

      frag.appendChild(tr);
    });

    mktBody.replaceChildren(frag);

    if(!selectedSym && data.length){
      selectedSym = data[0].symbol;
      selSymEl.textContent = selectedSym;
    }
  }

  function renderPositions(positions, marketRows){
    const bySym = new Map((marketRows||[]).map(r=>[normSym(r.symbol), r]));

    posBody.innerHTML = '';
    (positions||[]).forEach(p=>{
      const sym = normSym(p.symbol);
      const m = bySym.get(sym) || {};
      const side = p.side || m.status || '-';
      const entry = p.entry_price ?? p.entry ?? null;
      const cur = p.current ?? p.price ?? null;
      const pnl = p.pnl ?? null;

      const lev = p.leverage ?? (m.pos_leverage ?? 1.0);
      const pnlPctRaw = (entry && cur) ? ((side==='LONG' ? (cur-entry) : (entry-cur)) / entry) * 100 : null;
      const pnlPct = pnlPctRaw===null?null:(pnlPctRaw * (lev ?? 1.0));
      const cap = p.cap_frac!==undefined && p.cap_frac!==null ? Number(p.cap_frac)*100 : null;
      const age = p.age_sec ?? (p.time ? Math.max(0, (Date.now()-p.time)/1000) : null);

      const cls = (side==='LONG')?'up':(side==='SHORT')?'down':'muted';
      const pnlCls = (pnl!==null && pnl<0) ? 'down' : 'up';

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="mono"><b>${sym}</b></td>
        <td><span class="pill ${cls}">${side}</span></td>
        <td class="mono">${entry===null?'-':f2(entry)}</td>
        <td class="mono">${cur===null?'-':f2(cur)}</td>
        <td class="mono ${pnlCls}">${pnl===null?'-':f2(pnl)}</td>
        <td class="mono ${pnlPct!==null && pnlPct<0 ? 'down':'up'}">${pnlPct===null?'-':pnlPct.toFixed(2)}</td>
        <td class="mono">${lev===null?'-':lev}</td>
        <td class="mono">${cap===null?'-':cap.toFixed(1)}</td>
        <td class="mono">${age===null?'-':Number(age).toFixed(0)}</td>
      `;
      posBody.appendChild(tr);
    });

    if(!(positions||[]).length){
      posBody.innerHTML = `<tr><td class="muted" colspan="9">열려있는 포지션 없음</td></tr>`;
    }
  }

  function renderTradeTape(){
    tradeBody.innerHTML = '';
    tradeTape.slice(-200).reverse().forEach(t=>{
      const sym = t.sym || t.symbol;

      // ✅ TYPE 확정 로직: payload 우선 → 없으면 문자열 파싱 fallback
      const findType = (txt)=>{ const m = (txt||'').match(/\\b(ENTER|EXIT|REBAL|REBALANCE|SPREAD|PYRAMID|KILL)\\b/i); return m?m[1].toUpperCase():null; };
      let ttype = (t.action_type || t.ttype || t.type || t.event || '').toString().toUpperCase();
      if(ttype === 'REBALANCE') ttype = 'REBAL';
      if(!ttype || ttype==='-'){
        ttype = findType(t.reason) || findType(t.note) || "-";
      }

      const side = (t.side || '').toUpperCase();
      const cls = (side==='LONG')?'up':(side==='SHORT')?'down':'muted';

      const findPnl = (txt)=>{ const pm = (txt||'').match(/pnl=([-0-9.]+)/i); return pm?Number(pm[1]):null; };
      const findRoe = (txt)=>{ const rm = (txt||'').match(/roe=([-0-9.]+)/i); return rm?Number(rm[1]):null; };

      let pnl = (t.pnl!==undefined)?t.pnl:null;
      let roe = (t.roe!==undefined)?t.roe:null;

      if((pnl===null || pnl===undefined)) pnl = findPnl(t.note) ?? findPnl(t.reason);
      if((roe===null || roe===undefined)) roe = findRoe(t.note) ?? findRoe(t.reason);

      if((pnl===null || pnl===undefined) && t.realized_r!==undefined && t.notional){
        try { pnl = Number(t.realized_r) * Number(t.notional); } catch(e){}
      }
      if((roe===null || roe===undefined) && t.realized_r!==undefined){
        try { roe = Number(t.realized_r); } catch(e){}
      }

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="mono">${t.time||'-'}</td>
        <td class="mono"><b>${normSym(sym)}</b></td>
        <td>${tradeTypeBadge(ttype)}</td>
        <td><span class="pill ${cls}">${side||'-'}</span></td>
        <td class="mono">${t.price===null||t.price===undefined?'-':f2(t.price)}</td>
        <td class="mono ${(pnl!==null&&pnl<0)?'down':'up'}">${pnl===null||pnl===undefined?'-':f2(pnl)}</td>
        <td class="mono">${roe===null||roe===undefined?'-':(roe*100).toFixed(2)}</td>
        <td class="mono">${t.leverage===null||t.leverage===undefined?'-':t.leverage}</td>
        <td class="muted">${t.tag||''} ${t.reason||t.note||''}</td>
      `;
      tradeBody.appendChild(tr);
    });

    if(!tradeTape.length){
      tradeBody.innerHTML = `<tr><td class="muted" colspan="9">아직 트레이드 이벤트 없음 (logs에서 ENTER/EXIT가 찍히면 자동으로 들어옴)</td></tr>`;
    }
  }

  function updateTradeTapeFromLogs(logs){
    (logs||[]).forEach(l=>{
      const key = `${l.time}|${l.msg}`;
      if(seenTradeMsg.has(key)) return;
      const p = parseTradeMsg(l.msg);
      if(!p) return;
      seenTradeMsg.add(key);
      tradeTape.push({ time:l.time, ...p });
      if(tradeTape.length>1000) tradeTape.shift();
    });
    renderTradeTape();
  }

  function renderLogs(logs){
    logsEl.innerHTML = '';
    (logs||[]).slice(-250).forEach(l=>{
      const lvl = (l.level||'INFO').toUpperCase();
      logsEl.innerHTML += `<div>[${l.time}] <span class="muted">${lvl}</span> ${l.msg}</div>`;
    });
  }

  function renderAlerts(alerts){
    alertsEl.innerHTML = '';
    (alerts||[]).slice(-200).reverse().forEach(a=>{
      const sev = (a.severity||'info').toUpperCase();
      const ts = a.ts ? new Date(a.ts).toLocaleTimeString() : '-';
      const msg = a.message || '';
      const kind = a.kind || '-';
      const cls = sev==='CRITICAL' ? 'down' : (sev==='WARN' ? 'wait' : 'muted');
      alertsEl.innerHTML += `<div>[${ts}] <span class="pill ${cls}">${sev}</span> <span class="mono">${kind}</span> ${msg}</div>`;
    });
    if(!(alerts||[]).length){
      alertsEl.innerHTML = `<div class="muted">알림 없음</div>`;
    }
  }

  // Sorting
  document.querySelectorAll('#mktTable thead th').forEach(th=>{
    th.addEventListener('click', ()=>{
      const k = th.dataset.k;
      if(!k) return;
      if(sortKey===k) sortAsc = !sortAsc;
      else { sortKey = k; sortAsc = true; }
      if(latestPayload && latestPayload.market) renderMarketTable(latestPayload.market);
    });
  });

  searchEl.addEventListener('input', ()=>{
    if(latestPayload && latestPayload.market) renderMarketTable(latestPayload.market);
  });

  function applyUpdate(d){
    if(d.type !== 'full_update') return;

    // topbar
    const ksOn = !!(d.kill_switch || (d.engine && d.engine.safety_mode));
    ksEl.textContent = ksOn ? 'ON' : 'OFF';
    ksEl.className = `v ${ksOn?'on':'off'}`;

    const equity = Number((d.portfolio && d.portfolio.equity) || 0);
    smoothSetText(eqEl, equity, (v)=>Number(v).toFixed(2), 260);

    wsEl.textContent = (d.engine && d.engine.ws_clients !== undefined) ? d.engine.ws_clients : '-';
    feedEl.textContent = (d.feed && d.feed.connected) ? 'OK' : 'STALE';

    const utilVal = (d.portfolio && d.portfolio.utilization!==undefined) ? d.portfolio.utilization : null;
    const utilCap = d.portfolio ? d.portfolio.utilization_cap : null;
    utilEl.textContent = utilVal===null?'-':(utilVal*100).toFixed(1)+'%'+(utilCap?`/${(utilCap*100).toFixed(0)}%`:'');

    const evalm = d.eval_metrics || {};
    brierEl.textContent = evalm.brier===null||evalm.brier===undefined?'-':evalm.brier.toFixed(4);
    hitEl.textContent = evalm.hit_rate===null||evalm.hit_rate===undefined?'-':(evalm.hit_rate*100).toFixed(1)+'%';
    selSymEl.textContent = selectedSym || '-';

    // KPIs
    const bal = Number((d.portfolio && d.portfolio.balance) || 0);
    smoothSetText(balKpi, bal, (v)=>Number(v).toFixed(2), 260);
    smoothSetText(eqKpi, equity, (v)=>Number(v).toFixed(2), 260);

    // dd
    const peak = equityHist.reduce((m,p)=>Math.max(m,p.equity), equity);
    const dd = peak>0 ? ((equity-peak)/peak)*100 : 0;
    ddKpi.textContent = `${dd.toFixed(2)}%`;

    // seed history
    if(!equitySeeded && d.portfolio && Array.isArray(d.portfolio.history) && d.portfolio.history.length){
      equityHist.length = 0;
      d.portfolio.history.forEach(p=>{
        equityHist.push({t:p.time || p.ts || Date.now(), equity:p.equity});
      });
      equitySeeded = true;
      updateEquityChart();
    }

    const t = d.server_time || Date.now();
    pushEquityPoint(t, equity);

    // market
    const rows = d.market || [];
    rows.forEach(x=>{
      const sym = normSym(x.symbol);
      const price = Number(x.price || 0);
      pushSymPoint(sym, t, price);
    });
    // render top-4 summary and full market table
    renderTop4(rows);
    renderMarketTable(rows);

    // positions
    const positions = (d.portfolio && d.portfolio.positions) ? d.portfolio.positions : [];
    renderPositions(positions, rows);

    // trade tape: payload 우선 → logs fallback
    if(Array.isArray(d.trade_tape) && d.trade_tape.length){
      tradeTape.length = 0;
      d.trade_tape.slice(-500).forEach(t=> tradeTape.push(t));
      renderTradeTape();
    } else {
      updateTradeTapeFromLogs(d.logs || []);
    }

    renderLogs(d.logs || []);
    renderAlerts(d.alerts || []);
  }

  ws.onmessage = (e)=>{
    try{
      latestPayload = JSON.parse(e.data);
    }catch(_){
      return;
    }
    if(!rafScheduled){
      rafScheduled = true;
      requestAnimationFrame(()=>{
        rafScheduled = false;
        applyUpdate(latestPayload);
      });
    }
  };

  // ---------- Top-4 rendering ----------
  function renderTop4(rows){
    const out = $('top4Panel');
    if(!out) return;
    
    const data = (rows||[]).map(x=>{
      const sym = normSym(x.symbol);
      const unified = (x.unified_score!==undefined && x.unified_score!==null) ? Number(x.unified_score) :
                      (x.meta && x.meta.unified_score!==undefined && x.meta.unified_score!==null) ? Number(x.meta.unified_score) :
                      (x.ev!==undefined && x.ev!==null ? Number(x.ev) : 0);
      const scorep = unified * 100;
      return {
        raw:x,
        symbol:sym,
        unified_score: unified,
        scorep: scorep,
        price: x.price ?? null,
        status: x.status || 'WAIT',
        regime: x.regime || '-',
      };
    });
    
    // Unified score 기준 정렬
    const byScore = data.slice().sort((a,b)=> (b.unified_score||0) - (a.unified_score||0));
    const top = byScore.slice(0,4);
    
    out.innerHTML = '';
    if(top.length===0){
      out.innerHTML = '<div class="muted" style="padding:8px">Top-4: 데이터 없음</div>';
      return;
    }
    
    top.forEach((t,i)=>{
      const pct = 25; // 각 25%
      const card = document.createElement('div');
      card.style.cssText = 'padding:10px 14px;border:2px solid var(--accent);border-radius:12px;background:linear-gradient(135deg, #fff 0%, #f8fafc 100%);min-width:180px;flex:1';
      
      const statusCls = (t.status==='LONG')?'up':(t.status==='SHORT')?'down':'muted';
      
      card.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <div style="font-size:20px;font-weight:900;color:var(--accent)">#${i+1}</div>
          <div style="font-size:16px;font-weight:700">${t.symbol}</div>
        </div>
        <div style="font-size:11px;color:var(--muted);margin-bottom:4px">자본 배분: <b style="color:var(--accent)">${pct}%</b></div>
        <div style="display:flex;gap:12px;font-size:12px">
          <div><span style="color:var(--muted)">Score:</span> <b class="${(t.scorep>=0)?'up':'down'}">${t.scorep.toFixed(2)}%</b></div>
          <div><span style="color:var(--muted)">Status:</span> <span class="pill ${statusCls}" style="font-size:10px;padding:2px 6px">${t.status}</span></div>
        </div>
        <div style="margin-top:4px;font-size:11px;color:var(--muted)">Regime: ${t.regime}</div>
      `;
      out.appendChild(card);
    });
  }
</script>
</body>
</html>
